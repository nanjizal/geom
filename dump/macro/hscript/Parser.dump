class hscript.Parser {

	public function new() {
		this.uid = 0;
		this.preprocesorValues = new haxe.ds.StringMap();
		this.line = 1;
		this.opChars = "+*/-=!><&|^%~";
		this.identChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
		var priorities = [["%"], ["*", "/"], ["+", "-"], ["<<", ">>", ">>>"], ["|", "&", "^"], ["==", "!=", ">", "<", ">=", "<="], ["..."], ["&&"], ["||"], ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "&=", "^=", "=>"]];
		this.opPriority = new haxe.ds.StringMap();
		this.opRightAssoc = new haxe.ds.StringMap();
		this.unops = new haxe.ds.StringMap();
		{
			var _g = 0;
			var _g1 = priorities.length;
			while ((_g < _g1)) {
				var i = _g ++;
				{
					var _g = 0;
					var _g1 = priorities[i];
					while ((_g < _g1.length)) {
						var x = _g1[_g];
						++ _g;
						cast cast this.opPriority.set(x, i);
						if ((i == 9)) cast cast this.opRightAssoc.set(x, true);
					};
				};
			};
		};
		{
			{
				var x = "!";
				cast cast this.unops.set(x, x == "++" || x == "--");
			};
			{
				var x = "++";
				cast cast this.unops.set(x, x == "++" || x == "--");
			};
			{
				var x = "--";
				cast cast this.unops.set(x, x == "++" || x == "--");
			};
			{
				var x = "-";
				cast cast this.unops.set(x, x == "++" || x == "--");
			};
			{
				var x = "~";
				cast cast this.unops.set(x, x == "++" || x == "--");
			};
		};
	}

	public var line:Int;

	public var opChars:String;

	public var identChars:String;

	public var opPriority:Map<String, Int>;

	public var opRightAssoc:Map<String, Bool>;

	public var unops:Map<String, Bool>;

	@:value(new Map())
	public var preprocesorValues:Map<String, Dynamic>;

	public var allowJSON:Bool;

	public var allowTypes:Bool;

	public var allowMetadata:Bool;

	var input:haxe.io.Input;

	var char:Int;

	var ops:Array<Bool>;

	var idents:Array<Bool>;

	@:value(0)
	var uid:Int;

	var tokens:haxe.ds.GenericStack<hscript.Token>;

	public function error(err:hscript.Error, pmin:Int, pmax:Int) {
		throw throw haxe.Exception.thrown(err);
	}

	public function invalidChar(c:Int) {
		this.error(hscript.Error.EInvalidChar(c), 0 - 1, 0 - 1);
	}

	function initParser(origin:Null<String>) {
		this.preprocStack = [];
		this.tokens = new haxe.ds.GenericStack();
		this.char = -1;
		this.ops = new Array();
		this.idents = new Array();
		this.uid = 0;
		{
			var ` = 0;
			var `1 = this.opChars.length;
			while (` < `1) {
				var i = ` ++;
				this.ops[this.opChars.charCodeAt(i)] = true;
			};
		};
		{
			var `2 = 0;
			var `3 = this.identChars.length;
			while (`2 < `3) {
				var i = `2 ++;
				this.idents[this.identChars.charCodeAt(i)] = true;
			};
		};
	}

	@:value({ origin : "hscript" })
	public function parseString(s:String, origin:Null<String> = "hscript") {
		return this.parse(new haxe.io.StringInput(s), origin);
	}

	@:value({ origin : "hscript" })
	public function parse(s:haxe.io.Input, origin:Null<String> = "hscript") {
		this.initParser(origin);
		this.input = s;
		var a = new Array();
		while (true) {
			var tk = this.token();
			if (tk == hscript.Token.TEof) {
				break;
			};
			this.push(tk);
			this.parseFullExpr(a);
		};
		return if (a.length == 1) {
			a[0];
		} else {
			this.mk(hscript.Expr.EBlock(a), 0, null);
		};
	}

	function unexpected(tk:hscript.Token) {
		this.error(hscript.Error.EUnexpected(this.tokenString(tk)), 0, 0);
		return null;
	}

	function push(tk:hscript.Token) {
		this.tokens.add(tk);
	}

	function ensure(tk:Null<hscript.Token>) {
		var t = this.token();
		if (t != tk) {
			this.unexpected(t);
		};
	}

	function ensureToken(tk:Null<hscript.Token>) {
		var t = this.token();
		if (! Type.enumEq(t, tk)) {
			this.unexpected(t);
		};
	}

	function maybe(tk:Null<hscript.Token>) {
		var t = this.token();
		if (Type.enumEq(t, tk)) {
			return true;
		};
		this.push(t);
		return false;
	}

	function getIdent() {
		var tk = this.token();
		@:ast(switch (tk) {
	case TId(id):
		return id;	
	default:
		unexpected(tk);
		return null;	
}) if (tk == null) {
			this.unexpected(tk);
			return null;
		} else if (enumIndex tk == 2) {
			var ` = tk[0];
			{
				var id = `;
				{
					return id;
				};
			};
		} else {
			this.unexpected(tk);
			return null;
		};
	}

	function expr(e:hscript.Expr) {
		return e;
	}

	function pmin(e:hscript.Expr) {
		return 0;
	}

	function pmax(e:hscript.Expr) {
		return 0;
	}

	function mk(e:hscript.Expr, pmin:Null<Int> = null, pmax:Null<Int> = null) {
		return e;
	}

	function isBlock(e:hscript.Expr) {
		return @:ast(switch (expr(e)) {
	case EBlock(_), EObject(_), ESwitch(_):
		true;	
	case EFunction(_, e, _, _):
		isBlock(e);	
	case EVar(_, t, e):
		e != null ? isBlock(e) : t != null ? t.match(CTAnon(_)) : false;	
	case EIf(_, e1, e2):
		if (e2 != null) isBlock(e2) else isBlock(e1);	
	case EBinop(_, _, e):
		isBlock(e);	
	case EUnop(_, prefix, e):
		!prefix && isBlock(e);	
	case EWhile(_, e):
		isBlock(e);	
	case EDoWhile(_, e):
		isBlock(e);	
	case EFor(_, _, e):
		isBlock(e);	
	case EReturn(e):
		e != null && isBlock(e);	
	case ETry(_, _, _, e):
		isBlock(e);	
	case EMeta(_, _, e):
		isBlock(e);	
	default:
		false;	
}) {
			var ` = this.expr(e);
			switch (enumIndex `) {
				case 2: {
					var `23 = `[2];
					var `22 = `[1];
					var `21 = `[0];
					{
						var e = `23;
						var t = `22;
						{
							if (e != null) {
								this.isBlock(e);
							} else {
								if (t != null) {
									if (t == null) false else if (enumIndex t == 2) {
										var ` = t[0];
										true;
									} else false;
								} else {
									false;
								};
							};
						};
					};
				};
				case 4: {
					var `11 = `[0];
					{
						true;
					};
				};
				case 6: {
					var `30 = `[2];
					var `29 = `[1];
					var `28 = `[0];
					{
						var e = `30;
						{
							this.isBlock(e);
						};
					};
				};
				case 7: {
					var `10 = `[2];
					var `9 = `[1];
					var `8 = `[0];
					{
						var e = `10;
						var prefix = `9;
						{
							! prefix && this.isBlock(e);
						};
					};
				};
				case 9: {
					var `3 = `[2];
					var `2 = `[1];
					var `1 = `[0];
					{
						var e2 = `3;
						var e1 = `2;
						{
							if (e2 != null) {
								this.isBlock(e2);
							} else {
								this.isBlock(e1);
							};
						};
					};
				};
				case 10: {
					var `13 = `[1];
					var `12 = `[0];
					{
						var e = `13;
						{
							this.isBlock(e);
						};
					};
				};
				case 11: {
					var `19 = `[2];
					var `18 = `[1];
					var `17 = `[0];
					{
						var e = `19;
						{
							this.isBlock(e);
						};
					};
				};
				case 14: {
					var `27 = `[3];
					var `26 = `[2];
					var `25 = `[1];
					var `24 = `[0];
					{
						var e = `25;
						{
							this.isBlock(e);
						};
					};
				};
				case 15: {
					var `33 = `[0];
					{
						var e = `33;
						{
							e != null && this.isBlock(e);
						};
					};
				};
				case 20: {
					var `7 = `[3];
					var `6 = `[2];
					var `5 = `[1];
					var `4 = `[0];
					{
						var e = `7;
						{
							this.isBlock(e);
						};
					};
				};
				case 21: {
					var `20 = `[0];
					{
						true;
					};
				};
				case 23: {
					var `16 = `[2];
					var `15 = `[1];
					var `14 = `[0];
					{
						true;
					};
				};
				case 24: {
					var `32 = `[1];
					var `31 = `[0];
					{
						var e = `32;
						{
							this.isBlock(e);
						};
					};
				};
				case 25: {
					var `36 = `[2];
					var `35 = `[1];
					var `34 = `[0];
					{
						var e = `36;
						{
							this.isBlock(e);
						};
					};
				};
				default: {
					false;
				}
			};
		};
	}

	function parseFullExpr(exprs:Array<hscript.Expr>) {
		var e = this.parseExpr();
		exprs.push(e);
		var tk = this.token();
		while (tk == hscript.Token.TComma && {
			var ` = this.expr(e);
			if (enumIndex ` == 2) {
				var `3 = `[2];
				var `2 = `[1];
				var `1 = `[0];
				true;
			} else false;
		}) {
			e = this.parseStructure("var");
			exprs.push(e);
			tk = this.token();
		};
		if (tk != hscript.Token.TSemicolon && tk != hscript.Token.TEof) {
			if (this.isBlock(e)) {
				this.push(tk);
			} else {
				this.unexpected(tk);
			};
		};
	}

	function parseObject(p1:Null<Int>) {
		var fl = new Array();
		while (true) {
			var tk = this.token();
			var id = null;
			@:ast(switch (tk) {
	case TId(i):
		id = i;	
	case TConst(c):
		if (!allowJSON) unexpected(tk);
		switch (c) {
			case CString(s):
				id = s;			
			default:
				unexpected(tk);			
		};	
	case TBrClose:
		break;	
	default:
		unexpected(tk);	
}) if (tk == null) {
				this.unexpected(tk);
			} else switch (enumIndex tk) {
				case 1: {
					var ` = tk[0];
					{
						var c = `;
						{
							if (! this.allowJSON) {
								this.unexpected(tk);
							};
							@:ast(switch (c) {
	case CString(s):
		id = s;	
	default:
		unexpected(tk);	
}) if (enumIndex c == 2) {
								var ` = c[0];
								{
									var s = `;
									{
										id = s;
									};
								};
							} else {
								this.unexpected(tk);
							};
						};
					};
				};
				case 2: {
					var `1 = tk[0];
					{
						var i = `1;
						{
							id = i;
						};
					};
				};
				case 7: {
					{
						break;
					};
				};
				default: {
					this.unexpected(tk);
				}
			};
			this.ensure(hscript.Token.TDoubleDot);
			fl.push({name : id, e : this.parseExpr()});
			tk = this.token();
			@:ast(switch (tk) {
	case TBrClose:
		break;	
	case TComma:
	default:
		unexpected(tk);	
}) if (tk == null) {
				this.unexpected(tk);
			} else switch (enumIndex tk) {
				case 7: {
					{
						break;
					};
				};
				case 9: {
					{};
				};
				default: {
					this.unexpected(tk);
				}
			};
		};
		return this.parseExprNext(this.mk(hscript.Expr.EObject(fl), p1, null));
	}

	function parseExpr() {
		var tk = this.token();
		@:ast(switch (tk) {
	case TId(id):
		var e = parseStructure(id);
		if (e == null) e = mk(EIdent(id));
		return parseExprNext(e);	
	case TConst(c):
		return parseExprNext(mk(EConst(c)));	
	case TPOpen:
		var e = parseExpr();
		tk = token();
		switch (tk) {
			case TPClose:
				return parseExprNext(mk(EParent(e), p1, tokenMax));			
			case TDoubleDot:
				var t = parseType();
				tk = token();
				switch (tk) {
					case TPClose:
						return parseExprNext(mk(ECheckType(e, t), p1, tokenMax));					
					case TComma:
						switch (expr(e)) {
							case EIdent(v):
								return parseLambda([{ name : v, t : t }], pmin(e));							
							default:
						};					
					default:
				};			
			case TComma:
				switch (expr(e)) {
					case EIdent(v):
						return parseLambda([{ name : v }], pmin(e));					
					default:
				};			
			default:
		};
		return unexpected(tk);	
	case TBrOpen:
		tk = token();
		switch (tk) {
			case TBrClose:
				return parseExprNext(mk(EObject([]), p1));			
			case TId(_):
				var tk2 = token();
				push(tk2);
				push(tk);
				switch (tk2) {
					case TDoubleDot:
						return parseExprNext(parseObject(p1));					
					default:
				};			
			case TConst(c):
				if (allowJSON) {
					switch (c) {
						case CString(_):
							var tk2 = token();
							push(tk2);
							push(tk);
							switch (tk2) {
								case TDoubleDot:
									return parseExprNext(parseObject(p1));								
								default:
							};						
						default:
							push(tk);						
					};
				} else push(tk);			
			default:
				push(tk);			
		};
		var a = new Array();
		while (true) {
			parseFullExpr(a);
			tk = token();
			if (tk == TBrClose) break;
			push(tk);
		};
		return mk(EBlock(a), p1);	
	case TOp(op):
		if (unops.exists(op)) {
			var start = tokenMin;
			var e = parseExpr();
			if (op == "-") switch (expr(e)) {
				case EConst(CInt(i)):
					return mk(EConst(CInt(-i)), start, pmax(e));				
				case EConst(CFloat(f)):
					return mk(EConst(CFloat(-f)), start, pmax(e));				
				default:
			};
			return makeUnop(op, e);
		};
		return unexpected(tk);	
	case TBkOpen:
		var a = new Array();
		tk = token();
		while (tk != TBkClose) {
			push(tk);
			a.push(parseExpr());
			tk = token();
			if (tk == TComma) tk = token();
		};
		if (a.length == 1) switch (expr(a[0])) {
			case EFor(_), EWhile(_), EDoWhile(_):
				var tmp = "__a_" + (uid++);
				var e = mk(EBlock([mk(EVar(tmp, null, mk(EArrayDecl([]), p1)), p1), mapCompr(tmp, a[0]), mk(EIdent(tmp), p1)]), p1);
				return parseExprNext(e);			
			default:
		};
		return parseExprNext(mk(EArrayDecl(a), p1));	
	case TMeta(id) if (allowMetadata):
		var args = parseMetaArgs();
		return mk(EMeta(id, args, parseExpr()), p1);	
	default:
		return unexpected(tk);	
}) if (tk == null) {
			return this.unexpected(tk);
		} else switch (enumIndex tk) {
			case 1: {
				var ` = tk[0];
				{
					var c = `;
					{
						return this.parseExprNext(this.mk(hscript.Expr.EConst(c), null, null));
					};
				};
			};
			case 2: {
				var `1 = tk[0];
				{
					var id = `1;
					{
						var e = this.parseStructure(id);
						if (e == null) {
							e = this.mk(hscript.Expr.EIdent(id), null, null);
						};
						return this.parseExprNext(e);
					};
				};
			};
			case 3: {
				var `3 = tk[0];
				{
					var op = `3;
					{
						if ({
							var this = this.unops;
							cast this.exists(op);
						}) {
							var start = 0;
							var e = this.parseExpr();
							if (op == "-") {
								@:ast(switch (expr(e)) {
	case EConst(CInt(i)):
		return mk(EConst(CInt(-i)), start, pmax(e));	
	case EConst(CFloat(f)):
		return mk(EConst(CFloat(-f)), start, pmax(e));	
	default:
}) {
									var ` = this.expr(e);
									if (enumIndex ` == 0) {
										var `1 = `[0];
										switch (enumIndex `1) {
											case 0: {
												var `2 = `1[0];
												{
													var i = `2;
													{
														return this.mk(hscript.Expr.EConst(hscript.Const.CInt(- i)), start, this.pmax(e));
													};
												};
											};
											case 1: {
												var `3 = `1[0];
												{
													var f = `3;
													{
														return this.mk(hscript.Expr.EConst(hscript.Const.CFloat(- f)), start, this.pmax(e));
													};
												};
											};
											default: {}
										};
									} else {};
								};
							};
							return this.makeUnop(op, e);
						};
						return this.unexpected(tk);
					};
				};
			};
			case 4: {
				{
					var e = this.parseExpr();
					tk = this.token();
					@:ast(switch (tk) {
	case TPClose:
		return parseExprNext(mk(EParent(e), p1, tokenMax));	
	case TDoubleDot:
		var t = parseType();
		tk = token();
		switch (tk) {
			case TPClose:
				return parseExprNext(mk(ECheckType(e, t), p1, tokenMax));			
			case TComma:
				switch (expr(e)) {
					case EIdent(v):
						return parseLambda([{ name : v, t : t }], pmin(e));					
					default:
				};			
			default:
		};	
	case TComma:
		switch (expr(e)) {
			case EIdent(v):
				return parseLambda([{ name : v }], pmin(e));			
			default:
		};	
	default:
}) if (tk == null) {} else switch (enumIndex tk) {
						case 5: {
							{
								return this.parseExprNext(this.mk(hscript.Expr.EParent(e), 0, 0));
							};
						};
						case 9: {
							{
								@:ast(switch (expr(e)) {
	case EIdent(v):
		return parseLambda([{ name : v }], pmin(e));	
	default:
}) {
									var ` = this.expr(e);
									if (enumIndex ` == 1) {
										var `1 = `[0];
										{
											var v = `1;
											{
												return this.parseLambda([{name : v}], this.pmin(e));
											};
										};
									} else {};
								};
							};
						};
						case 14: {
							{
								var t = this.parseType();
								tk = this.token();
								@:ast(switch (tk) {
	case TPClose:
		return parseExprNext(mk(ECheckType(e, t), p1, tokenMax));	
	case TComma:
		switch (expr(e)) {
			case EIdent(v):
				return parseLambda([{ name : v, t : t }], pmin(e));			
			default:
		};	
	default:
}) if (tk == null) {} else switch (enumIndex tk) {
									case 5: {
										{
											return this.parseExprNext(this.mk(hscript.Expr.ECheckType(e, t), 0, 0));
										};
									};
									case 9: {
										{
											@:ast(switch (expr(e)) {
	case EIdent(v):
		return parseLambda([{ name : v, t : t }], pmin(e));	
	default:
}) {
												var ` = this.expr(e);
												if (enumIndex ` == 1) {
													var `1 = `[0];
													{
														var v = `1;
														{
															return this.parseLambda([{name : v, t : t}], this.pmin(e));
														};
													};
												} else {};
											};
										};
									};
									default: {}
								};
							};
						};
						default: {}
					};
					return this.unexpected(tk);
				};
			};
			case 6: {
				{
					tk = this.token();
					@:ast(switch (tk) {
	case TBrClose:
		return parseExprNext(mk(EObject([]), p1));	
	case TId(_):
		var tk2 = token();
		push(tk2);
		push(tk);
		switch (tk2) {
			case TDoubleDot:
				return parseExprNext(parseObject(p1));			
			default:
		};	
	case TConst(c):
		if (allowJSON) {
			switch (c) {
				case CString(_):
					var tk2 = token();
					push(tk2);
					push(tk);
					switch (tk2) {
						case TDoubleDot:
							return parseExprNext(parseObject(p1));						
						default:
					};				
				default:
					push(tk);				
			};
		} else push(tk);	
	default:
		push(tk);	
}) if (tk == null) {
						this.push(tk);
					} else switch (enumIndex tk) {
						case 1: {
							var ` = tk[0];
							{
								var c = `;
								{
									if (this.allowJSON) {
										@:ast(switch (c) {
	case CString(_):
		var tk2 = token();
		push(tk2);
		push(tk);
		switch (tk2) {
			case TDoubleDot:
				return parseExprNext(parseObject(p1));			
			default:
		};	
	default:
		push(tk);	
}) if (enumIndex c == 2) {
											var ` = c[0];
											{
												var tk2 = this.token();
												this.push(tk2);
												this.push(tk);
												@:ast(switch (tk2) {
	case TDoubleDot:
		return parseExprNext(parseObject(p1));	
	default:
}) if (tk2 == null) {} else if (enumIndex tk2 == 14) {
													{
														return this.parseExprNext(this.parseObject(0));
													};
												} else {};
											};
										} else {
											this.push(tk);
										};
									} else {
										this.push(tk);
									};
								};
							};
						};
						case 2: {
							var `1 = tk[0];
							{
								var tk2 = this.token();
								this.push(tk2);
								this.push(tk);
								@:ast(switch (tk2) {
	case TDoubleDot:
		return parseExprNext(parseObject(p1));	
	default:
}) if (tk2 == null) {} else if (enumIndex tk2 == 14) {
									{
										return this.parseExprNext(this.parseObject(0));
									};
								} else {};
							};
						};
						case 7: {
							{
								return this.parseExprNext(this.mk(hscript.Expr.EObject([]), 0, null));
							};
						};
						default: {
							this.push(tk);
						}
					};
					var a = new Array();
					while (true) {
						this.parseFullExpr(a);
						tk = this.token();
						if (tk == hscript.Token.TBrClose) {
							break;
						};
						this.push(tk);
					};
					return this.mk(hscript.Expr.EBlock(a), 0, null);
				};
			};
			case 11: {
				{
					var a = new Array();
					tk = this.token();
					while (tk != hscript.Token.TBkClose) {
						this.push(tk);
						a.push(this.parseExpr());
						tk = this.token();
						if (tk == hscript.Token.TComma) {
							tk = this.token();
						};
					};
					if (a.length == 1) {
						@:ast(switch (expr(a[0])) {
	case EFor(_), EWhile(_), EDoWhile(_):
		var tmp = "__a_" + (uid++);
		var e = mk(EBlock([mk(EVar(tmp, null, mk(EArrayDecl([]), p1)), p1), mapCompr(tmp, a[0]), mk(EIdent(tmp), p1)]), p1);
		return parseExprNext(e);	
	default:
}) {
							var ` = this.expr(a[0]);
							switch (enumIndex `) {
								case 10: {
									var `2 = `[1];
									var `1 = `[0];
									{
										var tmp = "__a_" + (this.uid ++);
										var e = this.mk(hscript.Expr.EBlock([this.mk(hscript.Expr.EVar(tmp, null, this.mk(hscript.Expr.EArrayDecl([]), 0, null)), 0, null), this.mapCompr(tmp, a[0]), this.mk(hscript.Expr.EIdent(tmp), 0, null)]), 0, null);
										return this.parseExprNext(e);
									};
								};
								case 11: {
									var `5 = `[2];
									var `4 = `[1];
									var `3 = `[0];
									{
										var tmp = "__a_" + (this.uid ++);
										var e = this.mk(hscript.Expr.EBlock([this.mk(hscript.Expr.EVar(tmp, null, this.mk(hscript.Expr.EArrayDecl([]), 0, null)), 0, null), this.mapCompr(tmp, a[0]), this.mk(hscript.Expr.EIdent(tmp), 0, null)]), 0, null);
										return this.parseExprNext(e);
									};
								};
								case 24: {
									var `7 = `[1];
									var `6 = `[0];
									{
										var tmp = "__a_" + (this.uid ++);
										var e = this.mk(hscript.Expr.EBlock([this.mk(hscript.Expr.EVar(tmp, null, this.mk(hscript.Expr.EArrayDecl([]), 0, null)), 0, null), this.mapCompr(tmp, a[0]), this.mk(hscript.Expr.EIdent(tmp), 0, null)]), 0, null);
										return this.parseExprNext(e);
									};
								};
								default: {}
							};
						};
					};
					return this.parseExprNext(this.mk(hscript.Expr.EArrayDecl(a), 0, null));
				};
			};
			case 15: {
				var `2 = tk[0];
				{
					var id = `2;
					if (this.allowMetadata) {
						var args = this.parseMetaArgs();
						return this.mk(hscript.Expr.EMeta(id, args, this.parseExpr()), 0, null);
					} else {
						return this.unexpected(tk);
					};
				};
			};
			default: {
				return this.unexpected(tk);
			}
		};
	}

	function parseLambda(args:Array<hscript.Argument>, pmin:Null<Int>) {
		while (true) {
			var id = this.getIdent();
			var t = if (this.maybe(hscript.Token.TDoubleDot)) {
				this.parseType();
			} else {
				null;
			};
			args.push({name : id, t : t});
			var tk = this.token();
			@:ast(switch (tk) {
	case TComma:
	case TPClose:
		break;	
	default:
		unexpected(tk);	
}) if (tk == null) {
				this.unexpected(tk);
			} else switch (enumIndex tk) {
				case 5: {
					{
						break;
					};
				};
				case 9: {
					{};
				};
				default: {
					this.unexpected(tk);
				}
			};
		};
		this.ensureToken(hscript.Token.TOp("->"));
		var eret = this.parseExpr();
		return this.mk(hscript.Expr.EFunction(args, this.mk(hscript.Expr.EReturn(eret), pmin, null), null, null), pmin, null);
	}

	function parseMetaArgs() {
		var tk = this.token();
		if (tk != hscript.Token.TPOpen) {
			this.push(tk);
			return null;
		};
		var args = [];
		tk = this.token();
		if (tk != hscript.Token.TPClose) {
			this.push(tk);
			while (true) {
				args.push(this.parseExpr());
				@:ast(switch (token()) {
	case TComma:
	case TPClose:
		break;	
	case tk:
		unexpected(tk);	
}) {
					var ` = this.token();
					if (` == null) {
						var tk = `;
						{
							this.unexpected(tk);
						};
					} else switch (enumIndex `) {
						case 5: {
							{
								break;
							};
						};
						case 9: {
							{};
						};
						default: {
							var tk = `;
							{
								this.unexpected(tk);
							};
						}
					};
				};
			};
		};
		return args;
	}

	function mapCompr(tmp:String, e:hscript.Expr) {
		var edef = @:ast(switch (expr(e)) {
	case EFor(v, it, e2):
		EFor(v, it, mapCompr(tmp, e2));	
	case EWhile(cond, e2):
		EWhile(cond, mapCompr(tmp, e2));	
	case EDoWhile(cond, e2):
		EDoWhile(cond, mapCompr(tmp, e2));	
	case EIf(cond, e1, e2) if (e2 == null):
		EIf(cond, mapCompr(tmp, e1), null);	
	case EBlock([e]):
		EBlock([mapCompr(tmp, e)]);	
	case EParent(e2):
		EParent(mapCompr(tmp, e2));	
	default:
		ECall(mk(EField(mk(EIdent(tmp), pmin(e), pmax(e)), "push"), pmin(e), pmax(e)), [e]);	
}) {
			var ` = this.expr(e);
			switch (enumIndex `) {
				case 3: {
					var `13 = `[0];
					{
						var e2 = `13;
						{
							hscript.Expr.EParent(this.mapCompr(tmp, e2));
						};
					};
				};
				case 4: {
					var `6 = `[0];
					if (`6.length == 1) {
						var `7 = `6[0];
						{
							var e = `7;
							{
								hscript.Expr.EBlock([this.mapCompr(tmp, e)]);
							};
						};
					} else {
						hscript.Expr.ECall(this.mk(hscript.Expr.EField(this.mk(hscript.Expr.EIdent(tmp), this.pmin(e), this.pmax(e)), "push"), this.pmin(e), this.pmax(e)), [e]);
					};
				};
				case 9: {
					var `3 = `[2];
					var `2 = `[1];
					var `1 = `[0];
					{
						var e2 = `3;
						var e1 = `2;
						var cond = `1;
						if (e2 == null) {
							hscript.Expr.EIf(cond, this.mapCompr(tmp, e1), null);
						} else {
							hscript.Expr.ECall(this.mk(hscript.Expr.EField(this.mk(hscript.Expr.EIdent(tmp), this.pmin(e), this.pmax(e)), "push"), this.pmin(e), this.pmax(e)), [e]);
						};
					};
				};
				case 10: {
					var `5 = `[1];
					var `4 = `[0];
					{
						var e2 = `5;
						var cond = `4;
						{
							hscript.Expr.EWhile(cond, this.mapCompr(tmp, e2));
						};
					};
				};
				case 11: {
					var `10 = `[2];
					var `9 = `[1];
					var `8 = `[0];
					{
						var e2 = `10;
						var it = `9;
						var v = `8;
						{
							hscript.Expr.EFor(v, it, this.mapCompr(tmp, e2));
						};
					};
				};
				case 24: {
					var `12 = `[1];
					var `11 = `[0];
					{
						var e2 = `12;
						var cond = `11;
						{
							hscript.Expr.EDoWhile(cond, this.mapCompr(tmp, e2));
						};
					};
				};
				default: {
					hscript.Expr.ECall(this.mk(hscript.Expr.EField(this.mk(hscript.Expr.EIdent(tmp), this.pmin(e), this.pmax(e)), "push"), this.pmin(e), this.pmax(e)), [e]);
				}
			};
		};
		return this.mk(edef, this.pmin(e), this.pmax(e));
	}

	function makeUnop(op:String, e:hscript.Expr) {
		return @:ast(switch (expr(e)) {
	case EBinop(bop, e1, e2):
		mk(EBinop(bop, makeUnop(op, e1), e2), pmin(e1), pmax(e2));	
	case ETernary(e1, e2, e3):
		mk(ETernary(makeUnop(op, e1), e2, e3), pmin(e1), pmax(e3));	
	default:
		mk(EUnop(op, true, e), pmin(e), pmax(e));	
}) {
			var ` = this.expr(e);
			switch (enumIndex `) {
				case 6: {
					var `6 = `[2];
					var `5 = `[1];
					var `4 = `[0];
					{
						var e2 = `6;
						var e1 = `5;
						var bop = `4;
						{
							this.mk(hscript.Expr.EBinop(bop, this.makeUnop(op, e1), e2), this.pmin(e1), this.pmax(e2));
						};
					};
				};
				case 22: {
					var `3 = `[2];
					var `2 = `[1];
					var `1 = `[0];
					{
						var e3 = `3;
						var e2 = `2;
						var e1 = `1;
						{
							this.mk(hscript.Expr.ETernary(this.makeUnop(op, e1), e2, e3), this.pmin(e1), this.pmax(e3));
						};
					};
				};
				default: {
					this.mk(hscript.Expr.EUnop(op, true, e), this.pmin(e), this.pmax(e));
				}
			};
		};
	}

	function makeBinop(op:String, e1:hscript.Expr, e:hscript.Expr) {
		return @:ast(switch (expr(e)) {
	case EBinop(op2, e2, e3):
		if (opPriority.get(op) <= opPriority.get(op2) && !opRightAssoc.exists(op)) mk(EBinop(op2, makeBinop(op, e1, e2), e3), pmin(e1), pmax(e3)) else mk(EBinop(op, e1, e), pmin(e1), pmax(e));	
	case ETernary(e2, e3, e4):
		if (opRightAssoc.exists(op)) mk(EBinop(op, e1, e), pmin(e1), pmax(e)) else mk(ETernary(makeBinop(op, e1, e2), e3, e4), pmin(e1), pmax(e));	
	default:
		mk(EBinop(op, e1, e), pmin(e1), pmax(e));	
}) {
			var ` = this.expr(e);
			switch (enumIndex `) {
				case 6: {
					var `6 = `[2];
					var `5 = `[1];
					var `4 = `[0];
					{
						var e3 = `6;
						var e2 = `5;
						var op2 = `4;
						{
							if ({
								var this = this.opPriority;
								cast this.get(op);
							} <= {
								var this = this.opPriority;
								cast this.get(op2);
							} && ! {
								var this = this.opRightAssoc;
								cast this.exists(op);
							}) {
								this.mk(hscript.Expr.EBinop(op2, this.makeBinop(op, e1, e2), e3), this.pmin(e1), this.pmax(e3));
							} else {
								this.mk(hscript.Expr.EBinop(op, e1, e), this.pmin(e1), this.pmax(e));
							};
						};
					};
				};
				case 22: {
					var `3 = `[2];
					var `2 = `[1];
					var `1 = `[0];
					{
						var e4 = `3;
						var e3 = `2;
						var e2 = `1;
						{
							if ({
								var this = this.opRightAssoc;
								cast this.exists(op);
							}) {
								this.mk(hscript.Expr.EBinop(op, e1, e), this.pmin(e1), this.pmax(e));
							} else {
								this.mk(hscript.Expr.ETernary(this.makeBinop(op, e1, e2), e3, e4), this.pmin(e1), this.pmax(e));
							};
						};
					};
				};
				default: {
					this.mk(hscript.Expr.EBinop(op, e1, e), this.pmin(e1), this.pmax(e));
				}
			};
		};
	}

	function parseStructure(id:String) {
		return @:ast(switch (id) {
	case "if":
		ensure(TPOpen);
		var cond = parseExpr();
		ensure(TPClose);
		var e1 = parseExpr();
		var e2 = null;
		var semic = false;
		var tk = token();
		if (tk == TSemicolon) {
			semic = true;
			tk = token();
		};
		if (Type.enumEq(tk, TId("else"))) e2 = parseExpr() else {
			push(tk);
			if (semic) push(TSemicolon);
		};
		mk(EIf(cond, e1, e2), p1, (e2 == null) ? tokenMax : pmax(e2));	
	case "var":
		var ident = getIdent();
		var tk = token();
		var t = null;
		if (tk == TDoubleDot && allowTypes) {
			t = parseType();
			tk = token();
		};
		var e = null;
		if (Type.enumEq(tk, TOp("="))) e = parseExpr() else push(tk);
		mk(EVar(ident, t, e), p1, (e == null) ? tokenMax : pmax(e));	
	case "while":
		var econd = parseExpr();
		var e = parseExpr();
		mk(EWhile(econd, e), p1, pmax(e));	
	case "do":
		var e = parseExpr();
		var tk = token();
		switch (tk) {
			case TId("while"):
			default:
				unexpected(tk);			
		};
		var econd = parseExpr();
		mk(EDoWhile(econd, e), p1, pmax(econd));	
	case "for":
		ensure(TPOpen);
		var vname = getIdent();
		ensureToken(TId("in"));
		var eiter = parseExpr();
		ensure(TPClose);
		var e = parseExpr();
		mk(EFor(vname, eiter, e), p1, pmax(e));	
	case "break":
		mk(EBreak);	
	case "continue":
		mk(EContinue);	
	case "else":
		unexpected(TId(id));	
	case "inline":
		if (!maybe(TId("function"))) unexpected(TId("inline"));
		return parseStructure("function");	
	case "function":
		var tk = token();
		var name = null;
		switch (tk) {
			case TId(id):
				name = id;			
			default:
				push(tk);			
		};
		var inf = parseFunctionDecl();
		mk(EFunction(inf.args, inf.body, name, inf.ret), p1, pmax(inf.body));	
	case "return":
		var tk = token();
		push(tk);
		var e = if (tk == TSemicolon) null else parseExpr();
		mk(EReturn(e), p1, if (e == null) tokenMax else pmax(e));	
	case "new":
		var a = new Array();
		a.push(getIdent());
		var next = true;
		while (next) {
			var tk = token();
			switch (tk) {
				case TDot:
					a.push(getIdent());				
				case TPOpen:
					next = false;				
				default:
					unexpected(tk);				
			};
		};
		var args = parseExprList(TPClose);
		mk(ENew(a.join("."), args), p1);	
	case "throw":
		var e = parseExpr();
		mk(EThrow(e), p1, pmax(e));	
	case "try":
		var e = parseExpr();
		ensureToken(TId("catch"));
		ensure(TPOpen);
		var vname = getIdent();
		ensure(TDoubleDot);
		var t = null;
		if (allowTypes) t = parseType() else ensureToken(TId("Dynamic"));
		ensure(TPClose);
		var ec = parseExpr();
		mk(ETry(e, vname, t, ec), p1, pmax(ec));	
	case "switch":
		var e = parseExpr();
		var def = null, cases = [];
		ensure(TBrOpen);
		while (true) {
			var tk = token();
			switch (tk) {
				case TId("case"):
					var c = { values : [], expr : null };
					cases.push(c);
					while (true) {
						var e = parseExpr();
						c.values.push(e);
						tk = token();
						switch (tk) {
							case TComma:
							case TDoubleDot:
								break;							
							default:
								unexpected(tk);							
						};
					};
					var exprs = [];
					while (true) {
						tk = token();
						push(tk);
						switch (tk) {
							case TId("case"), TId("default"), TBrClose:
								break;							
							default:
								parseFullExpr(exprs);							
						};
					};
					c.expr = if (exprs.length == 1) exprs[0] else if (exprs.length == 0) mk(EBlock([]), tokenMin, tokenMin) else mk(EBlock(exprs), pmin(exprs[0]), pmax(exprs[exprs.length - 1]));				
				case TId("default"):
					if (def != null) unexpected(tk);
					ensure(TDoubleDot);
					var exprs = [];
					while (true) {
						tk = token();
						push(tk);
						switch (tk) {
							case TId("case"), TId("default"), TBrClose:
								break;							
							default:
								parseFullExpr(exprs);							
						};
					};
					def = if (exprs.length == 1) exprs[0] else if (exprs.length == 0) mk(EBlock([]), tokenMin, tokenMin) else mk(EBlock(exprs), pmin(exprs[0]), pmax(exprs[exprs.length - 1]));				
				case TBrClose:
					break;				
				default:
					unexpected(tk);				
			};
		};
		mk(ESwitch(e, cases, def), p1, tokenMax);	
	default:
		null;	
}) switch (id) {
			case "break": {
				{
					this.mk(hscript.Expr.EBreak, null, null);
				};
			};
			case "continue": {
				{
					this.mk(hscript.Expr.EContinue, null, null);
				};
			};
			case "do": {
				{
					var e = this.parseExpr();
					var tk = this.token();
					@:ast(switch (tk) {
	case TId("while"):
	default:
		unexpected(tk);	
}) if (tk == null) {
						this.unexpected(tk);
					} else if (enumIndex tk == 2) {
						var ` = tk[0];
						if (` == "while") {
							{};
						} else {
							this.unexpected(tk);
						};
					} else {
						this.unexpected(tk);
					};
					var econd = this.parseExpr();
					this.mk(hscript.Expr.EDoWhile(econd, e), 0, this.pmax(econd));
				};
			};
			case "else": {
				{
					this.unexpected(hscript.Token.TId(id));
				};
			};
			case "for": {
				{
					this.ensure(hscript.Token.TPOpen);
					var vname = this.getIdent();
					this.ensureToken(hscript.Token.TId("in"));
					var eiter = this.parseExpr();
					this.ensure(hscript.Token.TPClose);
					var e = this.parseExpr();
					this.mk(hscript.Expr.EFor(vname, eiter, e), 0, this.pmax(e));
				};
			};
			case "function": {
				{
					var tk = this.token();
					var name = null;
					@:ast(switch (tk) {
	case TId(id):
		name = id;	
	default:
		push(tk);	
}) if (tk == null) {
						this.push(tk);
					} else if (enumIndex tk == 2) {
						var ` = tk[0];
						{
							var id = `;
							{
								name = id;
							};
						};
					} else {
						this.push(tk);
					};
					var inf = this.parseFunctionDecl();
					this.mk(hscript.Expr.EFunction(inf.args, inf.body, name, inf.ret), 0, this.pmax(inf.body));
				};
			};
			case "if": {
				{
					this.ensure(hscript.Token.TPOpen);
					var cond = this.parseExpr();
					this.ensure(hscript.Token.TPClose);
					var e1 = this.parseExpr();
					var e2 = null;
					var semic = false;
					var tk = this.token();
					if (tk == hscript.Token.TSemicolon) {
						semic = true;
						tk = this.token();
					};
					if (Type.enumEq(tk, hscript.Token.TId("else"))) {
						e2 = this.parseExpr();
					} else {
						this.push(tk);
						if (semic) {
							this.push(hscript.Token.TSemicolon);
						};
					};
					this.mk(hscript.Expr.EIf(cond, e1, e2), 0, if ((e2 == null)) {
						0;
					} else {
						this.pmax(e2);
					});
				};
			};
			case "inline": {
				{
					if (! this.maybe(hscript.Token.TId("function"))) {
						this.unexpected(hscript.Token.TId("inline"));
					};
					return this.parseStructure("function");
				};
			};
			case "new": {
				{
					var a = new Array();
					a.push(this.getIdent());
					var next = true;
					while (next) {
						var tk = this.token();
						@:ast(switch (tk) {
	case TDot:
		a.push(getIdent());	
	case TPOpen:
		next = false;	
	default:
		unexpected(tk);	
}) if (tk == null) {
							this.unexpected(tk);
						} else switch (enumIndex tk) {
							case 4: {
								{
									next = false;
								};
							};
							case 8: {
								{
									a.push(this.getIdent());
								};
							};
							default: {
								this.unexpected(tk);
							}
						};
					};
					var args = this.parseExprList(hscript.Token.TPClose);
					this.mk(hscript.Expr.ENew(a.join("."), args), 0, null);
				};
			};
			case "return": {
				{
					var tk = this.token();
					this.push(tk);
					var e = if (tk == hscript.Token.TSemicolon) {
						null;
					} else {
						this.parseExpr();
					};
					this.mk(hscript.Expr.EReturn(e), 0, if (e == null) {
						0;
					} else {
						this.pmax(e);
					});
				};
			};
			case "switch": {
				{
					var e = this.parseExpr();
					var def = null;
					var cases = [];
					this.ensure(hscript.Token.TBrOpen);
					while (true) {
						var tk = this.token();
						@:ast(switch (tk) {
	case TId("case"):
		var c = { values : [], expr : null };
		cases.push(c);
		while (true) {
			var e = parseExpr();
			c.values.push(e);
			tk = token();
			switch (tk) {
				case TComma:
				case TDoubleDot:
					break;				
				default:
					unexpected(tk);				
			};
		};
		var exprs = [];
		while (true) {
			tk = token();
			push(tk);
			switch (tk) {
				case TId("case"), TId("default"), TBrClose:
					break;				
				default:
					parseFullExpr(exprs);				
			};
		};
		c.expr = if (exprs.length == 1) exprs[0] else if (exprs.length == 0) mk(EBlock([]), tokenMin, tokenMin) else mk(EBlock(exprs), pmin(exprs[0]), pmax(exprs[exprs.length - 1]));	
	case TId("default"):
		if (def != null) unexpected(tk);
		ensure(TDoubleDot);
		var exprs = [];
		while (true) {
			tk = token();
			push(tk);
			switch (tk) {
				case TId("case"), TId("default"), TBrClose:
					break;				
				default:
					parseFullExpr(exprs);				
			};
		};
		def = if (exprs.length == 1) exprs[0] else if (exprs.length == 0) mk(EBlock([]), tokenMin, tokenMin) else mk(EBlock(exprs), pmin(exprs[0]), pmax(exprs[exprs.length - 1]));	
	case TBrClose:
		break;	
	default:
		unexpected(tk);	
}) if (tk == null) {
							this.unexpected(tk);
						} else switch (enumIndex tk) {
							case 2: {
								var ` = tk[0];
								switch (`) {
									case "case": {
										{
											var c = {values : [], expr : null};
											cases.push(c);
											while (true) {
												var e = this.parseExpr();
												c.values.push(e);
												tk = this.token();
												@:ast(switch (tk) {
	case TComma:
	case TDoubleDot:
		break;	
	default:
		unexpected(tk);	
}) if (tk == null) {
													this.unexpected(tk);
												} else switch (enumIndex tk) {
													case 9: {
														{};
													};
													case 14: {
														{
															break;
														};
													};
													default: {
														this.unexpected(tk);
													}
												};
											};
											var exprs = [];
											while (true) {
												tk = this.token();
												this.push(tk);
												@:ast(switch (tk) {
	case TId("case"), TId("default"), TBrClose:
		break;	
	default:
		parseFullExpr(exprs);	
}) if (tk == null) {
													this.parseFullExpr(exprs);
												} else switch (enumIndex tk) {
													case 2: {
														var ` = tk[0];
														switch (`) {
															case "case", "default": {
																{
																	break;
																};
															};
															default: {
																this.parseFullExpr(exprs);
															}
														};
													};
													case 7: {
														{
															break;
														};
													};
													default: {
														this.parseFullExpr(exprs);
													}
												};
											};
											c.expr = if (exprs.length == 1) {
												exprs[0];
											} else {
												if (exprs.length == 0) {
													this.mk(hscript.Expr.EBlock([]), 0, 0);
												} else {
													this.mk(hscript.Expr.EBlock(exprs), this.pmin(exprs[0]), this.pmax(exprs[exprs.length - 1]));
												};
											};
										};
									};
									case "default": {
										{
											if (def != null) {
												this.unexpected(tk);
											};
											this.ensure(hscript.Token.TDoubleDot);
											var exprs = [];
											while (true) {
												tk = this.token();
												this.push(tk);
												@:ast(switch (tk) {
	case TId("case"), TId("default"), TBrClose:
		break;	
	default:
		parseFullExpr(exprs);	
}) if (tk == null) {
													this.parseFullExpr(exprs);
												} else switch (enumIndex tk) {
													case 2: {
														var ` = tk[0];
														switch (`) {
															case "case", "default": {
																{
																	break;
																};
															};
															default: {
																this.parseFullExpr(exprs);
															}
														};
													};
													case 7: {
														{
															break;
														};
													};
													default: {
														this.parseFullExpr(exprs);
													}
												};
											};
											def = if (exprs.length == 1) {
												exprs[0];
											} else {
												if (exprs.length == 0) {
													this.mk(hscript.Expr.EBlock([]), 0, 0);
												} else {
													this.mk(hscript.Expr.EBlock(exprs), this.pmin(exprs[0]), this.pmax(exprs[exprs.length - 1]));
												};
											};
										};
									};
									default: {
										this.unexpected(tk);
									}
								};
							};
							case 7: {
								{
									break;
								};
							};
							default: {
								this.unexpected(tk);
							}
						};
					};
					this.mk(hscript.Expr.ESwitch(e, cases, def), 0, 0);
				};
			};
			case "throw": {
				{
					var e = this.parseExpr();
					this.mk(hscript.Expr.EThrow(e), 0, this.pmax(e));
				};
			};
			case "try": {
				{
					var e = this.parseExpr();
					this.ensureToken(hscript.Token.TId("catch"));
					this.ensure(hscript.Token.TPOpen);
					var vname = this.getIdent();
					this.ensure(hscript.Token.TDoubleDot);
					var t = null;
					if (this.allowTypes) {
						t = this.parseType();
					} else {
						this.ensureToken(hscript.Token.TId("Dynamic"));
					};
					this.ensure(hscript.Token.TPClose);
					var ec = this.parseExpr();
					this.mk(hscript.Expr.ETry(e, vname, t, ec), 0, this.pmax(ec));
				};
			};
			case "var": {
				{
					var ident = this.getIdent();
					var tk = this.token();
					var t = null;
					if (tk == hscript.Token.TDoubleDot && this.allowTypes) {
						t = this.parseType();
						tk = this.token();
					};
					var e = null;
					if (Type.enumEq(tk, hscript.Token.TOp("="))) {
						e = this.parseExpr();
					} else {
						this.push(tk);
					};
					this.mk(hscript.Expr.EVar(ident, t, e), 0, if ((e == null)) {
						0;
					} else {
						this.pmax(e);
					});
				};
			};
			case "while": {
				{
					var econd = this.parseExpr();
					var e = this.parseExpr();
					this.mk(hscript.Expr.EWhile(econd, e), 0, this.pmax(e));
				};
			};
			default: {
				null;
			}
		};
	}

	function parseExprNext(e1:hscript.Expr) {
		var tk = this.token();
		@:ast(switch (tk) {
	case TOp(op):
		if (op == "->") {
			switch (expr(e1)) {
				case EIdent(i), EParent(expr(_) => EIdent(i)):
					var eret = parseExpr();
					return mk(EFunction([{ name : i }], mk(EReturn(eret), pmin(eret))), pmin(e1));				
				case ECheckType(expr(_) => EIdent(i), t):
					var eret = parseExpr();
					return mk(EFunction([{ name : i, t : t }], mk(EReturn(eret), pmin(eret))), pmin(e1));				
				default:
			};
			unexpected(tk);
		};
		if (unops.get(op)) {
			if (isBlock(e1) || switch (expr(e1)) {
				case EParent(_):
					true;				
				default:
					false;				
			}) {
				push(tk);
				return e1;
			};
			return parseExprNext(mk(EUnop(op, false, e1), pmin(e1)));
		};
		return makeBinop(op, e1, parseExpr());	
	case TDot:
		var field = getIdent();
		return parseExprNext(mk(EField(e1, field), pmin(e1)));	
	case TPOpen:
		return parseExprNext(mk(ECall(e1, parseExprList(TPClose)), pmin(e1)));	
	case TBkOpen:
		var e2 = parseExpr();
		ensure(TBkClose);
		return parseExprNext(mk(EArray(e1, e2), pmin(e1)));	
	case TQuestion:
		var e2 = parseExpr();
		ensure(TDoubleDot);
		var e3 = parseExpr();
		return mk(ETernary(e1, e2, e3), pmin(e1), pmax(e3));	
	default:
		push(tk);
		return e1;	
}) if (tk == null) {
			this.push(tk);
			return e1;
		} else switch (enumIndex tk) {
			case 3: {
				var ` = tk[0];
				{
					var op = `;
					{
						if (op == "->") {
							@:ast(switch (expr(e1)) {
	case EIdent(i), EParent(expr(_) => EIdent(i)):
		var eret = parseExpr();
		return mk(EFunction([{ name : i }], mk(EReturn(eret), pmin(eret))), pmin(e1));	
	case ECheckType(expr(_) => EIdent(i), t):
		var eret = parseExpr();
		return mk(EFunction([{ name : i, t : t }], mk(EReturn(eret), pmin(eret))), pmin(e1));	
	default:
}) {
								var ` = this.expr(e1);
								switch (enumIndex `) {
									case 1: {
										var `1 = `[0];
										{
											var i = `1;
											{
												var eret = this.parseExpr();
												return this.mk(hscript.Expr.EFunction([{name : i}], this.mk(hscript.Expr.EReturn(eret), this.pmin(eret), null), null, null), this.pmin(e1), null);
											};
										};
									};
									case 3: {
										var `5 = `[0];
										{
											var _hx_tmp;
											if (enumIndex (_hx_tmp = this.expr(`5)) == 1) {
												var `6 = _hx_tmp[0];
												{
													var i = `6;
													{
														var eret = this.parseExpr();
														return this.mk(hscript.Expr.EFunction([{name : i}], this.mk(hscript.Expr.EReturn(eret), this.pmin(eret), null), null, null), this.pmin(e1), null);
													};
												};
											} else {};
										};
									};
									case 26: {
										var `3 = `[1];
										var `2 = `[0];
										{
											var _hx_tmp;
											if (enumIndex (_hx_tmp = this.expr(`2)) == 1) {
												var `4 = _hx_tmp[0];
												{
													var t = `3;
													var i = `4;
													{
														var eret = this.parseExpr();
														return this.mk(hscript.Expr.EFunction([{name : i, t : t}], this.mk(hscript.Expr.EReturn(eret), this.pmin(eret), null), null, null), this.pmin(e1), null);
													};
												};
											} else {};
										};
									};
									default: {}
								};
							};
							this.unexpected(tk);
						};
						if ({
							var this = this.unops;
							cast this.get(op);
						}) {
							if (this.isBlock(e1) || @:ast(switch (expr(e1)) {
	case EParent(_):
		true;	
	default:
		false;	
}) {
								var ` = this.expr(e1);
								if (enumIndex ` == 3) {
									var `1 = `[0];
									{
										true;
									};
								} else {
									false;
								};
							}) {
								this.push(tk);
								return e1;
							};
							return this.parseExprNext(this.mk(hscript.Expr.EUnop(op, false, e1), this.pmin(e1), null));
						};
						return this.makeBinop(op, e1, this.parseExpr());
					};
				};
			};
			case 4: {
				{
					return this.parseExprNext(this.mk(hscript.Expr.ECall(e1, this.parseExprList(hscript.Token.TPClose)), this.pmin(e1), null));
				};
			};
			case 8: {
				{
					var field = this.getIdent();
					return this.parseExprNext(this.mk(hscript.Expr.EField(e1, field), this.pmin(e1), null));
				};
			};
			case 11: {
				{
					var e2 = this.parseExpr();
					this.ensure(hscript.Token.TBkClose);
					return this.parseExprNext(this.mk(hscript.Expr.EArray(e1, e2), this.pmin(e1), null));
				};
			};
			case 13: {
				{
					var e2 = this.parseExpr();
					this.ensure(hscript.Token.TDoubleDot);
					var e3 = this.parseExpr();
					return this.mk(hscript.Expr.ETernary(e1, e2, e3), this.pmin(e1), this.pmax(e3));
				};
			};
			default: {
				this.push(tk);
				return e1;
			}
		};
	}

	function parseFunctionArgs() {
		var args = new Array();
		var tk = this.token();
		if (tk != hscript.Token.TPClose) {
			var done = false;
			while (! done) {
				var name = null;
				var opt = false;
				@:ast(switch (tk) {
	case TQuestion:
		opt = true;
		tk = token();	
	default:
}) if (tk == null) {} else if (enumIndex tk == 13) {
					{
						opt = true;
						tk = this.token();
					};
				} else {};
				@:ast(switch (tk) {
	case TId(id):
		name = id;	
	default:
		unexpected(tk);	
}) if (tk == null) {
					this.unexpected(tk);
				} else if (enumIndex tk == 2) {
					var ` = tk[0];
					{
						var id = `;
						{
							name = id;
						};
					};
				} else {
					this.unexpected(tk);
				};
				var arg = {name : name};
				args.push(arg);
				if (opt) {
					arg.opt = true;
				};
				if (this.allowTypes) {
					if (this.maybe(hscript.Token.TDoubleDot)) {
						arg.t = this.parseType();
					};
					if (this.maybe(hscript.Token.TOp("="))) {
						arg.value = this.parseExpr();
					};
				};
				tk = this.token();
				@:ast(switch (tk) {
	case TComma:
		tk = token();	
	case TPClose:
		done = true;	
	default:
		unexpected(tk);	
}) if (tk == null) {
					this.unexpected(tk);
				} else switch (enumIndex tk) {
					case 5: {
						{
							done = true;
						};
					};
					case 9: {
						{
							tk = this.token();
						};
					};
					default: {
						this.unexpected(tk);
					}
				};
			};
		};
		return args;
	}

	function parseFunctionDecl() {
		this.ensure(hscript.Token.TPOpen);
		var args = this.parseFunctionArgs();
		var ret = null;
		if (this.allowTypes) {
			var tk = this.token();
			if (tk != hscript.Token.TDoubleDot) {
				this.push(tk);
			} else {
				ret = this.parseType();
			};
		};
		return {args : args, ret : ret, body : this.parseExpr()};
	}

	function parsePath() {
		var path = [this.getIdent()];
		while (true) {
			var t = this.token();
			if (t != hscript.Token.TDot) {
				this.push(t);
				break;
			};
			path.push(this.getIdent());
		};
		return path;
	}

	function parseType() {
		var `this = this;
		var t = this.token();
		@:ast(switch (t) {
	case TId(v):
		push(t);
		var path = parsePath();
		var params = null;
		t = token();
		switch (t) {
			case TOp(op):
				if (op == "<") {
					params = [];
					while (true) {
						params.push(parseType());
						t = token();
						switch (t) {
							case TComma:
								continue;							
							case TOp(op):
								if (op == ">") break;
								if (op.charCodeAt(0) == ">".code) {
									tokens.add(TOp(op.substr(1)));
									break;
								};							
							default:
						};
						unexpected(t);
					};
				} else push(t);			
			default:
				push(t);			
		};
		return parseTypeNext(CTPath(path, params));	
	case TPOpen:
		var a = token(), b = token();
		push(b);
		push(a);
		function withReturn(args) {
			switch token() {
				case TOp("->"):
				case t:
					unexpected(t);				
			};
			return CTFun(args, parseType());
		};
		switch [a, b] {
			case [TPClose, _] | [TId(_), TDoubleDot]:
				var args = [for (arg  in  parseFunctionArgs()) {
					switch arg.value {
						case null:
						case v:
							error(ECustom("Default values not allowed in function types"), 0, 0);						
					};
					CTNamed(arg.name, if (arg.opt) CTOpt(arg.t) else arg.t);
				}];
				return withReturn(args);			
			default:
				var t = parseType();
				return switch token() {
					case TComma:
						var args = [t];
						while (true) {
							args.push(parseType());
							if (!maybe(TComma)) break;
						};
						ensure(TPClose);
						withReturn(args);					
					case TPClose:
						parseTypeNext(CTParent(t));					
					case t:
						unexpected(t);					
				};			
		};	
	case TBrOpen:
		var fields = [];
		var meta = null;
		while (true) {
			t = token();
			switch (t) {
				case TBrClose:
					break;				
				case TId("var"):
					var name = getIdent();
					ensure(TDoubleDot);
					fields.push({ name : name, t : parseType(), meta : meta });
					meta = null;
					ensure(TSemicolon);				
				case TId(name):
					ensure(TDoubleDot);
					fields.push({ name : name, t : parseType(), meta : meta });
					t = token();
					switch (t) {
						case TComma:
						case TBrClose:
							break;						
						default:
							unexpected(t);						
					};				
				case TMeta(name):
					if (meta == null) meta = [];
					meta.push({ name : name, params : parseMetaArgs() });				
				default:
					unexpected(t);				
			};
		};
		return parseTypeNext(CTAnon(fields));	
	default:
		return unexpected(t);	
}) if (t == null) {
			return this.unexpected(t);
		} else switch (enumIndex t) {
			case 2: {
				var ` = t[0];
				{
					var v = `;
					{
						this.push(t);
						var path = this.parsePath();
						var params = null;
						t = this.token();
						@:ast(switch (t) {
	case TOp(op):
		if (op == "<") {
			params = [];
			while (true) {
				params.push(parseType());
				t = token();
				switch (t) {
					case TComma:
						continue;					
					case TOp(op):
						if (op == ">") break;
						if (op.charCodeAt(0) == ">".code) {
							tokens.add(TOp(op.substr(1)));
							break;
						};					
					default:
				};
				unexpected(t);
			};
		} else push(t);	
	default:
		push(t);	
}) if (t == null) {
							this.push(t);
						} else if (enumIndex t == 3) {
							var ` = t[0];
							{
								var op = `;
								{
									if (op == "<") {
										params = [];
										while (true) {
											params.push(this.parseType());
											t = this.token();
											@:ast(switch (t) {
	case TComma:
		continue;	
	case TOp(op):
		if (op == ">") break;
		if (op.charCodeAt(0) == ">".code) {
			tokens.add(TOp(op.substr(1)));
			break;
		};	
	default:
}) if (t == null) {} else switch (enumIndex t) {
												case 3: {
													var ` = t[0];
													{
														var op = `;
														{
															if (op == ">") {
																break;
															};
															if (op.charCodeAt(0) == 62) {
																this.tokens.add(hscript.Token.TOp(op.substr(1, null)));
																break;
															};
														};
													};
												};
												case 9: {
													{
														continue;
													};
												};
												default: {}
											};
											this.unexpected(t);
										};
									} else {
										this.push(t);
									};
								};
							};
						} else {
							this.push(t);
						};
						return this.parseTypeNext(hscript.CType.CTPath(path, params));
					};
				};
			};
			case 4: {
				{
					var a = this.token();
					var b = this.token();
					this.push(b);
					this.push(a);
					var withReturn = function(args:Array<hscript.CType>) {
						@:ast(switch token() {
	case TOp("->"):
	case t:
		unexpected(t);	
}) {
							var ` = `this.token();
							if (` == null) {
								var t = `;
								{
									`this.unexpected(t);
								};
							} else if (enumIndex ` == 3) {
								var `1 = `[0];
								if (`1 == "->") {
									{};
								} else {
									var t = `;
									{
										`this.unexpected(t);
									};
								};
							} else {
								var t = `;
								{
									`this.unexpected(t);
								};
							};
						};
						return hscript.CType.CTFun(args, `this.parseType());
					};
					@:ast(switch [a, b] {
	case [TPClose, _] | [TId(_), TDoubleDot]:
		var args = [for (arg  in  parseFunctionArgs()) {
			switch arg.value {
				case null:
				case v:
					error(ECustom("Default values not allowed in function types"), 0, 0);				
			};
			CTNamed(arg.name, if (arg.opt) CTOpt(arg.t) else arg.t);
		}];
		return withReturn(args);	
	default:
		var t = parseType();
		return switch token() {
			case TComma:
				var args = [t];
				while (true) {
					args.push(parseType());
					if (!maybe(TComma)) break;
				};
				ensure(TPClose);
				withReturn(args);			
			case TPClose:
				parseTypeNext(CTParent(t));			
			case t:
				unexpected(t);			
		};	
}) if (a == null) {
						var t = this.parseType();
						return @:ast(switch token() {
	case TComma:
		var args = [t];
		while (true) {
			args.push(parseType());
			if (!maybe(TComma)) break;
		};
		ensure(TPClose);
		withReturn(args);	
	case TPClose:
		parseTypeNext(CTParent(t));	
	case t:
		unexpected(t);	
}) {
							var ` = this.token();
							if (` == null) {
								var t = `;
								{
									this.unexpected(t);
								};
							} else switch (enumIndex `) {
								case 5: {
									{
										this.parseTypeNext(hscript.CType.CTParent(t));
									};
								};
								case 9: {
									{
										var args = [t];
										while (true) {
											args.push(this.parseType());
											if (! this.maybe(hscript.Token.TComma)) {
												break;
											};
										};
										this.ensure(hscript.Token.TPClose);
										withReturn(args);
									};
								};
								default: {
									var t = `;
									{
										this.unexpected(t);
									};
								}
							};
						};
					} else switch (enumIndex a) {
						case 2: {
							var ` = a[0];
							if (b == null) {
								var t = this.parseType();
								return @:ast(switch token() {
	case TComma:
		var args = [t];
		while (true) {
			args.push(parseType());
			if (!maybe(TComma)) break;
		};
		ensure(TPClose);
		withReturn(args);	
	case TPClose:
		parseTypeNext(CTParent(t));	
	case t:
		unexpected(t);	
}) {
									var ` = this.token();
									if (` == null) {
										var t = `;
										{
											this.unexpected(t);
										};
									} else switch (enumIndex `) {
										case 5: {
											{
												this.parseTypeNext(hscript.CType.CTParent(t));
											};
										};
										case 9: {
											{
												var args = [t];
												while (true) {
													args.push(this.parseType());
													if (! this.maybe(hscript.Token.TComma)) {
														break;
													};
												};
												this.ensure(hscript.Token.TPClose);
												withReturn(args);
											};
										};
										default: {
											var t = `;
											{
												this.unexpected(t);
											};
										}
									};
								};
							} else if (enumIndex b == 14) {
								{
									var args = {
										var ` = [];
										{
											var `1 = 0;
											var `2 = this.parseFunctionArgs();
											while (`1 < `2.length) {
												var arg = `2[`1];
												++ `1;
												@:ast(switch arg.value {
	case null:
	case v:
		error(ECustom("Default values not allowed in function types"), 0, 0);	
}) {
													var `1 = arg.value;
													if (`1 == null) {} else {
														var v = `1;
														{
															this.error(hscript.Error.ECustom("Default values not allowed in function types"), 0, 0);
														};
													};
												};
												`.push(hscript.CType.CTNamed(arg.name, if (arg.opt) {
													hscript.CType.CTOpt(arg.t);
												} else {
													arg.t;
												}));
											};
										};
										`;
									};
									return withReturn(args);
								};
							} else {
								var t = this.parseType();
								return @:ast(switch token() {
	case TComma:
		var args = [t];
		while (true) {
			args.push(parseType());
			if (!maybe(TComma)) break;
		};
		ensure(TPClose);
		withReturn(args);	
	case TPClose:
		parseTypeNext(CTParent(t));	
	case t:
		unexpected(t);	
}) {
									var ` = this.token();
									if (` == null) {
										var t = `;
										{
											this.unexpected(t);
										};
									} else switch (enumIndex `) {
										case 5: {
											{
												this.parseTypeNext(hscript.CType.CTParent(t));
											};
										};
										case 9: {
											{
												var args = [t];
												while (true) {
													args.push(this.parseType());
													if (! this.maybe(hscript.Token.TComma)) {
														break;
													};
												};
												this.ensure(hscript.Token.TPClose);
												withReturn(args);
											};
										};
										default: {
											var t = `;
											{
												this.unexpected(t);
											};
										}
									};
								};
							};
						};
						case 5: {
							{
								var args = {
									var ` = [];
									{
										var `1 = 0;
										var `2 = this.parseFunctionArgs();
										while (`1 < `2.length) {
											var arg = `2[`1];
											++ `1;
											@:ast(switch arg.value {
	case null:
	case v:
		error(ECustom("Default values not allowed in function types"), 0, 0);	
}) {
												var `1 = arg.value;
												if (`1 == null) {} else {
													var v = `1;
													{
														this.error(hscript.Error.ECustom("Default values not allowed in function types"), 0, 0);
													};
												};
											};
											`.push(hscript.CType.CTNamed(arg.name, if (arg.opt) {
												hscript.CType.CTOpt(arg.t);
											} else {
												arg.t;
											}));
										};
									};
									`;
								};
								return withReturn(args);
							};
						};
						default: {
							var t = this.parseType();
							return @:ast(switch token() {
	case TComma:
		var args = [t];
		while (true) {
			args.push(parseType());
			if (!maybe(TComma)) break;
		};
		ensure(TPClose);
		withReturn(args);	
	case TPClose:
		parseTypeNext(CTParent(t));	
	case t:
		unexpected(t);	
}) {
								var ` = this.token();
								if (` == null) {
									var t = `;
									{
										this.unexpected(t);
									};
								} else switch (enumIndex `) {
									case 5: {
										{
											this.parseTypeNext(hscript.CType.CTParent(t));
										};
									};
									case 9: {
										{
											var args = [t];
											while (true) {
												args.push(this.parseType());
												if (! this.maybe(hscript.Token.TComma)) {
													break;
												};
											};
											this.ensure(hscript.Token.TPClose);
											withReturn(args);
										};
									};
									default: {
										var t = `;
										{
											this.unexpected(t);
										};
									}
								};
							};
						}
					};
				};
			};
			case 6: {
				{
					var fields = [];
					var meta = null;
					while (true) {
						t = this.token();
						@:ast(switch (t) {
	case TBrClose:
		break;	
	case TId("var"):
		var name = getIdent();
		ensure(TDoubleDot);
		fields.push({ name : name, t : parseType(), meta : meta });
		meta = null;
		ensure(TSemicolon);	
	case TId(name):
		ensure(TDoubleDot);
		fields.push({ name : name, t : parseType(), meta : meta });
		t = token();
		switch (t) {
			case TComma:
			case TBrClose:
				break;			
			default:
				unexpected(t);			
		};	
	case TMeta(name):
		if (meta == null) meta = [];
		meta.push({ name : name, params : parseMetaArgs() });	
	default:
		unexpected(t);	
}) if (t == null) {
							this.unexpected(t);
						} else switch (enumIndex t) {
							case 2: {
								var ` = t[0];
								if (` == "var") {
									{
										var name = this.getIdent();
										this.ensure(hscript.Token.TDoubleDot);
										fields.push({name : name, t : this.parseType(), meta : meta});
										meta = null;
										this.ensure(hscript.Token.TSemicolon);
									};
								} else {
									var name = `;
									{
										this.ensure(hscript.Token.TDoubleDot);
										fields.push({name : name, t : this.parseType(), meta : meta});
										t = this.token();
										@:ast(switch (t) {
	case TComma:
	case TBrClose:
		break;	
	default:
		unexpected(t);	
}) if (t == null) {
											this.unexpected(t);
										} else switch (enumIndex t) {
											case 7: {
												{
													break;
												};
											};
											case 9: {
												{};
											};
											default: {
												this.unexpected(t);
											}
										};
									};
								};
							};
							case 7: {
								{
									break;
								};
							};
							case 15: {
								var `1 = t[0];
								{
									var name = `1;
									{
										if (meta == null) {
											meta = [];
										};
										meta.push({name : name, params : this.parseMetaArgs()});
									};
								};
							};
							default: {
								this.unexpected(t);
							}
						};
					};
					return this.parseTypeNext(hscript.CType.CTAnon(fields));
				};
			};
			default: {
				return this.unexpected(t);
			}
		};
	}

	function parseTypeNext(t:hscript.CType) {
		var tk = this.token();
		@:ast(switch (tk) {
	case TOp(op):
		if (op != "->") {
			push(tk);
			return t;
		};	
	default:
		push(tk);
		return t;	
}) if (tk == null) {
			this.push(tk);
			return t;
		} else if (enumIndex tk == 3) {
			var ` = tk[0];
			{
				var op = `;
				{
					if (op != "->") {
						this.push(tk);
						return t;
					};
				};
			};
		} else {
			this.push(tk);
			return t;
		};
		var t2 = this.parseType();
		@:ast(switch (t2) {
	case CTFun(args, _):
		args.unshift(t);
		return t2;	
	default:
		return CTFun([t], t2);	
}) if (enumIndex t2 == 1) {
			var `2 = t2[1];
			var `1 = t2[0];
			{
				var args = `1;
				{
					args.unshift(t);
					return t2;
				};
			};
		} else {
			return hscript.CType.CTFun([t], t2);
		};
	}

	function parseExprList(etk:Null<hscript.Token>) {
		var args = new Array();
		var tk = this.token();
		if (tk == etk) {
			return args;
		};
		this.push(tk);
		while (true) {
			args.push(this.parseExpr());
			tk = this.token();
			@:ast(switch (tk) {
	case TComma:
	default:
		if (tk == etk) break;
		unexpected(tk);	
}) if (tk == null) {
				if (tk == etk) {
					break;
				};
				this.unexpected(tk);
			} else if (enumIndex tk == 9) {
				{};
			} else {
				if (tk == etk) {
					break;
				};
				this.unexpected(tk);
			};
		};
		return args;
	}

	@:value({ origin : "hscript" })
	public function parseModule(content:String, origin:Null<String> = "hscript") {
		this.initParser(origin);
		this.input = new haxe.io.StringInput(content);
		this.allowTypes = true;
		this.allowMetadata = true;
		var decls = [];
		while (true) {
			var tk = this.token();
			if (tk == hscript.Token.TEof) {
				break;
			};
			this.push(tk);
			decls.push(this.parseModuleDecl());
		};
		return decls;
	}

	function parseMetadata() {
		var meta = [];
		while (true) {
			var tk = this.token();
			@:ast(switch (tk) {
	case TMeta(name):
		meta.push({ name : name, params : parseMetaArgs() });	
	default:
		push(tk);
		break;	
}) if (tk == null) {
				this.push(tk);
				break;
			} else if (enumIndex tk == 15) {
				var ` = tk[0];
				{
					var name = `;
					{
						meta.push({name : name, params : this.parseMetaArgs()});
					};
				};
			} else {
				this.push(tk);
				break;
			};
		};
		return meta;
	}

	function parseParams() {
		if (this.maybe(hscript.Token.TOp("<"))) {
			this.error(hscript.Error.EInvalidOp("Unsupported class type parameters"), 0, 0);
		};
		return {};
	}

	function parseModuleDecl() {
		var meta = this.parseMetadata();
		var ident = this.getIdent();
		var isPrivate = false;
		var isExtern = false;
		while (true) {
			@:ast(switch (ident) {
	case "private":
		isPrivate = true;	
	case "extern":
		isExtern = true;	
	default:
		break;	
}) switch (ident) {
				case "extern": {
					{
						isExtern = true;
					};
				};
				case "private": {
					{
						isPrivate = true;
					};
				};
				default: {
					break;
				}
			};
			ident = this.getIdent();
		};
		@:ast(switch (ident) {
	case "package":
		var path = parsePath();
		ensure(TSemicolon);
		return DPackage(path);	
	case "import":
		var path = [getIdent()];
		var star = false;
		while (true) {
			var t = token();
			if (t != TDot) {
				push(t);
				break;
			};
			t = token();
			switch (t) {
				case TId(id):
					path.push(id);				
				case TOp("*"):
					star = true;				
				default:
					unexpected(t);				
			};
		};
		ensure(TSemicolon);
		return DImport(path, star);	
	case "class":
		var name = getIdent();
		var params = parseParams();
		var extend = null;
		var implement = [];
		while (true) {
			var t = token();
			switch (t) {
				case TId("extends"):
					extend = parseType();				
				case TId("implements"):
					implement.push(parseType());				
				default:
					push(t);
					break;				
			};
		};
		var fields = [];
		ensure(TBrOpen);
		while (!maybe(TBrClose)) fields.push(parseField());
		return DClass({ name : name, meta : meta, params : params, extend : extend, implement : implement, fields : fields, isPrivate : isPrivate, isExtern : isExtern });	
	case "typedef":
		var name = getIdent();
		var params = parseParams();
		ensureToken(TOp("="));
		var t = parseType();
		return DTypedef({ name : name, meta : meta, params : params, isPrivate : isPrivate, t : t });	
	default:
		unexpected(TId(ident));	
}) switch (ident) {
			case "class": {
				{
					var name = this.getIdent();
					var params = this.parseParams();
					var extend = null;
					var implement = [];
					while (true) {
						var t = this.token();
						@:ast(switch (t) {
	case TId("extends"):
		extend = parseType();	
	case TId("implements"):
		implement.push(parseType());	
	default:
		push(t);
		break;	
}) if (t == null) {
							this.push(t);
							break;
						} else if (enumIndex t == 2) {
							var ` = t[0];
							switch (`) {
								case "extends": {
									{
										extend = this.parseType();
									};
								};
								case "implements": {
									{
										implement.push(this.parseType());
									};
								};
								default: {
									this.push(t);
									break;
								}
							};
						} else {
							this.push(t);
							break;
						};
					};
					var fields = [];
					this.ensure(hscript.Token.TBrOpen);
					while (! this.maybe(hscript.Token.TBrClose)) {
						fields.push(this.parseField());
					};
					return hscript.ModuleDecl.DClass({name : name, meta : meta, params : params, extend : extend, implement : implement, fields : fields, isPrivate : isPrivate, isExtern : isExtern});
				};
			};
			case "import": {
				{
					var path = [this.getIdent()];
					var star = false;
					while (true) {
						var t = this.token();
						if (t != hscript.Token.TDot) {
							this.push(t);
							break;
						};
						t = this.token();
						@:ast(switch (t) {
	case TId(id):
		path.push(id);	
	case TOp("*"):
		star = true;	
	default:
		unexpected(t);	
}) if (t == null) {
							this.unexpected(t);
						} else switch (enumIndex t) {
							case 2: {
								var ` = t[0];
								{
									var id = `;
									{
										path.push(id);
									};
								};
							};
							case 3: {
								var `1 = t[0];
								if (`1 == "*") {
									{
										star = true;
									};
								} else {
									this.unexpected(t);
								};
							};
							default: {
								this.unexpected(t);
							}
						};
					};
					this.ensure(hscript.Token.TSemicolon);
					return hscript.ModuleDecl.DImport(path, star);
				};
			};
			case "package": {
				{
					var path = this.parsePath();
					this.ensure(hscript.Token.TSemicolon);
					return hscript.ModuleDecl.DPackage(path);
				};
			};
			case "typedef": {
				{
					var name = this.getIdent();
					var params = this.parseParams();
					this.ensureToken(hscript.Token.TOp("="));
					var t = this.parseType();
					return hscript.ModuleDecl.DTypedef({name : name, meta : meta, params : params, isPrivate : isPrivate, t : t});
				};
			};
			default: {
				this.unexpected(hscript.Token.TId(ident));
			}
		};
		return null;
	}

	function parseField() {
		var meta = this.parseMetadata();
		var access = [];
		while (true) {
			var id = this.getIdent();
			@:ast(switch (id) {
	case "override":
		access.push(AOverride);	
	case "public":
		access.push(APublic);	
	case "private":
		access.push(APrivate);	
	case "inline":
		access.push(AInline);	
	case "static":
		access.push(AStatic);	
	case "macro":
		access.push(AMacro);	
	case "function":
		var name = getIdent();
		var inf = parseFunctionDecl();
		return { name : name, meta : meta, access : access, kind : KFunction({ args : inf.args, expr : inf.body, ret : inf.ret }) };	
	case "var":
		var name = getIdent();
		var get = null, set = null;
		if (maybe(TPOpen)) {
			get = getIdent();
			ensure(TComma);
			set = getIdent();
			ensure(TPClose);
		};
		var type = maybe(TDoubleDot) ? parseType() : null;
		var expr = maybe(TOp("=")) ? parseExpr() : null;
		if (expr != null) {
			if (isBlock(expr)) maybe(TSemicolon) else ensure(TSemicolon);
		} else if (type != null && type.match(CTAnon(_))) {
			maybe(TSemicolon);
		} else ensure(TSemicolon);
		return { name : name, meta : meta, access : access, kind : KVar({ get : get, set : set, type : type, expr : expr }) };	
	default:
		unexpected(TId(id));	
}) switch (id) {
				case "function": {
					{
						var name = this.getIdent();
						var inf = this.parseFunctionDecl();
						return {name : name, meta : meta, access : access, kind : hscript.FieldKind.KFunction({args : inf.args, expr : inf.body, ret : inf.ret})};
					};
				};
				case "inline": {
					{
						access.push(hscript.FieldAccess.AInline);
					};
				};
				case "macro": {
					{
						access.push(hscript.FieldAccess.AMacro);
					};
				};
				case "override": {
					{
						access.push(hscript.FieldAccess.AOverride);
					};
				};
				case "private": {
					{
						access.push(hscript.FieldAccess.APrivate);
					};
				};
				case "public": {
					{
						access.push(hscript.FieldAccess.APublic);
					};
				};
				case "static": {
					{
						access.push(hscript.FieldAccess.AStatic);
					};
				};
				case "var": {
					{
						var name = this.getIdent();
						var get = null;
						var set = null;
						if (this.maybe(hscript.Token.TPOpen)) {
							get = this.getIdent();
							this.ensure(hscript.Token.TComma);
							set = this.getIdent();
							this.ensure(hscript.Token.TPClose);
						};
						var type = if (this.maybe(hscript.Token.TDoubleDot)) {
							this.parseType();
						} else {
							null;
						};
						var expr = if (this.maybe(hscript.Token.TOp("="))) {
							this.parseExpr();
						} else {
							null;
						};
						if (expr != null) {
							if (this.isBlock(expr)) {
								this.maybe(hscript.Token.TSemicolon);
							} else {
								this.ensure(hscript.Token.TSemicolon);
							};
						} else {
							if (type != null && if (type == null) false else if (enumIndex type == 2) {
								var ` = type[0];
								true;
							} else false) {
								this.maybe(hscript.Token.TSemicolon);
							} else {
								this.ensure(hscript.Token.TSemicolon);
							};
						};
						return {name : name, meta : meta, access : access, kind : hscript.FieldKind.KVar({get : get, set : set, type : type, expr : expr})};
					};
				};
				default: {
					this.unexpected(hscript.Token.TId(id));
				}
			};
		};
		return null;
	}

	function incPos() {}

	function readChar() {
		this.incPos();
		return try {
			this.input.readByte();
		} catch (`45:Dynamic) {
			{};
			{};
			if (true) {
				{};
				0;
			} else throw `45;
		};
	}

	function readString(until:Int) {
		var c = 0;
		var b = new haxe.io.BytesOutput();
		var esc = false;
		var old = this.line;
		var s = this.input;
		while (true) {
			try {
				this.incPos();
				c = s.readByte();
			} catch (`48:Dynamic) {
				{};
				{};
				if (true) {
					{};
					{
						this.line = old;
						this.error(hscript.Error.EUnterminatedString, 0, 0);
					};
				} else throw `48;
			};
			if (esc) {
				esc = false;
				@:ast(switch (c) {
	case "n".code:
		b.writeByte(10);	
	case "r".code:
		b.writeByte(13);	
	case "t".code:
		b.writeByte(9);	
	case "'".code, "\"".code, "\\".code:
		b.writeByte(c);	
	case "/".code:
		if (allowJSON) b.writeByte(c) else invalidChar(c);	
	case "u".code:
		if (!allowJSON) invalidChar(c);
		var code = null;
		try {
			incPos();
			incPos();
			incPos();
			incPos();
			code = s.readString(4);
		} catch(e:Dynamic) {
			line = old;
			error(EUnterminatedString, p1, p1);
		};
		var k = 0;
		for (i  in  0 ... 4) {
			k <<= 4;
			var char = code.charCodeAt(i);
			switch (char) {
				case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
					k += char - 48;				
				case 65, 66, 67, 68, 69, 70:
					k += char - 55;				
				case 97, 98, 99, 100, 101, 102:
					k += char - 87;				
				default:
					invalidChar(char);				
			};
		};
		if (k <= 0x7F) b.writeByte(k) else if (k <= 0x7FF) {
			b.writeByte(0xC0 | (k >> 6));
			b.writeByte(0x80 | (k & 63));
		} else {
			b.writeByte(0xE0 | (k >> 12));
			b.writeByte(0x80 | ((k >> 6) & 63));
			b.writeByte(0x80 | (k & 63));
		};	
	default:
		invalidChar(c);	
}) switch (c) {
					case 34, 39, 92: {
						{
							b.writeByte(c);
						};
					};
					case 47: {
						{
							if (this.allowJSON) {
								b.writeByte(c);
							} else {
								this.invalidChar(c);
							};
						};
					};
					case 110: {
						{
							b.writeByte(10);
						};
					};
					case 114: {
						{
							b.writeByte(13);
						};
					};
					case 116: {
						{
							b.writeByte(9);
						};
					};
					case 117: {
						{
							if (! this.allowJSON) {
								this.invalidChar(c);
							};
							var code = null;
							try {
								this.incPos();
								this.incPos();
								this.incPos();
								this.incPos();
								code = s.readString(4, null);
							} catch (`51:Dynamic) {
								{};
								{};
								if (true) {
									{};
									{
										this.line = old;
										this.error(hscript.Error.EUnterminatedString, 0, 0);
									};
								} else throw `51;
							};
							var k = 0;
							{
								{
									k <<= 4;
									var char = code.charCodeAt(0);
									@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		k += char - 48;	
	case 65, 66, 67, 68, 69, 70:
		k += char - 55;	
	case 97, 98, 99, 100, 101, 102:
		k += char - 87;	
	default:
		invalidChar(char);	
}) if (char == null) {
										this.invalidChar(char);
									} else switch (char) {
										case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
											{
												k += char - 48;
											};
										};
										case 65, 66, 67, 68, 69, 70: {
											{
												k += char - 55;
											};
										};
										case 97, 98, 99, 100, 101, 102: {
											{
												k += char - 87;
											};
										};
										default: {
											this.invalidChar(char);
										}
									};
								};
								{
									k <<= 4;
									var char = code.charCodeAt(1);
									@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		k += char - 48;	
	case 65, 66, 67, 68, 69, 70:
		k += char - 55;	
	case 97, 98, 99, 100, 101, 102:
		k += char - 87;	
	default:
		invalidChar(char);	
}) if (char == null) {
										this.invalidChar(char);
									} else switch (char) {
										case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
											{
												k += char - 48;
											};
										};
										case 65, 66, 67, 68, 69, 70: {
											{
												k += char - 55;
											};
										};
										case 97, 98, 99, 100, 101, 102: {
											{
												k += char - 87;
											};
										};
										default: {
											this.invalidChar(char);
										}
									};
								};
								{
									k <<= 4;
									var char = code.charCodeAt(2);
									@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		k += char - 48;	
	case 65, 66, 67, 68, 69, 70:
		k += char - 55;	
	case 97, 98, 99, 100, 101, 102:
		k += char - 87;	
	default:
		invalidChar(char);	
}) if (char == null) {
										this.invalidChar(char);
									} else switch (char) {
										case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
											{
												k += char - 48;
											};
										};
										case 65, 66, 67, 68, 69, 70: {
											{
												k += char - 55;
											};
										};
										case 97, 98, 99, 100, 101, 102: {
											{
												k += char - 87;
											};
										};
										default: {
											this.invalidChar(char);
										}
									};
								};
								{
									k <<= 4;
									var char = code.charCodeAt(3);
									@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		k += char - 48;	
	case 65, 66, 67, 68, 69, 70:
		k += char - 55;	
	case 97, 98, 99, 100, 101, 102:
		k += char - 87;	
	default:
		invalidChar(char);	
}) if (char == null) {
										this.invalidChar(char);
									} else switch (char) {
										case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
											{
												k += char - 48;
											};
										};
										case 65, 66, 67, 68, 69, 70: {
											{
												k += char - 55;
											};
										};
										case 97, 98, 99, 100, 101, 102: {
											{
												k += char - 87;
											};
										};
										default: {
											this.invalidChar(char);
										}
									};
								};
							};
							if (k <= 127) {
								b.writeByte(k);
							} else {
								if (k <= 2047) {
									b.writeByte(192 | (k >> 6));
									b.writeByte(128 | (k & 63));
								} else {
									b.writeByte(224 | (k >> 12));
									b.writeByte(128 | ((k >> 6) & 63));
									b.writeByte(128 | (k & 63));
								};
							};
						};
					};
					default: {
						this.invalidChar(c);
					}
				};
			} else {
				if (c == 92) {
					esc = true;
				} else {
					if (c == until) {
						break;
					} else {
						if (c == 10) {
							this.line ++;
						};
						b.writeByte(c);
					};
				};
			};
		};
		return b.getBytes().toString();
	}

	function token() {
		if (! this.tokens.isEmpty()) {
			return this.tokens.pop();
		};
		var char;
		if (this.char < 0) {
			char = this.readChar();
		} else {
			char = this.char;
			this.char = -1;
		};
		while (true) {
			@:ast(switch (char) {
	case 0:
		return TEof;	
	case 32, 9, 13:
	case 10:
		line++;	
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		var n = (char - 48) * 1.0;
		var exp = 0.;
		while (true) {
			char = readChar();
			exp *= 10;
			switch (char) {
				case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
					n = n * 10 + (char - 48);				
				case "e".code, "E".code:
					var tk = token();
					var pow:Null<Int> = null;
					switch (tk) {
						case TConst(CInt(e)):
							pow = e;						
						case TOp("-"):
							tk = token();
							switch (tk) {
								case TConst(CInt(e)):
									pow = -e;								
								default:
									push(tk);								
							};						
						default:
							push(tk);						
					};
					if (pow == null) invalidChar(char);
					return TConst(CFloat((Math.pow(10, pow) / exp) * n * 10));				
				case ".".code:
					if (exp > 0) {
						if (exp == 10 && readChar() == ".".code) {
							push(TOp("..."));
							var i = Std.int(n);
							return TConst((i == n) ? CInt(i) : CFloat(n));
						};
						invalidChar(char);
					};
					exp = 1.;				
				case "x".code:
					if (n > 0 || exp > 0) invalidChar(char);
					var n = 0;
					while (true) {
						char = readChar();
						switch (char) {
							case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
								n = (n << 4) + char - 48;							
							case 65, 66, 67, 68, 69, 70:
								n = (n << 4) + (char - 55);							
							case 97, 98, 99, 100, 101, 102:
								n = (n << 4) + (char - 87);							
							default:
								this.char = char;
								return TConst(CInt(n));							
						};
					};				
				default:
					this.char = char;
					var i = Std.int(n);
					return TConst((exp > 0) ? CFloat(n * 10 / exp) : ((i == n) ? CInt(i) : CFloat(n)));				
			};
		};	
	case ";".code:
		return TSemicolon;	
	case "(".code:
		return TPOpen;	
	case ")".code:
		return TPClose;	
	case ",".code:
		return TComma;	
	case ".".code:
		char = readChar();
		switch (char) {
			case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
				var n = char - 48;
				var exp = 1;
				while (true) {
					char = readChar();
					exp *= 10;
					switch (char) {
						case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
							n = n * 10 + (char - 48);						
						default:
							this.char = char;
							return TConst(CFloat(n / exp));						
					};
				};			
			case ".".code:
				char = readChar();
				if (char != ".".code) invalidChar(char);
				return TOp("...");			
			default:
				this.char = char;
				return TDot;			
		};	
	case "{".code:
		return TBrOpen;	
	case "}".code:
		return TBrClose;	
	case "[".code:
		return TBkOpen;	
	case "]".code:
		return TBkClose;	
	case "'".code, "\"".code:
		return TConst(CString(readString(char)));	
	case "?".code:
		return TQuestion;	
	case ":".code:
		return TDoubleDot;	
	case "=".code:
		char = readChar();
		if (char == "=".code) return TOp("==") else if (char == ">".code) return TOp("=>");
		this.char = char;
		return TOp("=");	
	case "@".code:
		char = readChar();
		if (idents[char] || char == ":".code) {
			var id = String.fromCharCode(char);
			while (true) {
				char = readChar();
				if (!idents[char]) {
					this.char = char;
					return TMeta(id);
				};
				id += String.fromCharCode(char);
			};
		};
		invalidChar(char);	
	case "#".code:
		char = readChar();
		if (idents[char]) {
			var id = String.fromCharCode(char);
			while (true) {
				char = readChar();
				if (!idents[char]) {
					this.char = char;
					return preprocess(id);
				};
				id += String.fromCharCode(char);
			};
		};
		invalidChar(char);	
	default:
		if (ops[char]) {
			var op = String.fromCharCode(char);
			var prev = -1;
			while (true) {
				char = readChar();
				if (!ops[char] || prev == "=".code) {
					if (op.charCodeAt(0) == "/".code) return tokenComment(op, char);
					this.char = char;
					return TOp(op);
				};
				prev = char;
				op += String.fromCharCode(char);
			};
		};
		if (idents[char]) {
			var id = String.fromCharCode(char);
			while (true) {
				char = readChar();
				if (!idents[char]) {
					this.char = char;
					return TId(id);
				};
				id += String.fromCharCode(char);
			};
		};
		invalidChar(char);	
}) switch (char) {
				case 0: {
					{
						return hscript.Token.TEof;
					};
				};
				case 10: {
					{
						this.line ++;
					};
				};
				case 9, 13, 32: {
					{};
				};
				case 35: {
					{
						char = this.readChar();
						if (this.idents[char]) {
							var id = String.fromCharCode(char);
							while (true) {
								char = this.readChar();
								if (! this.idents[char]) {
									this.char = char;
									return this.preprocess(id);
								};
								id += String.fromCharCode(char);
							};
						};
						this.invalidChar(char);
					};
				};
				case 34, 39: {
					{
						return hscript.Token.TConst(hscript.Const.CString(this.readString(char)));
					};
				};
				case 40: {
					{
						return hscript.Token.TPOpen;
					};
				};
				case 41: {
					{
						return hscript.Token.TPClose;
					};
				};
				case 44: {
					{
						return hscript.Token.TComma;
					};
				};
				case 46: {
					{
						char = this.readChar();
						@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		var n = char - 48;
		var exp = 1;
		while (true) {
			char = readChar();
			exp *= 10;
			switch (char) {
				case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
					n = n * 10 + (char - 48);				
				default:
					this.char = char;
					return TConst(CFloat(n / exp));				
			};
		};	
	case ".".code:
		char = readChar();
		if (char != ".".code) invalidChar(char);
		return TOp("...");	
	default:
		this.char = char;
		return TDot;	
}) switch (char) {
							case 46: {
								{
									char = this.readChar();
									if (char != 46) {
										this.invalidChar(char);
									};
									return hscript.Token.TOp("...");
								};
							};
							case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
								{
									var n = char - 48;
									var exp = 1;
									while (true) {
										char = this.readChar();
										exp *= 10;
										@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		n = n * 10 + (char - 48);	
	default:
		this.char = char;
		return TConst(CFloat(n / exp));	
}) switch (char) {
											case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
												{
													n = n * 10 + (char - 48);
												};
											};
											default: {
												this.char = char;
												return hscript.Token.TConst(hscript.Const.CFloat(n / exp));
											}
										};
									};
								};
							};
							default: {
								this.char = char;
								return hscript.Token.TDot;
							}
						};
					};
				};
				case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
					{
						var n = (char - 48) * 1.0;
						var exp = 0.;
						while (true) {
							char = this.readChar();
							exp *= 10;
							@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		n = n * 10 + (char - 48);	
	case "e".code, "E".code:
		var tk = token();
		var pow:Null<Int> = null;
		switch (tk) {
			case TConst(CInt(e)):
				pow = e;			
			case TOp("-"):
				tk = token();
				switch (tk) {
					case TConst(CInt(e)):
						pow = -e;					
					default:
						push(tk);					
				};			
			default:
				push(tk);			
		};
		if (pow == null) invalidChar(char);
		return TConst(CFloat((Math.pow(10, pow) / exp) * n * 10));	
	case ".".code:
		if (exp > 0) {
			if (exp == 10 && readChar() == ".".code) {
				push(TOp("..."));
				var i = Std.int(n);
				return TConst((i == n) ? CInt(i) : CFloat(n));
			};
			invalidChar(char);
		};
		exp = 1.;	
	case "x".code:
		if (n > 0 || exp > 0) invalidChar(char);
		var n = 0;
		while (true) {
			char = readChar();
			switch (char) {
				case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
					n = (n << 4) + char - 48;				
				case 65, 66, 67, 68, 69, 70:
					n = (n << 4) + (char - 55);				
				case 97, 98, 99, 100, 101, 102:
					n = (n << 4) + (char - 87);				
				default:
					this.char = char;
					return TConst(CInt(n));				
			};
		};	
	default:
		this.char = char;
		var i = Std.int(n);
		return TConst((exp > 0) ? CFloat(n * 10 / exp) : ((i == n) ? CInt(i) : CFloat(n)));	
}) switch (char) {
								case 46: {
									{
										if (exp > 0) {
											if (exp == 10 && this.readChar() == 46) {
												this.push(hscript.Token.TOp("..."));
												var i = Std.int(n);
												return hscript.Token.TConst(if ((i == n)) {
													hscript.Const.CInt(i);
												} else {
													hscript.Const.CFloat(n);
												});
											};
											this.invalidChar(char);
										};
										exp = 1.;
									};
								};
								case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
									{
										n = n * 10 + (char - 48);
									};
								};
								case 69, 101: {
									{
										var tk = this.token();
										var pow = null;
										@:ast(switch (tk) {
	case TConst(CInt(e)):
		pow = e;	
	case TOp("-"):
		tk = token();
		switch (tk) {
			case TConst(CInt(e)):
				pow = -e;			
			default:
				push(tk);			
		};	
	default:
		push(tk);	
}) if (tk == null) {
											this.push(tk);
										} else switch (enumIndex tk) {
											case 1: {
												var ` = tk[0];
												if (enumIndex ` == 0) {
													var `1 = `[0];
													{
														var e = `1;
														{
															pow = e;
														};
													};
												} else {
													this.push(tk);
												};
											};
											case 3: {
												var `2 = tk[0];
												if (`2 == "-") {
													{
														tk = this.token();
														@:ast(switch (tk) {
	case TConst(CInt(e)):
		pow = -e;	
	default:
		push(tk);	
}) if (tk == null) {
															this.push(tk);
														} else if (enumIndex tk == 1) {
															var ` = tk[0];
															if (enumIndex ` == 0) {
																var `1 = `[0];
																{
																	var e = `1;
																	{
																		pow = - e;
																	};
																};
															} else {
																this.push(tk);
															};
														} else {
															this.push(tk);
														};
													};
												} else {
													this.push(tk);
												};
											};
											default: {
												this.push(tk);
											}
										};
										if (pow == null) {
											this.invalidChar(char);
										};
										return hscript.Token.TConst(hscript.Const.CFloat((Math.pow(10, pow) / exp) * n * 10));
									};
								};
								case 120: {
									{
										if (n > 0 || exp > 0) {
											this.invalidChar(char);
										};
										var n = 0;
										while (true) {
											char = this.readChar();
											@:ast(switch (char) {
	case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
		n = (n << 4) + char - 48;	
	case 65, 66, 67, 68, 69, 70:
		n = (n << 4) + (char - 55);	
	case 97, 98, 99, 100, 101, 102:
		n = (n << 4) + (char - 87);	
	default:
		this.char = char;
		return TConst(CInt(n));	
}) switch (char) {
												case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57: {
													{
														n = (n << 4) + char - 48;
													};
												};
												case 65, 66, 67, 68, 69, 70: {
													{
														n = (n << 4) + (char - 55);
													};
												};
												case 97, 98, 99, 100, 101, 102: {
													{
														n = (n << 4) + (char - 87);
													};
												};
												default: {
													this.char = char;
													return hscript.Token.TConst(hscript.Const.CInt(n));
												}
											};
										};
									};
								};
								default: {
									this.char = char;
									var i = Std.int(n);
									return hscript.Token.TConst(if ((exp > 0)) {
										hscript.Const.CFloat(n * 10 / exp);
									} else {
										(if ((i == n)) {
											hscript.Const.CInt(i);
										} else {
											hscript.Const.CFloat(n);
										});
									});
								}
							};
						};
					};
				};
				case 58: {
					{
						return hscript.Token.TDoubleDot;
					};
				};
				case 59: {
					{
						return hscript.Token.TSemicolon;
					};
				};
				case 61: {
					{
						char = this.readChar();
						if (char == 61) {
							return hscript.Token.TOp("==");
						} else {
							if (char == 62) {
								return hscript.Token.TOp("=>");
							};
						};
						this.char = char;
						return hscript.Token.TOp("=");
					};
				};
				case 63: {
					{
						return hscript.Token.TQuestion;
					};
				};
				case 64: {
					{
						char = this.readChar();
						if (this.idents[char] || char == 58) {
							var id = String.fromCharCode(char);
							while (true) {
								char = this.readChar();
								if (! this.idents[char]) {
									this.char = char;
									return hscript.Token.TMeta(id);
								};
								id += String.fromCharCode(char);
							};
						};
						this.invalidChar(char);
					};
				};
				case 91: {
					{
						return hscript.Token.TBkOpen;
					};
				};
				case 93: {
					{
						return hscript.Token.TBkClose;
					};
				};
				case 123: {
					{
						return hscript.Token.TBrOpen;
					};
				};
				case 125: {
					{
						return hscript.Token.TBrClose;
					};
				};
				default: {
					if (this.ops[char]) {
						var op = String.fromCharCode(char);
						var prev = -1;
						while (true) {
							char = this.readChar();
							if (! this.ops[char] || prev == 61) {
								if (op.charCodeAt(0) == 47) {
									return this.tokenComment(op, char);
								};
								this.char = char;
								return hscript.Token.TOp(op);
							};
							prev = char;
							op += String.fromCharCode(char);
						};
					};
					if (this.idents[char]) {
						var id = String.fromCharCode(char);
						while (true) {
							char = this.readChar();
							if (! this.idents[char]) {
								this.char = char;
								return hscript.Token.TId(id);
							};
							id += String.fromCharCode(char);
						};
					};
					this.invalidChar(char);
				}
			};
			char = this.readChar();
		};
		return null;
	}

	function preprocValue(id:String) {
		return {
			var this = this.preprocesorValues;
			cast this.get(id);
		};
	}

	var preprocStack:Array<{ r : Bool }>;

	function parsePreproCond() {
		var tk = this.token();
		return @:ast(switch (tk) {
	case TPOpen:
		push(TPOpen);
		parseExpr();	
	case TId(id):
		mk(EIdent(id), tokenMin, tokenMax);	
	case TOp("!"):
		mk(EUnop("!", true, parsePreproCond()), tokenMin, tokenMax);	
	default:
		unexpected(tk);	
}) if (tk == null) {
			this.unexpected(tk);
		} else switch (enumIndex tk) {
			case 2: {
				var ` = tk[0];
				{
					var id = `;
					{
						this.mk(hscript.Expr.EIdent(id), 0, 0);
					};
				};
			};
			case 3: {
				var `1 = tk[0];
				if (`1 == "!") {
					{
						this.mk(hscript.Expr.EUnop("!", true, this.parsePreproCond()), 0, 0);
					};
				} else {
					this.unexpected(tk);
				};
			};
			case 4: {
				{
					this.push(hscript.Token.TPOpen);
					this.parseExpr();
				};
			};
			default: {
				this.unexpected(tk);
			}
		};
	}

	function evalPreproCond(e:hscript.Expr) {
		@:ast(switch (expr(e)) {
	case EIdent(id):
		return preprocValue(id) != null;	
	case EUnop("!", _, e):
		return !evalPreproCond(e);	
	case EParent(e):
		return evalPreproCond(e);	
	case EBinop("&&", e1, e2):
		return evalPreproCond(e1) && evalPreproCond(e2);	
	case EBinop("||", e1, e2):
		return evalPreproCond(e1) || evalPreproCond(e2);	
	default:
		error(EInvalidPreprocessor("Can't eval " + expr(e).getName()), readPos, readPos);
		return false;	
}) {
			var ` = this.expr(e);
			switch (enumIndex `) {
				case 1: {
					var `4 = `[0];
					{
						var id = `4;
						{
							return this.preprocValue(id) != null;
						};
					};
				};
				case 3: {
					var `8 = `[0];
					{
						var e = `8;
						{
							return this.evalPreproCond(e);
						};
					};
				};
				case 6: {
					var `7 = `[2];
					var `6 = `[1];
					var `5 = `[0];
					switch (`5) {
						case "&&": {
							{
								var e2 = `7;
								var e1 = `6;
								{
									return this.evalPreproCond(e1) && this.evalPreproCond(e2);
								};
							};
						};
						case "||": {
							{
								var e2 = `7;
								var e1 = `6;
								{
									return this.evalPreproCond(e1) || this.evalPreproCond(e2);
								};
							};
						};
						default: {
							this.error(hscript.Error.EInvalidPreprocessor("Can't eval " + {
								var e = this.expr(e);
								Type.enumConstructor(e);
							}), 0, 0);
							return false;
						}
					};
				};
				case 7: {
					var `3 = `[2];
					var `2 = `[1];
					var `1 = `[0];
					if (`1 == "!") {
						{
							var e = `3;
							{
								return ! this.evalPreproCond(e);
							};
						};
					} else {
						this.error(hscript.Error.EInvalidPreprocessor("Can't eval " + {
							var e = this.expr(e);
							Type.enumConstructor(e);
						}), 0, 0);
						return false;
					};
				};
				default: {
					this.error(hscript.Error.EInvalidPreprocessor("Can't eval " + {
						var e = this.expr(e);
						Type.enumConstructor(e);
					}), 0, 0);
					return false;
				}
			};
		};
	}

	function preprocess(id:String) {
		@:ast(switch (id) {
	case "if":
		var e = parsePreproCond();
		if (evalPreproCond(e)) {
			preprocStack.push({ r : true });
			return token();
		};
		preprocStack.push({ r : false });
		skipTokens();
		return token();	
	case "else", "elseif" if (preprocStack.length > 0):
		if (preprocStack[preprocStack.length - 1].r) {
			preprocStack[preprocStack.length - 1].r = false;
			skipTokens();
			return token();
		} else if (id == "else") {
			preprocStack.pop();
			preprocStack.push({ r : true });
			return token();
		} else {
			preprocStack.pop();
			return preprocess("if");
		};	
	case "end" if (preprocStack.length > 0):
		preprocStack.pop();
		return token();	
	default:
		return TPrepro(id);	
}) switch (id) {
			case "else", "elseif": {
				if (this.preprocStack.length > 0) {
					if (this.preprocStack[this.preprocStack.length - 1].r) {
						this.preprocStack[this.preprocStack.length - 1].r = false;
						this.skipTokens();
						return this.token();
					} else {
						if (id == "else") {
							this.preprocStack.pop();
							this.preprocStack.push({r : true});
							return this.token();
						} else {
							this.preprocStack.pop();
							return this.preprocess("if");
						};
					};
				} else {
					return hscript.Token.TPrepro(id);
				};
			};
			case "end": {
				if (this.preprocStack.length > 0) {
					this.preprocStack.pop();
					return this.token();
				} else {
					return hscript.Token.TPrepro(id);
				};
			};
			case "if": {
				{
					var e = this.parsePreproCond();
					if (this.evalPreproCond(e)) {
						this.preprocStack.push({r : true});
						return this.token();
					};
					this.preprocStack.push({r : false});
					this.skipTokens();
					return this.token();
				};
			};
			default: {
				return hscript.Token.TPrepro(id);
			}
		};
	}

	function skipTokens() {
		var spos = this.preprocStack.length - 1;
		var obj = this.preprocStack[spos];
		var pos = 0;
		while (true) {
			var tk = this.token();
			if (tk == hscript.Token.TEof) {
				this.error(hscript.Error.EInvalidPreprocessor("Unclosed"), pos, pos);
			};
			if (this.preprocStack[spos] != obj) {
				this.push(tk);
				break;
			};
		};
	}

	function tokenComment(op:String, char:Int) {
		var c = op.charCodeAt(1);
		var s = this.input;
		if (c == 47) {
			try {
				while (char != 13 && char != 10) {
					this.incPos();
					char = s.readByte();
				};
				this.char = char;
			} catch (`54:Dynamic) {
				{};
				{};
				if (true) {
					{};
					{};
				} else throw `54;
			};
			return this.token();
		};
		if (c == 42) {
			var old = this.line;
			if (op == "/**/") {
				this.char = char;
				return this.token();
			};
			try {
				while (true) {
					while (char != 42) {
						if (char == 10) {
							this.line ++;
						};
						this.incPos();
						char = s.readByte();
					};
					this.incPos();
					char = s.readByte();
					if (char == 47) {
						break;
					};
				};
			} catch (`57:Dynamic) {
				{};
				{};
				if (true) {
					{};
					{
						this.line = old;
						this.error(hscript.Error.EUnterminatedComment, 0, 0);
					};
				} else throw `57;
			};
			return this.token();
		};
		this.char = char;
		return hscript.Token.TOp(op);
	}

	function constString(c:hscript.Const) {
		return @:ast(switch (c) {
	case CInt(v):
		Std.string(v);	
	case CFloat(f):
		Std.string(f);	
	case CString(s):
		s;	
}) switch (@:exhaustive enumIndex c) {
			case 0: {
				var ` = c[0];
				{
					var v = `;
					{
						Std.string(v);
					};
				};
			};
			case 1: {
				var `2 = c[0];
				{
					var f = `2;
					{
						Std.string(f);
					};
				};
			};
			case 2: {
				var `1 = c[0];
				{
					var s = `1;
					{
						s;
					};
				};
			};
		};
	}

	function tokenString(t:hscript.Token) {
		return @:ast(switch (t) {
	case TEof:
		"<eof>";	
	case TConst(c):
		constString(c);	
	case TId(s):
		s;	
	case TOp(s):
		s;	
	case TPOpen:
		"(";	
	case TPClose:
		")";	
	case TBrOpen:
		"{";	
	case TBrClose:
		"}";	
	case TDot:
		".";	
	case TComma:
		",";	
	case TSemicolon:
		";";	
	case TBkOpen:
		"[";	
	case TBkClose:
		"]";	
	case TQuestion:
		"?";	
	case TDoubleDot:
		":";	
	case TMeta(id):
		"@" + id;	
	case TPrepro(id):
		"#" + id;	
}) switch (@:exhaustive enumIndex t) {
			case 0: {
				{
					"<eof>";
				};
			};
			case 1: {
				var ` = t[0];
				{
					var c = `;
					{
						this.constString(c);
					};
				};
			};
			case 2: {
				var `1 = t[0];
				{
					var s = `1;
					{
						s;
					};
				};
			};
			case 3: {
				var `4 = t[0];
				{
					var s = `4;
					{
						s;
					};
				};
			};
			case 4: {
				{
					"(";
				};
			};
			case 5: {
				{
					")";
				};
			};
			case 6: {
				{
					"{";
				};
			};
			case 7: {
				{
					"}";
				};
			};
			case 8: {
				{
					".";
				};
			};
			case 9: {
				{
					",";
				};
			};
			case 10: {
				{
					";";
				};
			};
			case 11: {
				{
					"[";
				};
			};
			case 12: {
				{
					"]";
				};
			};
			case 13: {
				{
					"?";
				};
			};
			case 14: {
				{
					":";
				};
			};
			case 15: {
				var `3 = t[0];
				{
					var id = `3;
					{
						"@" + id;
					};
				};
			};
			case 16: {
				var `2 = t[0];
				{
					var id = `2;
					{
						"#" + id;
					};
				};
			};
		};
	}

	@:value(0)
	static inline var p1:Int = 0;

	@:value(0)
	static inline var readPos:Int = 0;

	@:value(0)
	static inline var tokenMin:Int = 0;

	@:value(0)
	static inline var tokenMax:Int = 0;
}