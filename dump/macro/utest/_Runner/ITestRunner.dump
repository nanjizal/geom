@:access(utest.Runner.iTestFixtures) @:access(utest.Runner.runNext) @:access(utest.Runner.runFixture) @:access(utest.Runner.executedFixtures)
private class utest._Runner.ITestRunner {

	public function new(runner:utest.Runner) {
		this.runner = runner;
	}

	var runner:utest.Runner;

	var cases:Iterator<utest.ITest>;

	var currentCase:utest.ITest;

	var currentCaseFixtures:Array<utest.TestFixture>;

	var teardownClass:Void -> utest.Async;

	var setupAsync:utest.Async;

	var teardownAsync:utest.Async;

	public function run() {
		this.cases = {
			var this = this.runner.iTestFixtures;
			cast this.keys();
		};
		this.runCases();
	}

	function runCases() {
		while (this.cases.hasNext()) {
			this.currentCase = this.cases.next();
			var data = {
				var this = this.runner.iTestFixtures;
				var key = this.currentCase;
				cast this.get(key);
			};
			this.currentCaseFixtures = data.fixtures;
			this.teardownClass = data.teardownClass;
			try {
				this.setupAsync = data.setupClass();
			} catch (`150:Dynamic) {
				var `151 = haxe.Exception.caught(`150);
				var `152 = `151.unwrap();
				if (true) {
					var e = `152;
					{
						this.setupFailed(utest.Assertation.SetupError("setupClass failed: " + Std.string(e), haxe._CallStack.CallStack_Impl_.exceptionStack()));
						return;
					};
				} else throw `150;
			};
			if (this.setupAsync.resolved) {
				if (! this.runFixtures(null)) {
					return;
				};
			} else {
				this.setupAsync.then(this.checkSetup);
				return;
			};
		};
		this.runner.runNext(null);
	}

	function checkSetup() {
		if (this.setupAsync.timedOut) {
			this.setupFailed(utest.Assertation.SetupError("setupClass timeout", []));
		} else {
			this.runFixtures(null);
		};
	}

	function setupFailed(assertation:utest.Assertation) {
		this.runner.executedFixtures += this.currentCaseFixtures.length;
		this.runner.onProgress.dispatch({totals : this.runner.length, result : utest.TestResult.ofFailedSetupClass(this.currentCase, assertation), done : this.runner.executedFixtures});
		this.runCases();
	}

	function runFixtures(finishedHandler:Null<utest.TestHandler<utest.TestFixture>> = null) {
		while (this.currentCaseFixtures.length > 0) {
			var handler = this.runner.runFixture(this.currentCaseFixtures.pop());
			if (! handler.finished) {
				handler.onComplete.add(this.runFixtures);
				return false;
			};
		};
		try {
			this.teardownAsync = this.teardownClass();
		} catch (`153:Dynamic) {
			var `154 = haxe.Exception.caught(`153);
			var `155 = `154.unwrap();
			if (true) {
				var e = `155;
				{
					this.teardownFailed(utest.Assertation.TeardownError("tearDownClass failed: " + Std.string(e), haxe._CallStack.CallStack_Impl_.exceptionStack()));
				};
			} else throw `153;
		};
		if (this.teardownAsync.resolved && finishedHandler == null) {
			return true;
		};
		this.teardownAsync.then(this.checkTeardown);
		return false;
	}

	function checkTeardown() {
		if (this.teardownAsync.timedOut) {
			this.teardownFailed(utest.Assertation.TeardownError("teardownClass timeout", []));
		};
		this.runCases();
	}

	function teardownFailed(assertation:utest.Assertation) {
		this.runner.onProgress.dispatch({totals : this.runner.length, result : utest.TestResult.ofFailedTeardownClass(this.currentCase, assertation), done : this.runner.executedFixtures});
	}
}