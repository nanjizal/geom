@:used
class geom.curve.ComplexTrig {

	public static inline function sin(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.sin(cast c.x), cast 0);
			return cast this;
		} else {
			var y = Math.exp(cast c.y);
			var y = Math.exp(cast c.y);
			var this = new geom.structure.Mat1x2(Math.sin(cast c.x) * ((y + 1. / y) / 2.), Math.cos(cast c.x) * ((y - 1. / y) / 2.));
			return cast this;
		};
	}

	public static inline function cos(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.cos(cast c.x), cast 0);
			return cast this;
		} else {
			var y = Math.exp(cast c.y);
			var y = Math.exp(cast c.y);
			var this = new geom.structure.Mat1x2(Math.cos(cast c.x) * ((y + 1. / y) / 2.), - Math.sin(cast c.x) * ((y - 1. / y) / 2.));
			return cast this;
		};
	}

	public static inline function tan(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.tan(cast c.x), cast 0);
			return cast this;
		} else {
			var s;
			if ((cast c.y == 0 == true)) {
				var this = new geom.structure.Mat1x2(Math.sin(cast c.x), cast 0);
				s = cast this;
			} else {
				var y = Math.exp(cast c.y);
				var y = Math.exp(cast c.y);
				var this = new geom.structure.Mat1x2(Math.sin(cast c.x) * ((y + 1. / y) / 2.), Math.cos(cast c.x) * ((y - 1. / y) / 2.));
				s = cast this;
			};
			var c;
			if ((cast c.y == 0 == true)) {
				var this = new geom.structure.Mat1x2(Math.cos(cast c.x), cast 0);
				c = cast this;
			} else {
				var y = Math.exp(cast c.y);
				var y = Math.exp(cast c.y);
				var this = new geom.structure.Mat1x2(Math.cos(cast c.x) * ((y + 1. / y) / 2.), - Math.sin(cast c.x) * ((y - 1. / y) / 2.));
				c = cast this;
			};
			var this = new geom.structure.Mat1x2(c.x, - c.y);
			var conj = cast this;
			var this = new geom.structure.Mat1x2(s.x * conj.x - s.y * conj.y, s.x * conj.y + s.y * conj.x);
			var numr = cast this;
			var this = new geom.structure.Mat1x2(c.x * conj.x - c.y * conj.y, c.x * conj.y + c.y * conj.x);
			var demr = cast this;
			var dval = cast demr.x + cast demr.y;
			var this = new geom.structure.Mat1x2(cast numr.x / dval, cast numr.y / dval);
			return cast this;
		};
	}

	public static inline function sinh(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var y = Math.exp(cast c.x);
			var this = new geom.structure.Mat1x2((y - 1. / y) / 2., cast 0);
			return cast this;
		} else {
			var y = Math.exp(cast c.x);
			var y = Math.exp(cast c.x);
			var this = new geom.structure.Mat1x2((y - 1. / y) / 2. * Math.cos(cast c.y), (y + 1. / y) / 2. * Math.sin(cast c.y));
			return cast this;
		};
	}

	public static inline function cosh(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var y = Math.exp(cast c.x);
			var this = new geom.structure.Mat1x2((y + 1. / y) / 2., cast 0);
			return cast this;
		} else {
			var y = Math.exp(cast c.x);
			var y = Math.exp(cast c.x);
			var this = new geom.structure.Mat1x2((y + 1. / y) / 2. * Math.cos(cast c.y), (y - 1. / y) / 2. * Math.sin(cast c.y));
			return cast this;
		};
	}

	public static inline function tanh(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var x = cast c.x;
			var a = Math.exp(x);
			var b = Math.exp(- x);
			var this = new geom.structure.Mat1x2(if ((a == Math.POSITIVE_INFINITY)) 1. else if ((b == Math.POSITIVE_INFINITY)) -1. else (a - b) / (a + b), cast 0);
			return cast this;
		} else {
			var x = cast c.x;
			var a = Math.exp(x);
			var b = Math.exp(- x);
			var hx = if ((a == Math.POSITIVE_INFINITY)) 1. else if ((b == Math.POSITIVE_INFINITY)) -1. else (a - b) / (a + b);
			var ty = Math.tan(cast c.y);
			var this = new geom.structure.Mat1x2(hx, ty);
			var n = cast this;
			var this = new geom.structure.Mat1x2(cast 1, hx * ty);
			var d = cast this;
			var this = new geom.structure.Mat1x2(d.x, - d.y);
			var conj = cast this;
			var this = new geom.structure.Mat1x2(n.x * conj.x - n.y * conj.y, n.x * conj.y + n.y * conj.x);
			var numr = cast this;
			var this = new geom.structure.Mat1x2(d.x * conj.x - d.y * conj.y, d.x * conj.y + d.y * conj.x);
			var demr = cast this;
			var dval = cast demr.x + cast demr.y;
			var this = new geom.structure.Mat1x2(cast numr.x / dval, cast numr.y / dval);
			return cast this;
		};
	}
}