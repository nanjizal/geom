@:used
private class geom.flat.f32._Float32Flat.Float32Flat_Impl_ {

	@:impl @:op([])
	public static inline function readItem(this:haxe.io.Float32Array, k:Int) {
		return cast this.bytes.getFloat((k + 2 << 2) + cast this.byteOffset);
	}

	@:impl @:op([])
	public static inline function writeItem(this:haxe.io.Float32Array, k:Int, v:Float) {
		{
			var index = k + 2;
			if ((index >= 0 && index < cast this.byteLength >> 2)) cast this.bytes.setFloat((index << 2) + cast this.byteOffset, v);
		};
		return v;
	}

	@:impl @:noCompletion
	public static inline function _new(len:Int) {
		var size = (len + 2) * 4;
		var this = new haxe.io.ArrayBufferViewImpl(haxe.io.Bytes.alloc(size), 0, size);
		var this = cast cast this;
		var this = cast this;
		if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, 0.);
		if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, 0.);
		return cast this;
	}

	@:impl
	public static var size(get,set):Int;

	@:impl
	static function get_size(this:haxe.io.Float32Array) {
		return Std.int(cast this.bytes.getFloat(4 + cast this.byteOffset));
	}

	@:impl
	static function set_size(this:haxe.io.Float32Array, id:Int) {
		{
			var pos_ = cast id;
			if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, pos_);
			if ((cast this.bytes.getFloat(cast this.byteOffset) > cast this.bytes.getFloat(4 + cast this.byteOffset) - 1)) {
				var value = cast this.bytes.getFloat(cast this.byteOffset);
				if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, value);
			};
		};
		return id;
	}

	@:impl
	public static var index(get,set):Int;

	@:impl
	static inline function get_index(this:haxe.io.Float32Array) {
		return Std.int(cast this.bytes.getFloat(cast this.byteOffset));
	}

	@:impl
	static inline function set_index(this:haxe.io.Float32Array, id:Int) {
		{
			if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, id);
			if ((cast this.bytes.getFloat(cast this.byteOffset) > cast this.bytes.getFloat(4 + cast this.byteOffset) - 1)) {
				var value = cast this.bytes.getFloat(cast this.byteOffset);
				if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, value);
			};
		};
		return id;
	}

	@:impl
	public static var pos(get,set):Float;

	@:impl
	static inline function get_pos(this:haxe.io.Float32Array) {
		return cast this.bytes.getFloat(cast this.byteOffset);
	}

	@:impl
	static inline function set_pos(this:haxe.io.Float32Array, pos_:Float) {
		if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, pos_);
		if ((cast cast this.bytes.getFloat(cast cast this.byteOffset) > cast cast this.bytes.getFloat(4 + cast cast this.byteOffset) - 1)) {
			var value = cast cast this.bytes.getFloat(cast cast this.byteOffset);
			if ((1 < cast cast this.byteLength >> 2)) cast cast this.bytes.setFloat(4 + cast cast this.byteOffset, value);
		};
		return pos_;
	}

	@:impl
	static inline function updateLen(this:haxe.io.Float32Array) {
		if ((cast this.bytes.getFloat(cast this.byteOffset) > cast this.bytes.getFloat(4 + cast this.byteOffset) - 1)) {
			var value = cast this.bytes.getFloat(cast this.byteOffset);
			if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, value);
		};
	}

	@:impl
	public static inline function hasNext(this:haxe.io.Float32Array) {
		return cast this.bytes.getFloat(cast this.byteOffset) < geom.flat.f32._Float32Flat.Float32Flat_Impl_.get_size(this);
	}

	@:impl
	public static inline function next(this:haxe.io.Float32Array) {
		{
			var pos_ = cast this.bytes.getFloat(cast this.byteOffset) + 1.;
			if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, pos_);
			if ((cast this.bytes.getFloat(cast this.byteOffset) > cast this.bytes.getFloat(4 + cast this.byteOffset) - 1)) {
				var value = cast this.bytes.getFloat(cast this.byteOffset);
				if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, value);
			};
		};
		return cast this.bytes.getFloat(cast this.byteOffset);
	}

	@:impl @:op(A++)
	public static inline function increment(this:haxe.io.Float32Array) {
		{
			var pos_ = cast cast this.bytes.getFloat(cast cast this.byteOffset) + 1.;
			if ((0 < cast cast this.byteLength >> 2)) cast cast this.bytes.setFloat(cast cast this.byteOffset, pos_);
			if ((cast cast this.bytes.getFloat(cast cast this.byteOffset) > cast cast this.bytes.getFloat(4 + cast cast this.byteOffset) - 1)) {
				var value = cast cast this.bytes.getFloat(cast cast this.byteOffset);
				if ((1 < cast cast this.byteLength >> 2)) cast cast this.bytes.setFloat(4 + cast cast this.byteOffset, value);
			};
		};
		return cast cast this.bytes.getFloat(cast cast this.byteOffset);
	}

	@:impl @:to
	public static inline function toArray(this:haxe.io.Float32Array) {
		var end = geom.flat.f32._Float32Flat.Float32Flat_Impl_.get_size(this) + 2;
		return haxe.io._Float32Array.Float32Array_Impl_.fromData(cast this.subarray(8, if ((end == null)) null else end << 2));
	}

	@:from
	public static inline function fromArray(arr:haxe.io.Float32Array) {
		var size = ((cast arr.byteLength >> 2) + 2) * 4;
		var this = new haxe.io.ArrayBufferViewImpl(haxe.io.Bytes.alloc(size), 0, size);
		var this = cast cast this;
		var this = cast this;
		if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, 0.);
		if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, 0.);
		var flat = cast this;
		{
			var l = cast arr.byteLength >> 2;
			{
				var ` = 0;
				var `1 = l;
				while ((` < `1)) {
					var i = ` ++;
					{
						var index = i + 2;
						var value = cast arr.bytes.getFloat((i << 2) + cast arr.byteOffset);
						if ((index >= 0 && index < cast cast flat.byteLength >> 2)) cast cast flat.bytes.setFloat((index << 2) + cast cast flat.byteOffset, value);
					};
				};
			};
			if ((0 < cast cast flat.byteLength >> 2)) cast cast flat.bytes.setFloat(cast cast flat.byteOffset, 0);
			if ((1 < cast cast flat.byteLength >> 2)) cast cast flat.bytes.setFloat(4 + cast cast flat.byteOffset, l);
		};
		return flat;
	}

	@:impl
	public static inline function clone(this:haxe.io.Float32Array) {
		var size = ((cast this.byteLength >> 2) - 2 + 2) * 4;
		var this = new haxe.io.ArrayBufferViewImpl(haxe.io.Bytes.alloc(size), 0, size);
		var this = cast cast this;
		var this = cast this;
		if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, 0.);
		if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, 0.);
		var flat = cast this;
		{
			var end = geom.flat.f32._Float32Flat.Float32Flat_Impl_.get_size(cast this) + 2;
			var arr = haxe.io._Float32Array.Float32Array_Impl_.fromData(cast cast this.subarray(8, if ((end == null)) null else end << 2));
			var l = cast arr.byteLength >> 2;
			{
				var ` = 0;
				var `1 = l;
				while ((` < `1)) {
					var i = ` ++;
					{
						var index = i + 2;
						var value = cast arr.bytes.getFloat((i << 2) + cast arr.byteOffset);
						if ((index >= 0 && index < cast cast flat.byteLength >> 2)) cast cast flat.bytes.setFloat((index << 2) + cast cast flat.byteOffset, value);
					};
				};
			};
			if ((0 < cast cast flat.byteLength >> 2)) cast cast flat.bytes.setFloat(cast cast flat.byteOffset, 0);
			if ((1 < cast cast flat.byteLength >> 2)) cast cast flat.bytes.setFloat(4 + cast cast flat.byteOffset, l);
		};
		return flat;
	}

	@:impl
	public static inline function fill(this:haxe.io.Float32Array, arr:haxe.io.Float32Array) {
		var l = cast arr.byteLength >> 2;
		{
			var ` = 0;
			var `1 = l;
			while ((` < `1)) {
				var i = ` ++;
				{
					var index = i + 2;
					var value = cast arr.bytes.getFloat((i << 2) + cast arr.byteOffset);
					if ((index >= 0 && index < cast this.byteLength >> 2)) cast this.bytes.setFloat((index << 2) + cast this.byteOffset, value);
				};
			};
		};
		if ((0 < cast this.byteLength >> 2)) cast this.bytes.setFloat(cast this.byteOffset, 0);
		if ((1 < cast this.byteLength >> 2)) cast this.bytes.setFloat(4 + cast this.byteOffset, l);
	}
}