@:used
private class geom.matrix._Matrix1x4.Matrix1x4_Impl_ {

	@:value(1)
	public static inline var rows:Int = 1;

	@:value(4)
	public static inline var columns:Int = 4;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat1x4) {
		var this = m;
		return cast this;
	}

	@:impl
	public static inline function clone(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(this.x, this.y, this.z, this.w);
		return cast this;
	}

	@:impl
	public static inline function iterator(this:geom.structure.Mat1x4) {
		var arr = [this.x, this.y, this.z, this.w];
		return new haxe.iterators.ArrayIterator(arr);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix1x4;

	@:impl
	static inline function get_self(this:geom.structure.Mat1x4) {
		return cast this;
	}

	@:impl
	public static var magnitude(get,set):Float;

	@:impl
	static inline function get_magnitude(this:geom.structure.Mat1x4) {
		return Math.sqrt(cast this.x * cast this.x + cast this.y * cast this.y + cast this.z * cast this.z + cast this.w * cast this.w);
	}

	@:impl
	static inline function set_magnitude(this:geom.structure.Mat1x4, length:Float) {
		var currentLength = Math.sqrt(cast this.x * cast this.x + cast this.y * cast this.y + cast this.z * cast this.z + cast this.w * cast this.w);
		if ((currentLength == 0.)) return 0. else {
			var mul = length / currentLength;
			this.x *= mul;
			this.y *= mul;
			this.z *= mul;
			this.w *= mul;
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};
	}

	@:impl
	public static inline function normalize(this:geom.structure.Mat1x4) {
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				this.z *= mul;
				this.w *= mul;
				var tmp = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			};
		};
		return this;
	}

	public static var zero(get,never):geom.matrix.Matrix1x4;

	static inline function get_zero() {
		var this = new geom.structure.Mat1x4(0., 0., 0., 0.);
		return cast this;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix1x4;

	@:impl
	static inline function get_nought(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(0., 0., 0., 0.);
		return cast this;
	}

	public static var unit(get,never):geom.matrix.Matrix1x4;

	static inline function get_unit() {
		var this = new geom.structure.Mat1x4(1., 1., 1., 1.);
		return cast this;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix1x4;

	@:impl
	static inline function get_one(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(1., 1., 1., 1.);
		return cast this;
	}

	public static var minus1(get,never):geom.matrix.Matrix1x4;

	static inline function get_minus1() {
		var this = new geom.structure.Mat1x4(1., 1., 1., 1.);
		var a = cast this;
		var this = new geom.structure.Mat1x4(- cast a.x, - cast a.y, - cast a.z, - cast a.w);
		return cast this;
	}

	public static var counting(get,never):geom.matrix.Matrix1x4;

	static inline function get_counting() {
		var this = new geom.structure.Mat1x4(1., 2., 3., 4.);
		return cast this;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix1x4;

	@:impl
	static inline function get_testCount(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(1., 2., 3., 4.);
		return cast this;
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(- cast a.x, - cast a.y, - cast a.z, - cast a.w);
		return cast this;
	}

	@:impl
	public static inline function negate(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(- this.x, - this.y, - this.z, - this.w);
		return cast this;
	}

	@:op(A - B)
	public static inline function subtracting(a:geom.matrix.Matrix1x4, b:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(cast a.x - b.x, cast a.y - b.y, cast a.z - b.z, cast a.w - b.w);
		return cast this;
	}

	@:impl
	public static inline function subtract(this:geom.structure.Mat1x4, b:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(this.x - b.x, this.y - b.y, this.z - b.z, this.w - b.w);
		return cast this;
	}

	@:op(A + B)
	public static inline function adding(a:geom.matrix.Matrix1x4, b:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(cast a.x + b.x, cast a.y + b.y, cast a.z + b.z, cast a.w + b.w);
		return cast this;
	}

	@:impl
	public static inline function add(this:geom.structure.Mat1x4, b:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(this.x + b.x, this.y + b.y, this.z + b.z, this.w + b.w);
		return cast this;
	}

	@:op(A * B) @:commutative
	public static inline function scaleMultiplying(a:geom.matrix.Matrix1x4, v:Float) {
		var this = new geom.structure.Mat1x4(cast a.x * v, cast a.y * v, cast a.z * v, cast a.w * v);
		return cast this;
	}

	@:impl
	public static inline function scaleMultiply(this:geom.structure.Mat1x4, v:Float) {
		var this = new geom.structure.Mat1x4(this.x * v, this.y * v, this.z * v, this.w * v);
		return cast this;
	}

	@:op(A == B)
	public static inline function isEqualling(a:geom.matrix.Matrix1x4, b:geom.matrix.Matrix1x4) {
		var delta = 0.0000001;
		return ! (Math.abs(cast a.x - b.x) >= delta || Math.abs(cast a.y - b.y) >= delta || Math.abs(cast a.z - b.z) >= delta || Math.abs(cast a.w - b.w) >= delta);
	}

	@:impl
	public static inline function isEqual(this:geom.structure.Mat1x4, b:geom.matrix.Matrix1x4) {
		var delta = 0.0000001;
		return ! (Math.abs(this.x - b.x) >= delta || Math.abs(this.y - b.y) >= delta || Math.abs(this.z - b.z) >= delta || Math.abs(this.w - b.w) >= delta);
	}

	public static inline function identity(out:geom.matrix.Matrix1x4) {
		out.x = 1.;
		out.y = 1.;
		out.z = 1.;
		out.w = 1.;
		return out;
	}

	public static inline function copy(pin:geom.matrix.Matrix1x4, pout:geom.matrix.Matrix1x4) {
		pout.x = pin.x;
		pout.y = pin.y;
		pout.z = pin.z;
		pout.w = pin.w;
		return pout;
	}

	@:impl
	public static inline function projectPoint(this:geom.structure.Mat1x4) {
		if ((this.z <= 0)) {
			var this = new geom.structure.Mat1x4(0., 0., this.z, 1.);
			return cast this;
		} else {
			var this = new geom.structure.Mat1x4(this.x / this.z, this.y / this.z, this.z, 1.);
			return cast this;
		};
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix1x4, b:geom.matrix.Matrix1x4) {
		var delta = 0.0000001;
		return (Math.abs(cast a.x - b.x) >= delta || Math.abs(cast a.y - b.y) >= delta || Math.abs(cast a.z - b.z) >= delta || Math.abs(cast a.w - b.w) >= delta);
	}

	@:impl
	public static inline function magnitudeSquared(this:geom.structure.Mat1x4) {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}

	public static inline function scalarProduct(a:geom.matrix.Matrix1x4, b:geom.matrix.Matrix1x4) {
		return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
	}

	@:impl
	public static inline function dotProd(this:geom.structure.Mat1x4, b:geom.matrix.Matrix1x4) {
		return this.x * b.x + this.y * b.y + this.z * b.z + this.w * b.w;
	}

	@:impl
	public static inline function rotateX(this:geom.structure.Mat1x4, theta:Float) {
		var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0.);
		var this = cast this;
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., c, - s, 0., 0., s, c, 0.);
		var s = cast this;
		var this = new geom.structure.Mat4x3(this.a * s.a + this.b * s.e + this.c * s.i, this.a * s.b + this.b * s.f + this.c * s.j, this.a * s.c + this.b * s.g + this.c * s.k, this.a * s.d + this.b * s.h + this.c * s.l + this.d, this.e * s.a + this.f * s.e + this.g * s.i, this.e * s.b + this.f * s.f + this.g * s.j, this.e * s.c + this.f * s.g + this.g * s.k, this.e * s.d + this.f * s.h + this.g * s.l + this.h, this.i * s.a + this.j * s.e + this.k * s.i, this.i * s.b + this.j * s.f + this.k * s.j, this.i * s.c + this.j * s.g + this.k * s.k, this.i * s.d + this.j * s.h + this.k * s.l + this.l);
		var t = cast this;
		var this = new geom.structure.Mat1x4(t.a * cast this.x + t.b * cast this.y + t.c * cast this.z + t.d, t.e * cast this.x + t.f * cast this.y + t.g * cast this.z + t.h, t.i * cast this.x + t.j * cast this.y + t.k * cast this.z + t.l, 1.);
		return cast this;
	}

	@:impl
	public static inline function rotateY(this:geom.structure.Mat1x4, theta:Float) {
		var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0.);
		var this = cast this;
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this = new geom.structure.Mat4x3(c, 0., s, 0., 0., 1., 0., 0., - s, 0., c, 0.);
		var s = cast this;
		var this = new geom.structure.Mat4x3(this.a * s.a + this.b * s.e + this.c * s.i, this.a * s.b + this.b * s.f + this.c * s.j, this.a * s.c + this.b * s.g + this.c * s.k, this.a * s.d + this.b * s.h + this.c * s.l + this.d, this.e * s.a + this.f * s.e + this.g * s.i, this.e * s.b + this.f * s.f + this.g * s.j, this.e * s.c + this.f * s.g + this.g * s.k, this.e * s.d + this.f * s.h + this.g * s.l + this.h, this.i * s.a + this.j * s.e + this.k * s.i, this.i * s.b + this.j * s.f + this.k * s.j, this.i * s.c + this.j * s.g + this.k * s.k, this.i * s.d + this.j * s.h + this.k * s.l + this.l);
		var t = cast this;
		var this = new geom.structure.Mat1x4(t.a * cast this.x + t.b * cast this.y + t.c * cast this.z + t.d, t.e * cast this.x + t.f * cast this.y + t.g * cast this.z + t.h, t.i * cast this.x + t.j * cast this.y + t.k * cast this.z + t.l, 1.);
		return cast this;
	}

	@:impl
	public static inline function rotateZ(this:geom.structure.Mat1x4, theta:Float) {
		var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0.);
		var this = cast this;
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this = new geom.structure.Mat4x3(c, - s, 0., 0., s, c, 0., 0., 0., 0., 1., 0.);
		var s = cast this;
		var this = new geom.structure.Mat4x3(this.a * s.a + this.b * s.e + this.c * s.i, this.a * s.b + this.b * s.f + this.c * s.j, this.a * s.c + this.b * s.g + this.c * s.k, this.a * s.d + this.b * s.h + this.c * s.l + this.d, this.e * s.a + this.f * s.e + this.g * s.i, this.e * s.b + this.f * s.f + this.g * s.j, this.e * s.c + this.f * s.g + this.g * s.k, this.e * s.d + this.f * s.h + this.g * s.l + this.h, this.i * s.a + this.j * s.e + this.k * s.i, this.i * s.b + this.j * s.f + this.k * s.j, this.i * s.c + this.j * s.g + this.k * s.k, this.i * s.d + this.j * s.h + this.k * s.l + this.l);
		var t = cast this;
		var this = new geom.structure.Mat1x4(t.a * cast this.x + t.b * cast this.y + t.c * cast this.z + t.d, t.e * cast this.x + t.f * cast this.y + t.g * cast this.z + t.h, t.i * cast this.x + t.j * cast this.y + t.k * cast this.z + t.l, 1.);
		return cast this;
	}

	@:impl
	public static inline function translateXY(this:geom.structure.Mat1x4, x:Float, y:Float) {
		var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0.);
		var this = cast this;
		var this = new geom.structure.Mat4x3(1., 0., 0., x, 0., 1., 0., y, 0., 0., 1., 0.);
		var s = cast this;
		var this = new geom.structure.Mat4x3(this.a * s.a + this.b * s.e + this.c * s.i, this.a * s.b + this.b * s.f + this.c * s.j, this.a * s.c + this.b * s.g + this.c * s.k, this.a * s.d + this.b * s.h + this.c * s.l + this.d, this.e * s.a + this.f * s.e + this.g * s.i, this.e * s.b + this.f * s.f + this.g * s.j, this.e * s.c + this.f * s.g + this.g * s.k, this.e * s.d + this.f * s.h + this.g * s.l + this.h, this.i * s.a + this.j * s.e + this.k * s.i, this.i * s.b + this.j * s.f + this.k * s.j, this.i * s.c + this.j * s.g + this.k * s.k, this.i * s.d + this.j * s.h + this.k * s.l + this.l);
		var t = cast this;
		var this = new geom.structure.Mat1x4(t.a * cast this.x + t.b * cast this.y + t.c * cast this.z + t.d, t.e * cast this.x + t.f * cast this.y + t.g * cast this.z + t.h, t.i * cast this.x + t.j * cast this.y + t.k * cast this.z + t.l, 1.);
		return cast this;
	}

	@:impl
	public static inline function translateXYZ(this:geom.structure.Mat1x4, x:Float, y:Float, z:Float) {
		var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0.);
		var this = cast this;
		var this = new geom.structure.Mat4x3(1., 0., 0., x, 0., 1., 0., y, 0., 0., 1., z);
		var s = cast this;
		var this = new geom.structure.Mat4x3(this.a * s.a + this.b * s.e + this.c * s.i, this.a * s.b + this.b * s.f + this.c * s.j, this.a * s.c + this.b * s.g + this.c * s.k, this.a * s.d + this.b * s.h + this.c * s.l + this.d, this.e * s.a + this.f * s.e + this.g * s.i, this.e * s.b + this.f * s.f + this.g * s.j, this.e * s.c + this.f * s.g + this.g * s.k, this.e * s.d + this.f * s.h + this.g * s.l + this.h, this.i * s.a + this.j * s.e + this.k * s.i, this.i * s.b + this.j * s.f + this.k * s.j, this.i * s.c + this.j * s.g + this.k * s.k, this.i * s.d + this.j * s.h + this.k * s.l + this.l);
		var t = cast this;
		var this = new geom.structure.Mat1x4(t.a * cast this.x + t.b * cast this.y + t.c * cast this.z + t.d, t.e * cast this.x + t.f * cast this.y + t.g * cast this.z + t.h, t.i * cast this.x + t.j * cast this.y + t.k * cast this.z + t.l, 1.);
		return cast this;
	}

	@:impl
	public static inline function transformPoint(this:geom.structure.Mat1x4, t:geom.matrix.Matrix4x3) {
		var this = new geom.structure.Mat1x4(t.a * this.x + t.b * this.y + t.c * this.z + t.d, t.e * this.x + t.f * this.y + t.g * this.z + t.h, t.i * this.x + t.j * this.y + t.k * this.z + t.l, 1.);
		return cast this;
	}

	@:op(A / B)
	public static inline function divide(a:geom.matrix.Matrix1x4, v:Float) {
		var v = 1 / v;
		var this = new geom.structure.Mat1x4(cast a.x * v, cast a.y * v, cast a.z * v, cast a.w * v);
		return cast this;
	}

	@:op(A / B)
	public static inline function divide2(v:Float, a:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(v / a.x, v / a.y, v / a.z, v / a.w);
		return cast this;
	}

	@:op(~A)
	public static inline function conjugate(a:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(- a.x, - a.y, - a.z, a.w);
		return cast this;
	}

	public static inline function multiplyV(a:geom.matrix.Matrix1x4, b:geom.matrix.Matrix1x4, out:geom.matrix.Matrix1x4) {
		var ax = a.x;
		var ay = a.y;
		var az = a.z;
		var aw = a.w;
		var bx = b.x;
		var by = b.y;
		var bz = b.z;
		var bw = b.w;
		out.x = ax * bw + aw * bx + ay * bz - az * by;
		out.y = ay * bw + aw * by + az * bx - ax * bz;
		out.z = az * bw + aw * bz + ax * by - ay * bx;
		out.w = aw * bw - ax * bx - ay * by - az * bz;
		return out;
	}

	public static inline function multiplyQ(q:geom.matrix.Matrix1x4, v:geom.matrix.Matrix1x4, out:geom.matrix.Matrix1x4) {
		var vx = v.x;
		var vy = v.y;
		var vz = v.z;
		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;
		out.w = - qx * vx - qy * vy - qz * vz;
		out.x = qw * vx + qy * vz - qz * vy;
		out.y = qw * vy - qx * vz + qz * vx;
		out.z = qw * vz + qx * vy - qy * vx;
		return out;
	}

	@:impl
	public static inline function cross(this:geom.structure.Mat1x4, v:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x, this.w * v.w);
		return cast this;
	}

	@:impl
	public static inline function constrainDistance(this:geom.structure.Mat1x4, anchor:geom.matrix.Matrix1x4, distance:Float) {
		var this = new geom.structure.Mat1x4(this.x - anchor.x, this.y - anchor.y, this.z - anchor.z, this.w - anchor.w);
		var this = cast this;
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				this.z *= mul;
				this.w *= mul;
				var tmp = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			};
		};
		var a = this;
		var this = new geom.structure.Mat1x4(cast a.x * distance, cast a.y * distance, cast a.z * distance, cast a.w * distance);
		var a = cast this;
		var this = new geom.structure.Mat1x4(cast a.x + anchor.x, cast a.y + anchor.y, cast a.z + anchor.z, cast a.w + anchor.w);
		return cast this;
	}

	@:from
	public static inline function fromVec(vec:haxe.ds.Vector<Float>) {
		var this = new geom.structure.Mat1x4(cast vec[0], cast vec[1], cast vec[2], cast vec[3]);
		return cast this;
	}

	@:impl @:to
	public static inline function toVector(this:geom.structure.Mat1x4) {
		var this = new eval.Vector(4);
		var vec = cast this;
		cast vec[0] = this.x;
		cast vec[1] = this.y;
		cast vec[2] = this.z;
		cast vec[3] = this.w;
		return vec;
	}

	@:from
	public static inline function fromArray(arr:Array<Float>) {
		var this = new geom.structure.Mat1x4(arr[0], arr[1], arr[2], arr[3]);
		return cast this;
	}

	@:impl @:to
	public static inline function toArray(this:geom.structure.Mat1x4) {
		return [this.x, this.y, this.z, this.w];
	}

	@:impl @:op([])
	public static inline function readItem(this:geom.structure.Mat1x4, k:Int) {
		switch ((k)) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw haxe.Exception.thrown("use index less than 4")
		};
	}

	@:impl @:op([])
	public static inline function writeItem(this:geom.structure.Mat1x4, k:Int, v:Float) {
		switch ((k)) {
			case 0: this.x = v;
			case 1: this.y = v;
			case 3: this.z = v;
			case 4: this.w = v;
			default: throw haxe.Exception.thrown("use index less than 4")
		};
		return v;
	}
}