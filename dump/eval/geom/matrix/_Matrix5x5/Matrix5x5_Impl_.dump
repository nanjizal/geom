@:used
private class geom.matrix._Matrix5x5.Matrix5x5_Impl_ {

	@:value(5)
	public static inline var rows:Int = 5;

	@:value(5)
	public static inline var columns:Int = 5;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat5x5) {
		var this = m;
		return cast this;
	}

	@:impl
	public static inline function clone(this:geom.structure.Mat5x5) {
		var this = new geom.structure.Mat5x5(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m, this.n, this.o, this.p, this.q, this.r, this.s, this.t, this.u, this.v, this.w, this.x, this.y);
		return cast this;
	}

	@:impl
	public static inline function iterator(this:geom.structure.Mat5x5) {
		return new haxe.iterators.ArrayIterator([this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m, this.n, this.o, this.p, this.q, this.r, this.s, this.t, this.u, this.v, this.w, this.x, this.y]);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_self(this:geom.structure.Mat5x5) {
		return cast this;
	}

	public static var zero(get,never):geom.matrix.Matrix5x5;

	static inline function get_zero() {
		var this = new geom.structure.Mat5x5(0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_nought(this:geom.structure.Mat5x5) {
		var this = new geom.structure.Mat5x5(0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this;
	}

	public static var unit(get,never):geom.matrix.Matrix5x5;

	static inline function get_unit() {
		var this = new geom.structure.Mat5x5(1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1.);
		return cast this;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_one(this:geom.structure.Mat5x5) {
		var this = new geom.structure.Mat5x5(1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1.);
		return cast this;
	}

	public static var minus1(get,never):geom.matrix.Matrix5x5;

	static inline function get_minus1() {
		var this = new geom.structure.Mat5x5(1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1.);
		var a = cast this;
		var this = new geom.structure.Mat5x5(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i, - cast a.j, - cast a.k, - cast a.l, - cast a.m, - cast a.n, - cast a.o, - cast a.p, - cast a.q, - cast a.r, - cast a.s, - cast a.t, - cast a.u, - cast a.v, - cast a.w, - cast a.x, - cast a.y);
		return cast this;
	}

	public static var counting(get,never):geom.matrix.Matrix5x5;

	static inline function get_counting() {
		var this = new geom.structure.Mat5x5(1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.);
		return cast this;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_testCount(this:geom.structure.Mat5x5) {
		var this = new geom.structure.Mat5x5(1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.);
		return cast this;
	}

	@:op(A == B)
	public static inline function equal(a:geom.matrix.Matrix5x5, b:geom.matrix.Matrix5x5) {
		var delta = 0.0000001;
		return ! (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta || Math.abs(a.e - b.e) >= delta || Math.abs(a.f - b.f) >= delta || Math.abs(a.g - b.g) >= delta || Math.abs(a.h - b.h) >= delta || Math.abs(a.i - b.i) >= delta || Math.abs(a.j - b.j) >= delta || Math.abs(a.k - b.k) >= delta || Math.abs(a.l - b.l) >= delta || Math.abs(a.m - b.m) >= delta || Math.abs(a.n - b.n) >= delta || Math.abs(a.o - b.o) >= delta || Math.abs(a.p - b.p) >= delta || Math.abs(a.q - b.q) >= delta || Math.abs(a.r - b.r) >= delta || Math.abs(a.s - b.s) >= delta || Math.abs(a.t - b.t) >= delta || Math.abs(a.u - b.u) >= delta || Math.abs(a.v - b.v) >= delta || Math.abs(a.w - b.w) >= delta || Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta);
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix5x5, b:geom.matrix.Matrix5x5) {
		var delta = 0.0000001;
		return (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta || Math.abs(a.e - b.e) >= delta || Math.abs(a.f - b.f) >= delta || Math.abs(a.g - b.g) >= delta || Math.abs(a.h - b.h) >= delta || Math.abs(a.i - b.i) >= delta || Math.abs(a.j - b.j) >= delta || Math.abs(a.k - b.k) >= delta || Math.abs(a.l - b.l) >= delta || Math.abs(a.m - b.m) >= delta || Math.abs(a.n - b.n) >= delta || Math.abs(a.o - b.o) >= delta || Math.abs(a.p - b.p) >= delta || Math.abs(a.q - b.q) >= delta || Math.abs(a.r - b.r) >= delta || Math.abs(a.s - b.s) >= delta || Math.abs(a.t - b.t) >= delta || Math.abs(a.u - b.u) >= delta || Math.abs(a.v - b.v) >= delta || Math.abs(a.w - b.w) >= delta || Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta);
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix5x5) {
		var this = new geom.structure.Mat5x5(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i, - cast a.j, - cast a.k, - cast a.l, - cast a.m, - cast a.n, - cast a.o, - cast a.p, - cast a.q, - cast a.r, - cast a.s, - cast a.t, - cast a.u, - cast a.v, - cast a.w, - cast a.x, - cast a.y);
		return cast this;
	}

	@:impl
	public static inline function negate(this:geom.structure.Mat5x5) {
		var this = new geom.structure.Mat5x5(- this.a, - this.b, - this.c, - this.d, - this.e, - this.f, - this.g, - this.h, - this.i, - this.j, - this.k, - this.l, - this.m, - this.n, - this.o, - this.p, - this.q, - this.r, - this.s, - this.t, - this.u, - this.v, - this.w, - this.x, - this.y);
		return cast this;
	}

	@:op(A * B)
	public static inline function multiply(r:geom.matrix.Matrix5x5, s:geom.matrix.Matrix5x5) {
		var this = new geom.structure.Mat5x5(r.a * s.a + r.b * s.f + r.c * s.k + r.d * s.p + r.e * s.u, r.a * s.b + r.b * s.g + r.c * s.l + r.d * s.q + r.e * s.v, r.a * s.c + r.b * s.h + r.c * s.m + r.d * s.r + r.e * s.w, r.a * s.d + r.b * s.i + r.c * s.n + r.d * s.s + r.e * s.x, r.a * s.e + r.b * s.j + r.c * s.o + r.d * s.t + r.e * s.y, r.f * s.a + r.g * s.f + r.h * s.k + r.i * s.p + r.j * s.u, r.f * s.b + r.g * s.g + r.h * s.l + r.i * s.q + r.j * s.v, r.f * s.c + r.g * s.h + r.h * s.m + r.i * s.r + r.j * s.w, r.f * s.d + r.g * s.i + r.h * s.n + r.i * s.s + r.j * s.x, r.f * s.e + r.g * s.j + r.h * s.o + r.i * s.t + r.j * s.y, r.k * s.a + r.l * s.f + r.m * s.k + r.n * s.p + r.o * s.u, r.k * s.b + r.l * s.g + r.m * s.l + r.n * s.q + r.o * s.v, r.k * s.c + r.l * s.h + r.m * s.m + r.n * s.r + r.o * s.w, r.k * s.d + r.l * s.i + r.m * s.n + r.n * s.s + r.o * s.x, r.k * s.e + r.l * s.j + r.m * s.o + r.n * s.t + r.o * s.y, r.p * s.a + r.q * s.f + r.r * s.k + r.s * s.p + r.t * s.u, r.p * s.b + r.q * s.g + r.r * s.l + r.s * s.q + r.t * s.v, r.p * s.c + r.q * s.h + r.r * s.m + r.s * s.r + r.t * s.w, r.p * s.d + r.q * s.i + r.r * s.n + r.s * s.s + r.t * s.x, r.p * s.e + r.q * s.j + r.r * s.o + r.s * s.t + r.t * s.y, r.u * s.a + r.v * s.f + r.w * s.k + r.x * s.p + r.y * s.u, r.u * s.b + r.v * s.g + r.w * s.l + r.x * s.q + r.y * s.v, r.u * s.c + r.v * s.h + r.w * s.m + r.x * s.r + r.y * s.w, r.u * s.d + r.v * s.i + r.w * s.n + r.x * s.s + r.y * s.x, r.u * s.e + r.v * s.j + r.w * s.o + r.x * s.t + r.y * s.y);
		return cast this;
	}

	@:op(A + B)
	public static inline function add(m0:geom.matrix.Matrix5x5, m1:geom.matrix.Matrix5x5) {
		var this = new geom.structure.Mat5x5(m0.a + m1.a, m0.b + m1.b, m0.c + m1.c, m0.d + m1.d, m0.e + m1.e, m0.f + m1.f, m0.g + m1.g, m0.h + m1.h, m0.i + m1.i, m0.j + m1.j, m0.k + m1.k, m0.l + m1.l, m0.m + m1.m, m0.n + m1.n, m0.o + m1.o, m0.p + m1.p, m0.q + m1.q, m0.r + m1.r, m0.s + m1.s, m0.t + m1.t, m0.u + m1.u, m0.v + m1.v, m0.w + m1.w, m0.x + m1.x, m0.y + m1.y);
		return cast this;
	}

	@:op(A - B)
	public static inline function sub(m0:geom.matrix.Matrix5x5, m1:geom.matrix.Matrix5x5) {
		var this = new geom.structure.Mat5x5(m0.a - m1.a, m0.b - m1.b, m0.c - m1.c, m0.d - m1.d, m0.e - m1.e, m0.f - m1.f, m0.g - m1.g, m0.h - m1.h, m0.i - m1.i, m0.j - m1.j, m0.k - m1.k, m0.l - m1.l, m0.m - m1.m, m0.n - m1.n, m0.o - m1.o, m0.p - m1.p, m0.q - m1.q, m0.r - m1.r, m0.s - m1.s, m0.t - m1.t, m0.u - m1.u, m0.v - m1.v, m0.w - m1.w, m0.x - m1.x, m0.y - m1.y);
		return cast this;
	}

	@:impl
	public static inline function transpose(this:geom.structure.Mat5x5) {
		var this = new geom.structure.Mat5x5(this.a, this.f, this.k, this.p, this.u, this.b, this.g, this.l, this.q, this.v, this.c, this.h, this.m, this.r, this.w, this.d, this.i, this.n, this.s, this.x, this.e, this.j, this.o, this.t, this.y);
		return cast this;
	}

	@:impl
	public static inline function setXY(this:geom.structure.Mat5x5, x:Int, y:Int, v:Float) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this.a = v;
				case 1: return this.b = v;
				case 2: return this.c = v;
				case 3: return this.d = v;
				case 4: return this.e = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 1: switch ((y)) {
				case 0: return this.f = v;
				case 1: return this.g = v;
				case 2: return this.h = v;
				case 3: return this.i = v;
				case 4: return this.j = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 2: switch ((y)) {
				case 0: return this.k = v;
				case 1: return this.l = v;
				case 2: return this.m = v;
				case 3: return this.n = v;
				case 4: return this.o = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 3: switch ((y)) {
				case 0: return this.p = v;
				case 1: return this.q = v;
				case 2: return this.r = v;
				case 3: return this.s = v;
				case 4: return this.t = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 4: switch ((y)) {
				case 0: return this.u = v;
				case 1: return this.v = v;
				case 2: return this.w = v;
				case 3: return this.x = v;
				case 4: return this.y = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
		};
	}

	@:impl
	public static inline function getXY(this:geom.structure.Mat5x5, x:Int, y:Int) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this.a;
				case 1: return this.b;
				case 2: return this.c;
				case 3: return this.d;
				case 4: return this.e;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 1: switch ((y)) {
				case 0: return this.f;
				case 1: return this.g;
				case 2: return this.h;
				case 3: return this.i;
				case 4: return this.j;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 2: switch ((y)) {
				case 0: return this.k;
				case 1: return this.l;
				case 2: return this.m;
				case 3: return this.n;
				case 4: return this.o;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 3: switch ((y)) {
				case 0: return this.p;
				case 1: return this.q;
				case 2: return this.r;
				case 3: return this.s;
				case 4: return this.t;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 4: switch ((y)) {
				case 0: return this.u;
				case 1: return this.v;
				case 2: return this.w;
				case 3: return this.x;
				case 4: return this.y;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
		};
	}

	@:impl
	public static inline function pretty(this:geom.structure.Mat5x5, prec:Int) {
		var sa = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.a, prec);
		var sb = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.b, prec);
		var sc = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.c, prec);
		var sd = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.d, prec);
		var se = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.e, prec);
		var sf = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.f, prec);
		var sg = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.g, prec);
		var sh = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.h, prec);
		var si = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.i, prec);
		var sj = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.j, prec);
		var sk = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.k, prec);
		var sl = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.l, prec);
		var sm = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.m, prec);
		var sn = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.n, prec);
		var so = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.o, prec);
		var sp = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.p, prec);
		var sq = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.q, prec);
		var sr = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.r, prec);
		var ss = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.s, prec);
		var st = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.t, prec);
		var su = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.u, prec);
		var sv = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.v, prec);
		var sw = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.w, prec);
		var sx = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.x, prec);
		var sy = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this.y, prec);
		var la = sa.length;
		var lb = sb.length;
		var lc = sc.length;
		var ld = sd.length;
		var le = se.length;
		var lf = sf.length;
		var lg = sg.length;
		var lh = sh.length;
		var li = si.length;
		var lj = sj.length;
		var lk = sk.length;
		var ll = sl.length;
		var lm = sm.length;
		var ln = sn.length;
		var lo = so.length;
		var lp = sp.length;
		var lq = sq.length;
		var lr = sr.length;
		var ls = ss.length;
		var lt = st.length;
		var lu = su.length;
		var lv = sv.length;
		var lw = sw.length;
		var lx = sx.length;
		var ly = sy.length;
		var r0 = Math.round(Math.max(Math.max(Math.max(Math.max(la, lf), lk), lp), lu));
		var r1 = Math.round(Math.max(Math.max(Math.max(Math.max(lb, lg), ll), lq), lv));
		var r2 = Math.round(Math.max(Math.max(Math.max(Math.max(lc, lh), lm), lr), lw));
		var r3 = Math.round(Math.max(Math.max(Math.max(Math.max(ld, li), ln), ls), lx));
		var r4 = Math.round(Math.max(Math.max(Math.max(Math.max(le, lj), lo), lt), ly));
		var spaces = "";
		{
			var ` = 0;
			var `1 = r0;
			while ((` < `1)) {
				var n = ` ++;
				spaces += " ";
			};
		};
		sa = spaces.substr(0, r0 - la) + sa;
		sf = spaces.substr(0, r0 - lf) + sf;
		sk = spaces.substr(0, r0 - lk) + sk;
		sp = spaces.substr(0, r0 - lp) + sp;
		su = spaces.substr(0, r0 - lu) + su;
		var spaces = "";
		{
			var `2 = 0;
			var `3 = r1;
			while ((`2 < `3)) {
				var n = `2 ++;
				spaces += " ";
			};
		};
		sb = spaces.substr(0, r1 - lb) + sb;
		sg = spaces.substr(0, r1 - lg) + sg;
		sl = spaces.substr(0, r1 - ll) + sl;
		sq = spaces.substr(0, r1 - lq) + sq;
		sv = spaces.substr(0, r1 - lv) + sv;
		var space = "";
		{
			var `4 = 0;
			var `5 = r2;
			while ((`4 < `5)) {
				var n = `4 ++;
				spaces += " ";
			};
		};
		sc = spaces.substr(0, r2 - lc) + sc;
		sh = spaces.substr(0, r2 - lh) + sh;
		sm = spaces.substr(0, r2 - lm) + sm;
		sr = spaces.substr(0, r2 - lr) + sr;
		sw = spaces.substr(0, r2 - lw) + sw;
		var space = "";
		{
			var `6 = 0;
			var `7 = r3;
			while ((`6 < `7)) {
				var n = `6 ++;
				spaces += " ";
			};
		};
		sd = spaces.substr(0, r3 - ld) + sd;
		si = spaces.substr(0, r3 - li) + si;
		sn = spaces.substr(0, r3 - ln) + sn;
		ss = spaces.substr(0, r3 - ls) + ss;
		sx = spaces.substr(0, r3 - lx) + sx;
		var space = "";
		{
			var `8 = 0;
			var `9 = r4;
			while ((`8 < `9)) {
				var n = `8 ++;
				spaces += " ";
			};
		};
		se = spaces.substr(0, r4 - le) + se;
		sj = spaces.substr(0, r4 - lj) + sj;
		so = spaces.substr(0, r4 - lo) + so;
		st = spaces.substr(0, r4 - lt) + st;
		sy = spaces.substr(0, r4 - ly) + sy;
		return "\n" + "/ " + sa + ", " + sb + ", " + sc + ", " + sd + ", " + se + " \\\n" + "| " + sf + ", " + sg + ", " + sh + ", " + si + ", " + sj + " |\n" + "| " + sk + ", " + sl + ", " + sm + ", " + sn + ", " + so + " |\n" + "| " + sp + ", " + sq + ", " + sr + ", " + ss + ", " + st + " |\n" + "\\ " + su + ", " + sv + ", " + sw + ", " + sx + ", " + sy + " /\n";
	}

	public static inline function max5(f0:Float, f1:Float, f2:Float, f3:Float, f4:Float) {
		return Math.round(Math.max(Math.max(Math.max(Math.max(f0, f1), f2), f3), f4));
	}

	public static function floatToStringPrecision(n:Float, prec:Int) {
		if ((n == 0)) {
			var ` = [];
			{
				var `1 = 0;
				var `2 = prec;
				while ((`1 < `2)) {
					var i = `1 ++;
					`.push("0");
				};
			};
			return "0." + `.join("");
		};
		var minusSign = n < 0.0;
		n = Math.abs(n);
		var intPart = Math.floor(n);
		var p = Math.pow(10, prec);
		var fracPart = Math.round(p * (n - intPart));
		var buf = new StringBuf();
		if ((minusSign)) buf.addChar(45);
		buf.add(Std.string(intPart));
		if ((fracPart == 0)) {
			buf.addChar(46);
			{
				var ` = 0;
				var `1 = prec;
				while ((` < `1)) {
					var i = ` ++;
					buf.addChar(48);
				};
			};
		} else {
			buf.addChar(46);
			p /= 10;
			var nZeros = 0;
			while ((fracPart < p)) {
				p /= 10;
				buf.addChar(48);
			};
			buf.add(fracPart);
		};
		return buf.toString();
	}
}