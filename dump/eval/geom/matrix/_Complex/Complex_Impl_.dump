@:directlyUsed @:used
private class geom.matrix._Complex.Complex_Impl_ {

	@:from
	public static inline function fromString(s:String) {
		var removeI = s.substr(0, s.length - 1);
		var split = removeI.split("+");
		var this = new geom.structure.Mat1x2(0., 0.);
		var c = cast this;
		{
			var v = Std.parseFloat(split[0]);
			cast c.x = v;
		};
		{
			var v = Std.parseFloat(split[1]);
			cast c.y = v;
		};
		return c;
	}

	@:from
	public static inline function fromRealImaginary(c:{ real : Float, imaginary : Float }) {
		var this = new geom.structure.Mat1x2(c.real, c.imaginary);
		return cast this;
	}

	@:from
	public static inline function fromRi(c:{ r : Float, i : Float }) {
		var this = new geom.structure.Mat1x2(c.r, c.i);
		return cast this;
	}

	@:from
	public static inline function fromRealI(c:{ real : Float, i : Float }) {
		var this = new geom.structure.Mat1x2(c.real, c.i);
		return cast this;
	}

	@:impl @:to
	public static inline function toString(this:geom.structure.Mat1x2) {
		var r = this.x;
		var i = this.y;
		return "" + r + " + " + i + " i";
	}

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat1x2) {
		var this = m;
		return cast this;
	}

	public static var zero(get,null):geom.matrix.Complex;

	static inline function get_zero() {
		var this = new geom.structure.Mat1x2(0., 0.);
		return cast this;
	}

	public static var one(get,null):geom.matrix.Complex;

	static inline function get_one() {
		var this = new geom.structure.Mat1x2(1., 0.);
		return cast this;
	}

	public static var minus1(get,null):geom.matrix.Complex;

	static inline function get_minus1() {
		var this = new geom.structure.Mat1x2(-1., 0.);
		return cast this;
	}

	public static var unit(get,null):geom.matrix.Complex;

	static inline function get_unit() {
		var this = new geom.structure.Mat1x2(1., 1.);
		return cast this;
	}

	public static var i1(get,null):geom.matrix.Complex;

	static inline function get_i1() {
		var this = new geom.structure.Mat1x2(0., 1.);
		return cast this;
	}

	public static var iMinus1(get,null):geom.matrix.Complex;

	static inline function get_iMinus1() {
		var this = new geom.structure.Mat1x2(0., -1.);
		return cast this;
	}

	public static var minusUnit(get,null):geom.matrix.Complex;

	static inline function get_minusUnit() {
		var this = new geom.structure.Mat1x2(-1., -1.);
		return cast this;
	}

	public static var unitInfinity(get,null):geom.matrix.Complex;

	static inline function get_unitInfinity() {
		var this = new geom.structure.Mat1x2(Math.POSITIVE_INFINITY, Math.POSITIVE_INFINITY);
		return cast this;
	}

	public static var unitMinusInfinity(get,null):geom.matrix.Complex;

	static inline function get_unitMinusInfinity() {
		var this = new geom.structure.Mat1x2(Math.NEGATIVE_INFINITY, Math.NEGATIVE_INFINITY);
		return cast this;
	}

	public static var realInfinity(get,null):geom.matrix.Complex;

	static inline function get_realInfinity() {
		var this = new geom.structure.Mat1x2(Math.POSITIVE_INFINITY, 0.);
		return cast this;
	}

	public static var minusInfinity(get,null):geom.matrix.Complex;

	static inline function get_minusInfinity() {
		var this = new geom.structure.Mat1x2(Math.NEGATIVE_INFINITY, 0.);
		return cast this;
	}

	public static var iInfinity(get,null):geom.matrix.Complex;

	static inline function get_iInfinity() {
		var this = new geom.structure.Mat1x2(0., Math.POSITIVE_INFINITY);
		return cast this;
	}

	public static var iMinusInfinity(get,null):geom.matrix.Complex;

	static inline function get_iMinusInfinity() {
		var this = new geom.structure.Mat1x2(0., Math.NEGATIVE_INFINITY);
		return cast this;
	}

	public static var posNegInfinity(get,null):geom.matrix.Complex;

	static inline function get_posNegInfinity() {
		var this = new geom.structure.Mat1x2(Math.POSITIVE_INFINITY, Math.NEGATIVE_INFINITY);
		return cast this;
	}

	public static var negPosInfinity(get,null):geom.matrix.Complex;

	static inline function get_negPosInfinity() {
		var this = new geom.structure.Mat1x2(Math.NEGATIVE_INFINITY, Math.POSITIVE_INFINITY);
		return cast this;
	}

	public static var realPi(get,null):geom.matrix.Complex;

	static inline function get_realPi() {
		var this = new geom.structure.Mat1x2(Math.PI, 0.);
		return cast this;
	}

	public static var iPi(get,null):geom.matrix.Complex;

	static inline function get_iPi() {
		var this = new geom.structure.Mat1x2(0., Math.PI);
		return cast this;
	}

	public static var unitPi(get,null):geom.matrix.Complex;

	static inline function get_unitPi() {
		var this = new geom.structure.Mat1x2(Math.PI, Math.PI);
		return cast this;
	}

	public static var unitMinusPi(get,null):geom.matrix.Complex;

	static inline function get_unitMinusPi() {
		var this = new geom.structure.Mat1x2(- Math.PI, - Math.PI);
		return cast this;
	}

	public static var iMinusPi(get,null):geom.matrix.Complex;

	static inline function get_iMinusPi() {
		var this = new geom.structure.Mat1x2(0., - Math.PI);
		return cast this;
	}

	public static var minusPi(get,null):geom.matrix.Complex;

	static inline function get_minusPi() {
		var this = new geom.structure.Mat1x2(- Math.PI, 0.);
		return cast this;
	}

	public static var posNegPi(get,null):geom.matrix.Complex;

	static inline function get_posNegPi() {
		var this = new geom.structure.Mat1x2(Math.PI, - Math.PI);
		return cast this;
	}

	public static var negPosPi(get,null):geom.matrix.Complex;

	static inline function get_negPosPi() {
		var this = new geom.structure.Mat1x2(- Math.PI, Math.PI);
		return cast this;
	}

	public static var realTau(get,null):geom.matrix.Complex;

	static inline function get_realTau() {
		var this = new geom.structure.Mat1x2(Math.PI * 2, 0.);
		return cast this;
	}

	public static var iTau(get,null):geom.matrix.Complex;

	static inline function get_iTau() {
		var this = new geom.structure.Mat1x2(0., Math.PI * 2);
		return cast this;
	}

	public static var unitTau(get,null):geom.matrix.Complex;

	static inline function get_unitTau() {
		var this = new geom.structure.Mat1x2(Math.PI * 2, Math.PI * 2);
		return cast this;
	}

	public static var unitMinusTau(get,null):geom.matrix.Complex;

	static inline function get_unitMinusTau() {
		var this = new geom.structure.Mat1x2(- Math.PI * 2, - Math.PI * 2);
		return cast this;
	}

	public static var iMinusTau(get,null):geom.matrix.Complex;

	static inline function get_iMinusTau() {
		var this = new geom.structure.Mat1x2(0., - Math.PI * 2);
		return cast this;
	}

	public static var minusTau(get,null):geom.matrix.Complex;

	static inline function get_minusTau() {
		var this = new geom.structure.Mat1x2(- Math.PI * 2, 0.);
		return cast this;
	}

	public static var posNegTau(get,null):geom.matrix.Complex;

	static inline function get_posNegTau() {
		var this = new geom.structure.Mat1x2(Math.PI * 2, - Math.PI * 2);
		return cast this;
	}

	public static var negPosTau(get,null):geom.matrix.Complex;

	static inline function get_negPosTau() {
		var this = new geom.structure.Mat1x2(- Math.PI * 2, Math.PI * 2);
		return cast this;
	}

	@:impl
	public static var i(get,set):Float;

	@:impl
	static inline function get_i(this:geom.structure.Mat1x2) {
		return this.y;
	}

	@:impl
	static inline function set_i(this:geom.structure.Mat1x2, v:Float) {
		this.y = v;
		return v;
	}

	@:impl
	public static var real(get,set):Float;

	@:impl
	static inline function get_real(this:geom.structure.Mat1x2) {
		return this.x;
	}

	@:impl
	static inline function set_real(this:geom.structure.Mat1x2, v:Float) {
		this.x = v;
		return v;
	}

	@:impl
	public static inline function clone(this:geom.structure.Mat1x2) {
		var this = new geom.structure.Mat1x2(this.x, this.y);
		return cast this;
	}

	@:impl
	public static inline function swap(this:geom.structure.Mat1x2) {
		var this = new geom.structure.Mat1x2(this.y, this.x);
		return cast this;
	}

	@:op(A == B)
	public static inline function equal(a:geom.matrix.Complex, b:geom.matrix.Complex) {
		var delta = 0.0000001;
		return ! (Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta);
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Complex, b:geom.matrix.Complex) {
		var delta = 0.0000001;
		return (Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta);
	}

	@:op(A + B)
	public static inline function add(a:geom.matrix.Complex, b:geom.matrix.Complex) {
		var this = new geom.structure.Mat1x2(a.x + b.x, a.y + b.y);
		return cast this;
	}

	@:op(A - B)
	public static inline function subtract(a:geom.matrix.Complex, b:geom.matrix.Complex) {
		var this = new geom.structure.Mat1x2(a.x - b.x, a.y - b.y);
		return cast this;
	}

	@:op(A * B)
	public static inline function scale(a:Float, b:geom.matrix.Complex) {
		var this = new geom.structure.Mat1x2(a * b.x, a * b.y);
		return cast this;
	}

	@:op(A * B)
	public static inline function multiply(a:geom.matrix.Complex, b:geom.matrix.Complex) {
		var this = new geom.structure.Mat1x2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
		return cast this;
	}

	@:impl
	public static inline function addExponents(this:geom.structure.Mat1x2) {
		return this.x + this.y;
	}

	@:op(~A)
	public static inline function conjugate(a:geom.matrix.Complex) {
		var this = new geom.structure.Mat1x2(a.x, - a.y);
		return cast this;
	}

	@:op(A / B)
	public static inline function divide(c1:geom.matrix.Complex, c2:geom.matrix.Complex) {
		var this = new geom.structure.Mat1x2(c2.x, - c2.y);
		var conj = cast this;
		var this = new geom.structure.Mat1x2(c1.x * conj.x - c1.y * conj.y, c1.x * conj.y + c1.y * conj.x);
		var numr = cast this;
		var this = new geom.structure.Mat1x2(c2.x * conj.x - c2.y * conj.y, c2.x * conj.y + c2.y * conj.x);
		var demr = cast this;
		var dval = cast demr.x + cast demr.y;
		var this = new geom.structure.Mat1x2(cast numr.x / dval, cast numr.y / dval);
		return cast this;
	}

	@:op(-A)
	public static inline function negate(a:geom.matrix.Complex) {
		var this = new geom.structure.Mat1x2(- a.x, - a.y);
		return cast this;
	}

	@:impl
	public static inline function magnitudeSquared(this:geom.structure.Mat1x2) {
		return this.x * this.x + this.y * this.y;
	}

	@:impl
	public static var magnitude(get,set):Float;

	@:impl
	static inline function get_magnitude(this:geom.structure.Mat1x2) {
		return Math.sqrt(cast this.x * cast this.x + cast this.y * cast this.y);
	}

	@:impl
	static inline function set_magnitude(this:geom.structure.Mat1x2, length:Float) {
		var currentLength = Math.sqrt(cast this.x * cast this.x + cast this.y * cast this.y);
		if ((currentLength == 0.)) return 0. else {
			var mul = length / currentLength;
			this.x *= mul;
			this.y *= mul;
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};
	}

	@:impl
	public static inline function phase(this:geom.structure.Mat1x2) {
		return Math.atan2(this.y, this.x);
	}

	@:impl
	public static inline function isReal(this:geom.structure.Mat1x2) {
		return this.y == 0;
	}

	@:impl
	public static inline function isImaginary(this:geom.structure.Mat1x2) {
		return this.x == 0;
	}

	public static inline function cis(angle:Float) {
		var this = new geom.structure.Mat1x2(Math.cos(angle), Math.sin(angle));
		return cast this;
	}

	public static inline function fromCircle(r:Float, angle:Float) {
		var this = new geom.structure.Mat1x2(Math.cos(angle), Math.sin(angle));
		var b = cast this;
		var this = new geom.structure.Mat1x2(r * b.x, r * b.y);
		return cast this;
	}

	public static inline function square(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(cast c.x * cast c.x, cast 0);
			return cast this;
		} else {
			var this = new geom.structure.Mat1x2(c.x, c.y);
			var here = cast this;
			var this = new geom.structure.Mat1x2(here.x * here.x - here.y * here.y, here.x * here.y + here.y * here.x);
			return cast this;
		};
	}

	public static inline function exp(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.exp(cast c.x), cast 0);
			return cast this;
		} else {
			var this = new geom.structure.Mat1x2(Math.exp(cast c.x) * Math.cos(cast c.y), Math.exp(cast c.x) * Math.sin(cast c.y));
			return cast this;
		};
	}

	public static inline function ln(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.log(cast c.x), cast 0);
			return cast this;
		} else {
			var ` = 0.5 * Math.log(cast c.x * cast c.x + cast c.y * cast c.y);
			var m;
			if ((cast c.x > 0.)) m = Math.atan(cast c.y / cast c.x) else if ((cast c.x < 0. && cast c.y >= 0.)) m = Math.atan(cast c.y / cast c.x) + Math.PI else if ((cast c.x < 0. && cast c.y < 0.)) m = Math.atan(cast c.y / cast c.x) - Math.PI else if ((cast c.x == 0. && cast c.y > 0.)) m = Math.PI / 2 else if ((cast c.x == 0. && cast c.y < 0.)) m = - Math.PI / 2 else throw haxe.Exception.thrown("Complex.zero does not have arg?");
			var this = new geom.structure.Mat1x2(`, m);
			return cast this;
		};
	}

	public static inline function arg(c:geom.matrix.Complex) {
		if ((cast c.x > 0.)) return Math.atan(cast c.y / cast c.x) else if ((cast c.x < 0. && cast c.y >= 0.)) return Math.atan(cast c.y / cast c.x) + Math.PI else if ((cast c.x < 0. && cast c.y < 0.)) return Math.atan(cast c.y / cast c.x) - Math.PI else if ((cast c.x == 0. && cast c.y > 0.)) return Math.PI / 2 else if ((cast c.x == 0. && cast c.y < 0.)) return - Math.PI / 2 else throw haxe.Exception.thrown("Complex.zero does not have arg?");
	}

	@:impl
	public static inline function reciprocal(this:geom.structure.Mat1x2) {
		var scale = this.x * this.x + this.y * this.y;
		var this = new geom.structure.Mat1x2(this.x / scale, - this.y / scale);
		return cast this;
	}

	public static inline function pow(c:geom.matrix.Complex, n:Float) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.pow(cast c.x, n), cast 0);
			return cast this;
		} else {
			var a = Math.pow(Math.sqrt(cast c.x * cast c.x + cast c.y * cast c.y), n);
			var angle = n * Math.atan2(cast c.y, cast c.x);
			var this = new geom.structure.Mat1x2(Math.cos(angle), Math.sin(angle));
			var b = cast this;
			var this = new geom.structure.Mat1x2(a * b.x, a * b.y);
			return cast this;
		};
	}

	public static inline function squareRoot(c:geom.matrix.Complex) {
		if ((cast c.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.pow(cast c.x, 0.5), cast 0);
			return cast this;
		} else {
			var a = Math.pow(Math.sqrt(cast c.x * cast c.x + cast c.y * cast c.y), 0.5);
			var angle = 0.5 * Math.atan2(cast c.y, cast c.x);
			var this = new geom.structure.Mat1x2(Math.cos(angle), Math.sin(angle));
			var b = cast this;
			var this = new geom.structure.Mat1x2(a * b.x, a * b.y);
			return cast this;
		};
	}

	@:impl
	public static inline function root2(this:geom.structure.Mat1x2) {
		if ((this.y == 0 == true)) {
			var this = new geom.structure.Mat1x2(Math.pow(this.x, 0.5), cast 0);
			return cast this;
		} else {
			var a = Math.pow(Math.sqrt(this.x * this.x + this.y * this.y), 0.5);
			var angle = 0.5 * Math.atan2(this.y, this.x);
			var this = new geom.structure.Mat1x2(Math.cos(angle), Math.sin(angle));
			var b = cast this;
			var this = new geom.structure.Mat1x2(a * b.x, a * b.y);
			return cast this;
		};
	}
}