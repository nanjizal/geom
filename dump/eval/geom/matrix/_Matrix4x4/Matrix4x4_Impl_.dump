@:used
private class geom.matrix._Matrix4x4.Matrix4x4_Impl_ {

	@:value(4)
	public static inline var rows:Int = 4;

	@:value(4)
	public static inline var columns:Int = 4;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat4x4) {
		var this = m;
		return cast this;
	}

	@:impl
	public static inline function clone(this:geom.structure.Mat4x4) {
		var this = new geom.structure.Mat4x4(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m, this.n, this.o, this.p);
		return cast this;
	}

	@:impl
	public static inline function iterator(this:geom.structure.Mat4x4) {
		return new haxe.iterators.ArrayIterator([this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m, this.n, this.o, this.p]);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix4x4;

	@:impl
	static inline function get_self(this:geom.structure.Mat4x4) {
		return cast this;
	}

	public static var zero(get,never):geom.matrix.Matrix4x4;

	static inline function get_zero() {
		var this = new geom.structure.Mat4x4(0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix4x4;

	@:impl
	static inline function get_nought(this:geom.structure.Mat4x4) {
		var this = new geom.structure.Mat4x4(0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this;
	}

	public static var unit(get,never):geom.matrix.Matrix4x4;

	static inline function get_unit() {
		var this = new geom.structure.Mat4x4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1.);
		return cast this;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix4x4;

	@:impl
	static inline function get_one(this:geom.structure.Mat4x4) {
		var this = new geom.structure.Mat4x4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1.);
		return cast this;
	}

	public static var minus1(get,never):geom.matrix.Matrix4x4;

	static inline function get_minus1() {
		var this = new geom.structure.Mat4x4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1.);
		var a = cast this;
		var this = new geom.structure.Mat4x4(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i, - cast a.j, - cast a.k, - cast a.l, - cast a.m, - cast a.n, - cast a.o, - cast a.p);
		return cast this;
	}

	public static var counting(get,never):geom.matrix.Matrix4x4;

	static inline function get_counting() {
		var this = new geom.structure.Mat4x4(1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16.);
		return cast this;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix4x4;

	@:impl
	static inline function get_testCount(this:geom.structure.Mat4x4) {
		var this = new geom.structure.Mat4x4(1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16.);
		return cast this;
	}

	public static var _1_16(get,never):geom.matrix.Matrix4x4;

	static inline function get__1_16() {
		var this = new geom.structure.Mat4x4(1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16.);
		return cast this;
	}

	@:op(A == B)
	public static inline function equal(a:geom.matrix.Matrix4x4, b:geom.matrix.Matrix4x4) {
		var delta = 0.0000001;
		return ! (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta || Math.abs(a.e - b.e) >= delta || Math.abs(a.f - b.f) >= delta || Math.abs(a.g - b.g) >= delta || Math.abs(a.h - b.h) >= delta || Math.abs(a.i - b.i) >= delta || Math.abs(a.j - b.j) >= delta || Math.abs(a.k - b.k) >= delta || Math.abs(a.l - b.l) >= delta || Math.abs(a.m - b.m) >= delta || Math.abs(a.n - b.n) >= delta || Math.abs(a.o - b.o) >= delta || Math.abs(a.p - b.p) >= delta);
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix4x4, b:geom.matrix.Matrix4x4) {
		var delta = 0.0000001;
		return (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta || Math.abs(a.e - b.e) >= delta || Math.abs(a.f - b.f) >= delta || Math.abs(a.g - b.g) >= delta || Math.abs(a.h - b.h) >= delta || Math.abs(a.i - b.i) >= delta || Math.abs(a.j - b.j) >= delta || Math.abs(a.k - b.k) >= delta || Math.abs(a.l - b.l) >= delta || Math.abs(a.m - b.m) >= delta || Math.abs(a.n - b.n) >= delta || Math.abs(a.o - b.o) >= delta || Math.abs(a.p - b.p) >= delta);
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix4x4) {
		var this = new geom.structure.Mat4x4(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i, - cast a.j, - cast a.k, - cast a.l, - cast a.m, - cast a.n, - cast a.o, - cast a.p);
		return cast this;
	}

	@:impl
	public static inline function negate(this:geom.structure.Mat4x4) {
		var this = new geom.structure.Mat4x4(- this.a, - this.b, - this.c, - this.d, - this.e, - this.f, - this.g, - this.h, - this.i, - this.j, - this.k, - this.l, - this.m, - this.n, - this.o, - this.p);
		return cast this;
	}

	@:op(A + B)
	public static inline function add(m0:geom.matrix.Matrix4x4, m1:geom.matrix.Matrix4x4) {
		var this = new geom.structure.Mat4x4(m0.a + m1.a, m0.b + m1.b, m0.c + m1.c, m0.d + m1.d, m0.e + m1.e, m0.f + m1.f, m0.g + m1.g, m0.h + m1.h, m0.i + m1.i, m0.j + m1.j, m0.k + m1.k, m0.l + m1.l, m0.m + m1.m, m0.n + m1.n, m0.o + m1.o, m0.p + m1.p);
		return cast this;
	}

	@:op(A - B)
	public static inline function sub(m0:geom.matrix.Matrix4x4, m1:geom.matrix.Matrix4x4) {
		var this = new geom.structure.Mat4x4(m0.a - m1.a, m0.b - m1.b, m0.c - m1.c, m0.d - m1.d, m0.e - m1.e, m0.f - m1.f, m0.g - m1.g, m0.h - m1.h, m0.i - m1.i, m0.j - m1.j, m0.k - m1.k, m0.l - m1.l, m0.m - m1.m, m0.n - m1.n, m0.o - m1.o, m0.p - m1.p);
		return cast this;
	}

	@:op(A * B)
	public static inline function multiply(r:geom.matrix.Matrix4x4, s:geom.matrix.Matrix4x4) {
		var this = new geom.structure.Mat4x4(r.a * s.a + r.b * s.e + r.c * s.i + r.d * s.m, r.a * s.b + r.b * s.f + r.c * s.j + r.d * s.n, r.a * s.c + r.b * s.g + r.c * s.k + r.d * s.o, r.a * s.d + r.b * s.h + r.c * s.l + r.d * s.p, r.e * s.a + r.f * s.e + r.g * s.i + r.h * s.m, r.e * s.b + r.f * s.f + r.g * s.j + r.h * s.n, r.e * s.c + r.f * s.g + r.g * s.k + r.h * s.o, r.e * s.d + r.f * s.h + r.g * s.l + r.h * s.p, r.i * s.a + r.j * s.e + r.k * s.i + r.l * s.m, r.i * s.b + r.j * s.f + r.k * s.j + r.l * s.n, r.i * s.c + r.j * s.g + r.k * s.k + r.l * s.o, r.i * s.d + r.j * s.h + r.k * s.l + r.l * s.p, r.m * s.a + r.n * s.e + r.o * s.i + r.p * s.m, r.m * s.b + r.n * s.f + r.o * s.j + r.p * s.n, r.m + s.c + r.n * s.g + r.o * s.k + r.p * s.o, r.m * s.d + r.n * s.h + r.o * s.l + r.p * s.p);
		return cast this;
	}

	@:op(A / B)
	public static inline function scaleDivide(m:geom.matrix.Matrix4x4, p:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(1 / p.x, 1 / p.y, 1 / p.z, 1 / p.w);
		var pd = cast this;
		var this = new geom.structure.Mat4x4(m.a * pd.x, m.b, m.c, m.d, m.e, m.f * pd.y, m.g, m.h, m.i, m.j, m.k * pd.z, m.l, m.m, m.n, m.o, m.p * pd.w);
		return cast this;
	}

	@:op(A * B)
	public static inline function scaleMultiply1(p:geom.matrix.Matrix1x4, m:geom.matrix.Matrix4x4) {
		var this = new geom.structure.Mat4x4(m.a * p.x, m.b, m.c, m.d, m.e, m.f * p.y, m.g, m.h, m.i, m.j, m.k * p.z, m.l, m.m, m.n, m.o, m.p * p.w);
		return cast this;
	}

	@:op(A * B)
	public static inline function scaleMultiply2(m:geom.matrix.Matrix4x4, p:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat4x4(m.a * p.x, m.b, m.c, m.d, m.e, m.f * p.y, m.g, m.h, m.i, m.j, m.k * p.z, m.l, m.m, m.n, m.o, m.p * p.w);
		return cast this;
	}

	@:impl
	public static inline function delta(this:geom.structure.Mat4x4, x:Float, y:Float) {
		var this = new geom.structure.Mat4x4(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m + x, this.n + y, this.o, this.p);
		return cast this;
	}

	@:from
	public static inline function matrix4x3(m:geom.matrix.Matrix4x3) {
		var this = new geom.structure.Mat4x4(m.a, m.b, m.c, m.d, m.e, m.f, m.g, m.h, m.i, m.j, m.k, m.l, 0., 0., 0., 1.);
		return cast this;
	}

	@:impl
	public static inline function transpose(this:geom.structure.Mat4x4) {
		var this = new geom.structure.Mat4x4(this.a, this.e, this.i, this.m, this.b, this.f, this.j, this.n, this.c, this.g, this.k, this.o, this.d, this.h, this.l, this.p);
		return cast this;
	}

	@:impl
	public static inline function updateWebGL(this:geom.structure.Mat4x4, arr:haxe.io.Float32Array) {
		var here = this;
		{
			{
				var value = here.a;
				if ((0 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(cast arr.byteOffset, value);
			};
			{
				var value = here.e;
				if ((1 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(4 + cast arr.byteOffset, value);
			};
			{
				var value = here.i;
				if ((2 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(8 + cast arr.byteOffset, value);
			};
			{
				var value = here.m;
				if ((3 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(12 + cast arr.byteOffset, value);
			};
			{
				var value = here.b;
				if ((4 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(16 + cast arr.byteOffset, value);
			};
			{
				var value = here.f;
				if ((5 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(20 + cast arr.byteOffset, value);
			};
			{
				var value = here.j;
				if ((6 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(24 + cast arr.byteOffset, value);
			};
			{
				var value = here.n;
				if ((7 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(28 + cast arr.byteOffset, value);
			};
			{
				var value = here.c;
				if ((8 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(32 + cast arr.byteOffset, value);
			};
			{
				var value = here.g;
				if ((9 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(36 + cast arr.byteOffset, value);
			};
			{
				var value = here.k;
				if ((10 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(40 + cast arr.byteOffset, value);
			};
			{
				var value = here.o;
				if ((11 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(44 + cast arr.byteOffset, value);
			};
			{
				var value = here.d;
				if ((12 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(48 + cast arr.byteOffset, value);
			};
			{
				var value = here.h;
				if ((13 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(52 + cast arr.byteOffset, value);
			};
			{
				var value = here.l;
				if ((14 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(56 + cast arr.byteOffset, value);
			};
			{
				var value = here.p;
				if ((15 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(60 + cast arr.byteOffset, value);
			};
		};
		return arr;
	}

	@:impl
	public static inline function updateWebGL_(this:geom.structure.Mat4x4, arr:haxe.io.Float32Array) {
		var here = this;
		{
			{
				var value = here.a;
				if ((0 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(cast arr.byteOffset, value);
			};
			{
				var value = here.b;
				if ((1 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(4 + cast arr.byteOffset, value);
			};
			{
				var value = here.c;
				if ((2 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(8 + cast arr.byteOffset, value);
			};
			{
				var value = here.d;
				if ((3 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(12 + cast arr.byteOffset, value);
			};
			{
				var value = here.e;
				if ((4 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(16 + cast arr.byteOffset, value);
			};
			{
				var value = here.f;
				if ((5 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(20 + cast arr.byteOffset, value);
			};
			{
				var value = here.g;
				if ((6 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(24 + cast arr.byteOffset, value);
			};
			{
				var value = here.h;
				if ((7 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(28 + cast arr.byteOffset, value);
			};
			{
				var value = here.i;
				if ((8 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(32 + cast arr.byteOffset, value);
			};
			{
				var value = here.j;
				if ((9 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(36 + cast arr.byteOffset, value);
			};
			{
				var value = here.k;
				if ((10 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(40 + cast arr.byteOffset, value);
			};
			{
				var value = here.l;
				if ((11 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(44 + cast arr.byteOffset, value);
			};
			{
				var value = here.m;
				if ((12 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(48 + cast arr.byteOffset, value);
			};
			{
				var value = here.n;
				if ((13 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(52 + cast arr.byteOffset, value);
			};
			{
				var value = here.o;
				if ((14 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(56 + cast arr.byteOffset, value);
			};
			{
				var value = here.p;
				if ((15 < cast arr.byteLength >> 2)) cast arr.bytes.setFloat(60 + cast arr.byteOffset, value);
			};
		};
		return arr;
	}

	@:impl
	public static inline function setXY(this:geom.structure.Mat4x4, x:Int, y:Int, v:Float) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this.a = v;
				case 1: return this.b = v;
				case 2: return this.c = v;
				case 3: return this.d = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix4x4")
			};
			case 1: switch ((y)) {
				case 0: return this.e = v;
				case 1: return this.f = v;
				case 2: return this.g = v;
				case 3: return this.h = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix4x4")
			};
			case 2: switch ((y)) {
				case 0: return this.i = v;
				case 1: return this.j = v;
				case 2: return this.k = v;
				case 3: return this.l = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix4x4")
			};
			case 3: switch ((y)) {
				case 0: return this.m = v;
				case 1: return this.n = v;
				case 2: return this.o = v;
				case 3: return this.p = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix4x4")
			};
			default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix4x4")
		};
	}

	@:impl
	public static inline function getXY(this:geom.structure.Mat4x4, x:Int, y:Int) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this.a;
				case 1: return this.b;
				case 2: return this.c;
				case 3: return this.d;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix4x4")
			};
			case 1: switch ((y)) {
				case 0: return this.e;
				case 1: return this.f;
				case 2: return this.g;
				case 3: return this.h;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix4x4")
			};
			case 2: switch ((y)) {
				case 0: return this.i;
				case 1: return this.j;
				case 2: return this.k;
				case 3: return this.l;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix4x4")
			};
			case 3: switch ((y)) {
				case 0: return this.m;
				case 1: return this.n;
				case 2: return this.o;
				case 3: return this.p;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix4x4")
			};
			default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix4x4")
		};
	}

	@:impl
	public static inline function pretty(this:geom.structure.Mat4x4, prec:Int) {
		var dp = geom.constraints.Precision.floatToStringPrecision;
		var max4 = geom.constraints.Precision.max4;
		var sa = dp(this.a, prec);
		var sb = dp(this.b, prec);
		var sc = dp(this.c, prec);
		var sd = dp(this.d, prec);
		var se = dp(this.e, prec);
		var sf = dp(this.f, prec);
		var sg = dp(this.g, prec);
		var sh = dp(this.h, prec);
		var si = dp(this.i, prec);
		var sj = dp(this.j, prec);
		var sk = dp(this.k, prec);
		var sl = dp(this.l, prec);
		var sm = dp(this.m, prec);
		var sn = dp(this.n, prec);
		var so = dp(this.o, prec);
		var sp = dp(this.p, prec);
		var la = sa.length;
		var lb = sb.length;
		var lc = sc.length;
		var ld = sd.length;
		var le = se.length;
		var lf = sf.length;
		var lg = sg.length;
		var lh = sh.length;
		var li = si.length;
		var lj = sj.length;
		var lk = sk.length;
		var ll = sl.length;
		var lm = sm.length;
		var ln = sn.length;
		var lo = so.length;
		var lp = sp.length;
		var r0 = max4(la, le, li, lm);
		var r1 = max4(lb, lf, lj, ln);
		var r2 = max4(lc, lg, lk, lo);
		var r3 = max4(ld, lh, ll, lp);
		var spaces = "";
		{
			var ` = 0;
			var `1 = r0;
			while ((` < `1)) {
				var n = ` ++;
				spaces += " ";
			};
		};
		sa = spaces.substr(0, r0 - la) + sa;
		se = spaces.substr(0, r0 - le) + se;
		si = spaces.substr(0, r0 - li) + si;
		sm = spaces.substr(0, r0 - lm) + sm;
		var spaces = "";
		{
			var `2 = 0;
			var `3 = r1;
			while ((`2 < `3)) {
				var n = `2 ++;
				spaces += " ";
			};
		};
		sb = spaces.substr(0, r1 - lb) + sb;
		sf = spaces.substr(0, r1 - lf) + sf;
		sj = spaces.substr(0, r1 - lj) + sj;
		sn = spaces.substr(0, r1 - ln) + sn;
		var space = "";
		{
			var `4 = 0;
			var `5 = r2;
			while ((`4 < `5)) {
				var n = `4 ++;
				spaces += " ";
			};
		};
		sc = spaces.substr(0, r2 - lc) + sc;
		sg = spaces.substr(0, r2 - lg) + sg;
		sk = spaces.substr(0, r2 - lk) + sk;
		so = spaces.substr(0, r2 - lo) + so;
		var space = "";
		{
			var `6 = 0;
			var `7 = r3;
			while ((`6 < `7)) {
				var n = `6 ++;
				spaces += " ";
			};
		};
		sd = spaces.substr(0, r3 - ld) + sd;
		sh = spaces.substr(0, r3 - lh) + sh;
		sl = spaces.substr(0, r3 - ll) + sl;
		sp = spaces.substr(0, r3 - lp) + sp;
		return "\n" + "/ " + sa + ", " + sb + ", " + sc + ", " + sd + " \\\n" + "| " + se + ", " + sf + ", " + sg + ", " + sh + " |\n" + "| " + si + ", " + sj + ", " + sk + ", " + sl + " |\n" + "\\ " + sm + ", " + sn + ", " + so + ", " + sp + " /\n";
	}
}