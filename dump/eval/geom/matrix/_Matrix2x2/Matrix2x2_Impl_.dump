@:used
private class geom.matrix._Matrix2x2.Matrix2x2_Impl_ {

	@:value(2)
	public static inline var row:Int = 2;

	@:value(2)
	public static inline var col:Int = 2;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat2x2) {
		var this = m;
		return cast this;
	}

	@:impl
	public static inline function clone(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat2x2(this.a, this.b, this.c, this.d);
		return cast this;
	}

	@:impl
	public static inline function iterator(this:geom.structure.Mat2x2) {
		return new haxe.iterators.ArrayIterator([this.a, this.b, this.c, this.d]);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix2x2;

	@:impl
	static inline function get_self(this:geom.structure.Mat2x2) {
		return cast this;
	}

	public static var zero(get,never):geom.matrix.Matrix2x2;

	static inline function get_zero() {
		var this = new geom.structure.Mat2x2(0., 0., 0., 0.);
		return cast this;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix2x2;

	@:impl
	static inline function get_nought(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat2x2(0., 0., 0., 0.);
		return cast this;
	}

	public static var unit(get,never):geom.matrix.Matrix2x2;

	static inline function get_unit() {
		var this = new geom.structure.Mat2x2(1., 0., 0., 1.);
		return cast this;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix2x2;

	@:impl
	static inline function get_one(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat2x2(1., 0., 0., 1.);
		return cast this;
	}

	public static var minus1(get,never):geom.matrix.Matrix2x2;

	static inline function get_minus1() {
		var this = new geom.structure.Mat2x2(1., 0., 0., 1.);
		var a = cast this;
		var this = new geom.structure.Mat2x2(- cast a.a, - cast a.b, - cast a.c, - cast a.d);
		return cast this;
	}

	public static var counting(get,never):geom.matrix.Matrix2x2;

	static inline function get_counting() {
		var this = new geom.structure.Mat2x2(1., 2., 3., 4.);
		return cast this;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix2x2;

	@:impl
	static inline function get_testCount(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat2x2(1., 2., 3., 4.);
		return cast this;
	}

	public static var _1234(get,never):geom.matrix.Matrix2x2;

	static inline function get__1234() {
		var this = new geom.structure.Mat2x2(1., 2., 3., 4.);
		return cast this;
	}

	public static var topLeft(get,never):geom.matrix.Matrix2x2;

	static inline function get_topLeft() {
		var this = new geom.structure.Mat2x2(1., 0., 0., -1.);
		return cast this;
	}

	public static var topRight(get,never):geom.matrix.Matrix2x2;

	static inline function get_topRight() {
		var this = new geom.structure.Mat2x2(1., 0., 0., 1.);
		return cast this;
	}

	public static var bottomLeft(get,never):geom.matrix.Matrix2x2;

	static inline function get_bottomLeft() {
		var this = new geom.structure.Mat2x2(-1., 0., 0., -1.);
		return cast this;
	}

	public static var bottomRight(get,never):geom.matrix.Matrix2x2;

	static inline function get_bottomRight() {
		var this = new geom.structure.Mat2x2(1., 0., 0., -1.);
		return cast this;
	}

	public static var north(get,never):geom.matrix.Matrix2x2;

	static inline function get_north() {
		var this = new geom.structure.Mat2x2(0., 0., 0., 1.);
		return cast this;
	}

	public static var south(get,never):geom.matrix.Matrix2x2;

	static inline function get_south() {
		var this = new geom.structure.Mat2x2(0., 0., 0., -1.);
		return cast this;
	}

	public static var west(get,never):geom.matrix.Matrix2x2;

	static inline function get_west() {
		var this = new geom.structure.Mat2x2(-1., 0., 0., 0.);
		return cast this;
	}

	public static var east(get,never):geom.matrix.Matrix2x2;

	static inline function get_east() {
		var this = new geom.structure.Mat2x2(1., 0., 0., 0.);
		return cast this;
	}

	@:impl
	public static inline function create(this:geom.structure.Mat2x2, a:Float, b:Float, c:Float, d:Float) {
		var this = new geom.structure.Mat2x2(a, b, c, d);
		this = cast this;
		return this;
	}

	public static inline function scale(p:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat2x2(p.x, 0., 0., p.y);
		return cast this;
	}

	public static inline function rotation(alpha:Float) {
		var this = new geom.structure.Mat2x2(Math.cos(alpha), - Math.sin(alpha), Math.sin(alpha), Math.cos(alpha));
		return cast this;
	}

	@:impl
	public static inline function transpose(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat2x2(this.a, this.c, this.b, this.d);
		return cast this;
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix2x2) {
		var this = new geom.structure.Mat2x2(- cast a.a, - cast a.b, - cast a.c, - cast a.d);
		return cast this;
	}

	@:impl
	public static inline function negate(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat2x2(- this.a, - this.b, - this.c, - this.d);
		return cast this;
	}

	@:op(A + B)
	public static inline function adding(a:geom.matrix.Matrix2x2, b:geom.matrix.Matrix2x2) {
		var this = new geom.structure.Mat2x2(cast a.a + b.a, cast a.b + b.b, cast a.c + b.c, cast a.d + b.d);
		return cast this;
	}

	@:impl
	public static inline function add(this:geom.structure.Mat2x2, b:geom.matrix.Matrix2x2) {
		var this = new geom.structure.Mat2x2(this.a + b.a, this.b + b.b, this.c + b.c, this.d + b.d);
		return cast this;
	}

	@:op(A == B)
	public static inline function equal(a:geom.matrix.Matrix2x2, b:geom.matrix.Matrix2x2) {
		var delta = 0.0000001;
		return ! (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta);
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix2x2, b:geom.matrix.Matrix2x2) {
		var delta = 0.0000001;
		return (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta);
	}

	@:op(A - B)
	public static inline function subtracting(a:geom.matrix.Matrix2x2, b:geom.matrix.Matrix2x2) {
		var this = new geom.structure.Mat2x2(cast a.a - b.a, cast a.b - b.b, cast a.c - b.c, cast a.d - b.d);
		return cast this;
	}

	@:impl
	public static inline function subtract(this:geom.structure.Mat2x2, b:geom.matrix.Matrix2x2) {
		var this = new geom.structure.Mat2x2(this.a - b.a, this.b - b.b, this.c - b.c, this.d - b.d);
		return cast this;
	}

	@:op(A * B)
	public static inline function multiplyValue(v:Float, m:geom.matrix.Matrix2x2) {
		var this = new geom.structure.Mat2x2(m.a * v, m.b * v, m.c * v, m.d * v);
		return cast this;
	}

	@:impl
	public static inline function scaleByVector2(this:geom.structure.Mat2x2, p:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat2x2(this.a * p.x, this.b, this.c, this.d * p.y);
		return cast this;
	}

	@:op(A * B)
	public static inline function multiply(a2:geom.matrix.Matrix2x2, b2:geom.matrix.Matrix2x2) {
		var this = new geom.structure.Mat2x2(a2.a * b2.a + a2.b * b2.c, a2.a * b2.b + a2.b * b2.d, a2.c * b2.a + a2.d * b2.c, a2.c * b2.b + a2.d * b2.d);
		return cast this;
	}

	@:impl
	public static inline function multiplyPoint(this:geom.structure.Mat2x2, p:geom.matrix.Matrix1x2) {
		var x = this.a * p.x + this.c * p.y;
		var y = this.b * p.x + this.d * p.y;
		var this = new geom.structure.Mat1x2(x, y);
		return cast this;
	}

	@:impl
	public static inline function det(this:geom.structure.Mat2x2) {
		return this.a * this.d - this.b * this.c;
	}

	@:impl
	public static inline function inverse(this:geom.structure.Mat2x2) {
		var d = cast this.a * cast this.d - cast this.b * cast this.c;
		if ((d == 0)) return null else {
			var this = new geom.structure.Mat2x2(this.d, - this.b, - this.c, this.a);
			var adj = cast this;
			var v = 1 / d;
			var this = new geom.structure.Mat2x2(adj.a * v, adj.b * v, adj.c * v, adj.d * v);
			return cast this;
		};
	}

	@:impl @:to
	public static inline function to3x3(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat3x3(this.a, this.b, 0., this.c, this.d, 0., 0., cast 0, 1.);
		return cast this;
	}

	@:impl @:to
	public static inline function to4x3(this:geom.structure.Mat2x2) {
		var this = new geom.structure.Mat4x3(this.a, this.b, 0., 0., this.c, this.d, 0., 0., 0., 0., 1., 0.);
		return cast this;
	}

	@:from
	public static inline function from3x3(m3:geom.matrix.Matrix3x3) {
		var this = new geom.structure.Mat2x2(m3.a, m3.b, m3.d, m3.e);
		return cast this;
	}

	@:from
	public static inline function from4x3(m4:geom.matrix.Matrix4x3) {
		var this = new geom.structure.Mat2x2(m4.a, m4.b, m4.e, m4.f);
		return cast this;
	}

	@:from
	public static inline function fromArr(arr:Array<Float>) {
		var this = new geom.structure.Mat2x2(arr[0], arr[1], arr[2], arr[3]);
		return cast this;
	}

	@:impl @:to
	public static inline function toArray(this:geom.structure.Mat2x2) {
		return [this.a, this.b, this.c, this.d];
	}

	@:from
	public static inline function fromVec(vec:haxe.ds.Vector<Float>) {
		var this = new geom.structure.Mat2x2(cast vec[0], cast vec[1], cast vec[2], cast vec[3]);
		return cast this;
	}

	@:impl @:to
	public static inline function toVector(this:geom.structure.Mat2x2) {
		var this = new eval.Vector(4);
		var vec = cast this;
		cast vec[0] = this.a;
		cast vec[1] = this.b;
		cast vec[2] = this.c;
		cast vec[3] = this.d;
		return vec;
	}

	@:impl
	public static inline function setXY(this:geom.structure.Mat2x2, x:Int, y:Int, v:Float) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: this.a = v;
				case 1: this.c = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix2x2")
			};
			case 1: switch ((y)) {
				case 0: this.b = v;
				case 1: this.d = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix2x2")
			};
			default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix2x2")
		};
		return this;
	}

	@:impl
	public static inline function getXY(this:geom.structure.Mat2x2, x:Int, y:Int) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this.a;
				case 1: return this.c;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix2x2")
			};
			case 1: switch ((y)) {
				case 0: return this.b;
				case 1: return this.d;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix2x2")
			};
			default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix2x2")
		};
	}
}