@:used
private class geom.matrix._Quaternion.Quaternion_Impl_ {

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat1x4) {
		var this = m;
		return cast this;
	}

	public static var zero(get,never):geom.matrix.Quaternion;

	static inline function get_zero() {
		var this = new geom.structure.Mat1x4(0., 0., 0., 0.);
		return cast this;
	}

	public static var zeroNormal(get,never):geom.matrix.Quaternion;

	static inline function get_zeroNormal() {
		var this = new geom.structure.Mat1x4(0., 0., 0., 1.);
		return cast this;
	}

	public static var unit(get,never):geom.matrix.Quaternion;

	static inline function get_unit() {
		var this = new geom.structure.Mat1x4(1., 1., 1., 1.);
		return cast this;
	}

	public static var unitNormal(get,never):geom.matrix.Quaternion;

	static inline function get_unitNormal() {
		var this = new geom.structure.Mat1x4(1., 1., 1., 1.);
		var this = cast this;
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				this.z *= mul;
				this.w *= mul;
				var tmp = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			};
		};
		return this;
	}

	@:impl
	public static inline function clone(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(this.x, this.y, this.z, this.w);
		return cast this;
	}

	public static inline function xRotate(angle:Float) {
		var this = new geom.structure.Mat1x4(Math.sin(0.5 * angle), 0., cast 0, Math.cos(0.5 * angle));
		return cast this;
	}

	public static inline function yRotate(angle:Float) {
		var this = new geom.structure.Mat1x4(0., Math.sin(0.5 * angle), 0., Math.cos(0.5 * angle));
		return cast this;
	}

	public static inline function zRotate(angle:Float) {
		var this = new geom.structure.Mat1x4(0., 0., Math.sin(0.5 * angle), Math.cos(0.5 * angle));
		return cast this;
	}

	public static inline function xPIhalf() {
		var halfSqrt = Math.sqrt(0.5);
		var this = new geom.structure.Mat1x4(halfSqrt, 0., cast 0, halfSqrt);
		return cast this;
	}

	public static inline function yPIhalf() {
		var halfSqrt = Math.sqrt(0.5);
		var this = new geom.structure.Mat1x4(0., halfSqrt, 0., halfSqrt);
		return cast this;
	}

	public static inline function zPIhalf() {
		var halfSqrt = Math.sqrt(0.5);
		var this = new geom.structure.Mat1x4(0., 0., halfSqrt, halfSqrt);
		return cast this;
	}

	public static inline function xPI() {
		var this = new geom.structure.Mat1x4(1., 0., cast 0, 0.);
		return cast this;
	}

	public static inline function yPI() {
		var this = new geom.structure.Mat1x4(0., 1., 0., 0.);
		return cast this;
	}

	public static inline function zPI() {
		var this = new geom.structure.Mat1x4(0., 0., 1., 0.);
		return cast this;
	}

	public static inline function xPIhalfMinus() {
		var halfSqrt = Math.sqrt(0.5);
		var this = new geom.structure.Mat1x4(- halfSqrt, 0., cast 0, halfSqrt);
		return cast this;
	}

	public static inline function yPIhalfMinus() {
		var halfSqrt = Math.sqrt(0.5);
		var this = new geom.structure.Mat1x4(0., - halfSqrt, 0., halfSqrt);
		return cast this;
	}

	public static inline function zPIhalfMinus() {
		var halfSqrt = Math.sqrt(0.5);
		var this = new geom.structure.Mat1x4(0., 0., - halfSqrt, halfSqrt);
		return cast this;
	}

	public static inline function createFromAxisAngle(x:Float, y:Float, z:Float, theta:Float) {
		var factor = Math.sin(theta / 2.0);
		x *= factor;
		y *= factor;
		z *= factor;
		var w = Math.cos(theta / 2.0);
		var this = new geom.structure.Mat1x4(x, y, z, w);
		var this = cast this;
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				this.z *= mul;
				this.w *= mul;
				var tmp = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			};
		};
		return this;
	}

	@:impl
	public static inline function getAngleAxis(this:geom.structure.Mat1x4) {
		var sqrt = Math.sqrt(1 - this.w * this.w);
		var this = new geom.structure.Mat1x3(this.x / sqrt, this.y / sqrt, this.z / sqrt);
		return {axis : cast this, angle : 2 * Math.acos(this.w)};
	}

	public static inline function identity(out:geom.matrix.Quaternion) {
		out.x = 0.;
		out.y = 0.;
		out.z = 0.;
		out.w = 1.;
		return out;
	}

	@:impl @:to
	public static inline function toMatrix4x1(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(this.x, this.y, this.z, this.w);
		return cast this;
	}

	public static inline function copy(pin:geom.matrix.Quaternion, pout:geom.matrix.Quaternion) {
		pout.x = pin.x;
		pout.y = pin.y;
		pout.z = pin.z;
		pout.w = pin.w;
		return pout;
	}

	@:impl
	public static var magnitude(get,set):Float;

	@:impl
	static inline function get_magnitude(this:geom.structure.Mat1x4) {
		return Math.sqrt(cast this.x * cast this.x + cast this.y * cast this.y + cast this.z * cast this.z + cast this.w * cast this.w);
	}

	@:impl
	static inline function set_magnitude(this:geom.structure.Mat1x4, length:Float) {
		var currentLength = Math.sqrt(cast this.x * cast this.x + cast this.y * cast this.y + cast this.z * cast this.z + cast this.w * cast this.w);
		if ((currentLength == 0.)) return 0. else {
			var mul = length / currentLength;
			this.x *= mul;
			this.y *= mul;
			this.z *= mul;
			this.w *= mul;
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		};
	}

	@:impl
	public static inline function dot(this:geom.structure.Mat1x4) {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}

	@:impl
	public static inline function dotProd(this:geom.structure.Mat1x4, b:geom.matrix.Quaternion) {
		return this.x * b.x + this.y * b.y + this.z * b.z + this.w * b.w;
	}

	public static inline function dotProduct(a:geom.matrix.Quaternion, b:geom.matrix.Quaternion) {
		return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
	}

	@:op(A == B)
	public static inline function equal(a:geom.matrix.Quaternion, b:geom.matrix.Quaternion) {
		var delta = 0.0000001;
		return ! (Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta || Math.abs(a.z - b.z) >= delta || Math.abs(a.w - b.w) >= delta);
	}

	@:impl
	public static inline function distanceZeroOne(this:geom.structure.Mat1x4, q:geom.matrix.Quaternion) {
		var dot_ = cast this.x * q.x + cast this.y * q.y + cast this.z * q.z + cast this.w * q.w;
		return 1 - dot_ * dot_;
	}

	@:impl
	public static inline function theta(this:geom.structure.Mat1x4, q:geom.matrix.Quaternion) {
		var d = cast this.x * q.x + cast this.y * q.y + cast this.z * q.z + cast this.w * q.w;
		return Math.acos(2 * d * d - 1);
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Quaternion, b:geom.matrix.Quaternion) {
		var delta = 0.0000001;
		return (Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta || Math.abs(a.z - b.z) >= delta || Math.abs(a.w - b.w) >= delta);
	}

	@:impl
	public static inline function magnitudeSquared(this:geom.structure.Mat1x4) {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}

	@:op(A + B)
	public static inline function add(a:geom.matrix.Quaternion, b:geom.matrix.Quaternion) {
		var this = new geom.structure.Mat1x4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		return cast this;
	}

	@:op(A - B)
	public static inline function subtract(a:geom.matrix.Quaternion, b:geom.matrix.Quaternion) {
		var this = new geom.structure.Mat1x4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
		return cast this;
	}

	@:op(A * B) @:commutative
	public static inline function scaleMultiply(a:geom.matrix.Quaternion, v:Float) {
		var this = new geom.structure.Mat1x4(a.x * v, a.y * v, a.z * v, a.w * v);
		return cast this;
	}

	@:op(A / B)
	public static inline function divide(a:geom.matrix.Quaternion, v:Float) {
		var v = 1 / v;
		var this = new geom.structure.Mat1x4(a.x * v, a.y * v, a.z * v, a.w * v);
		return cast this;
	}

	@:op(A / B)
	public static inline function divide2(v:Float, a:geom.matrix.Quaternion) {
		var this = new geom.structure.Mat1x4(v / a.x, v / a.y, v / a.z, v / a.w);
		return cast this;
	}

	@:op(~A)
	public static inline function conjugate(a:geom.matrix.Quaternion) {
		var this = new geom.structure.Mat1x4(- a.x, - a.y, - a.z, a.w);
		return cast this;
	}

	@:op(-A)
	public static inline function negate(a:geom.matrix.Quaternion) {
		var this = new geom.structure.Mat1x4(- a.x, - a.y, - a.z, - a.w);
		return cast this;
	}

	@:impl
	public static inline function invert(this:geom.structure.Mat1x4) {
		var sqNorm = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		var this = new geom.structure.Mat1x4(this.x / - sqNorm, this.y / - sqNorm, this.z / - sqNorm, this.w / sqNorm);
		return cast this;
	}

	public static inline function inversion(q1:geom.matrix.Quaternion) {
		var sqNorm = cast q1.x * cast q1.x + cast q1.y * cast q1.y + cast q1.z * cast q1.z + cast q1.w * cast q1.w;
		var this = new geom.structure.Mat1x4(q1.x / - sqNorm, q1.y / - sqNorm, q1.z / - sqNorm, q1.w / sqNorm);
		return cast this;
	}

	@:op(A * B)
	public static inline function multiplyQ(q1:geom.matrix.Quaternion, q2:geom.matrix.Quaternion) {
		var this = new geom.structure.Mat1x4(q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x, - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y, q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z, - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);
		return cast this;
	}

	@:impl
	public static inline function cross(this:geom.structure.Mat1x4, v:geom.matrix.Quaternion) {
		var this = new geom.structure.Mat1x4(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x, this.w * v.w);
		return cast this;
	}

	public static inline function fromYawPitchRoll(yaw:Float, pitch:Float, roll:Float) {
		var n9 = roll * 0.5;
		var n6 = Math.sin(n9);
		var n5 = Math.cos(n9);
		var n8 = pitch * 0.5;
		var n4 = Math.sin(n8);
		var n3 = Math.cos(n8);
		var n7 = yaw * 0.5;
		var n2 = Math.sin(n7);
		var n1 = Math.cos(n7);
		var this = new geom.structure.Mat1x4(n1 * n4 * n5 + n2 * n3 * n6, n2 * n3 * n5 - n1 * n4 * n6, n1 * n3 * n6 - n2 * n4 * n5, n1 * n3 * n5 + n2 * n4 * n6);
		return cast this;
	}

	public static inline function fromAxisAngle(theta:Float, axis:geom.matrix.Quaternion) {
		var half = theta / 2.;
		var c = Math.cos(half);
		var s = Math.sin(half);
		var this = new geom.structure.Mat1x4(s * axis.x, s * axis.y, s * axis.z, c);
		return cast this;
	}

	public static inline function lerp(a:geom.matrix.Quaternion, b:geom.matrix.Quaternion, t:Float) {
		{
			var currentLength = Math.sqrt(cast a.x * cast a.x + cast a.y * cast a.y + cast a.z * cast a.z + cast a.w * cast a.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				cast a.x *= mul;
				cast a.y *= mul;
				cast a.z *= mul;
				cast a.w *= mul;
				var tmp = cast a.x * cast a.x + cast a.y * cast a.y + cast a.z * cast a.z + cast a.w * cast a.w;
			};
		};
		{
			var currentLength = Math.sqrt(cast b.x * cast b.x + cast b.y * cast b.y + cast b.z * cast b.z + cast b.w * cast b.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				cast b.x *= mul;
				cast b.y *= mul;
				cast b.z *= mul;
				cast b.w *= mul;
				var tmp = cast b.x * cast b.x + cast b.y * cast b.y + cast b.z * cast b.z + cast b.w * cast b.w;
			};
		};
		var v = 1.0 - t;
		var this = new geom.structure.Mat1x4(a.x * v, a.y * v, a.z * v, a.w * v);
		var a = cast this;
		var this = new geom.structure.Mat1x4(b.x * t, b.y * t, b.z * t, b.w * t);
		var b = cast this;
		var this = new geom.structure.Mat1x4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
		return cast this;
	}

	@:impl
	public static var euler(get,set):geom.matrix.Quaternion;

	@:impl
	static inline function set_euler(this:geom.structure.Mat1x4, a:geom.matrix.Quaternion) {
		var x5 = a.x * .5;
		var y5 = a.y * .5;
		var z5 = a.z * .5;
		var cx = Math.cos(x5);
		var sx = Math.sin(x5);
		var cy = Math.cos(y5);
		var sy = Math.sin(y5);
		var cz = Math.cos(z5);
		var sz = Math.sin(z5);
		this.w = cx * cy * cz + sx * sy * sz;
		this.x = sx * cy * cz - cx * sy * sz;
		this.y = cx * sy * cz + sx * cy * sz;
		this.z = cx * cy * sz - sx * sy * cz;
		return this;
	}

	@:impl
	static inline function get_euler(this:geom.structure.Mat1x4) {
		var this = new geom.structure.Mat1x4(Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y)), Math.asin(2 * (this.w * this.y - this.z * this.x)), Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z)), 1.);
		return cast this;
	}

	@:impl
	public static function slerp(this:geom.structure.Mat1x4, v1:geom.matrix.Quaternion, t:Float) {
		var this = new geom.structure.Mat1x4(cast this.x, cast this.y, cast this.z, cast this.w);
		var v0 = cast this;
		{
			var currentLength = Math.sqrt(cast v0.x * cast v0.x + cast v0.y * cast v0.y + cast v0.z * cast v0.z + cast v0.w * cast v0.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				cast v0.x *= mul;
				cast v0.y *= mul;
				cast v0.z *= mul;
				cast v0.w *= mul;
				var tmp = cast v0.x * cast v0.x + cast v0.y * cast v0.y + cast v0.z * cast v0.z + cast v0.w * cast v0.w;
			};
		};
		var dot = v0.x * v1.x + v0.y * v1.y + v0.z * v1.z + v0.w * v1.w;
		if ((dot < 0.0)) {
			var this = new geom.structure.Mat1x4(- v1.x, - v1.y, - v1.z, - v1.w);
			v1 = cast this;
			dot = - dot;
		};
		if ((dot > 0.9995)) {
			var ` = t;
			var this = new geom.structure.Mat1x4(v1.x - v0.x, v1.y - v0.y, v1.z - v0.z, v1.w - v0.w);
			var `1 = cast this;
			var this = new geom.structure.Mat1x4(`1.x * `, `1.y * `, `1.z * `, `1.w * `);
			var b = cast this;
			var this = new geom.structure.Mat1x4(v0.x + b.x, v0.y + b.y, v0.z + b.z, v0.w + b.w);
			var result = cast this;
			{
				var currentLength = Math.sqrt(cast result.x * cast result.x + cast result.y * cast result.y + cast result.z * cast result.z + cast result.w * cast result.w);
				if ((currentLength != 0.)) {
					var mul = 1. / currentLength;
					cast result.x *= mul;
					cast result.y *= mul;
					cast result.z *= mul;
					cast result.w *= mul;
					var tmp = cast result.x * cast result.x + cast result.y * cast result.y + cast result.z * cast result.z + cast result.w * cast result.w;
				};
			};
			return result;
		};
		var theta0 = Math.acos(dot);
		var theta = theta0 * t;
		var sinTheta = Math.sin(theta);
		var sinTheta0 = Math.sin(theta0);
		var ratioA = Math.cos(theta) - dot * sinTheta / sinTheta0;
		var ratioB = sinTheta / sinTheta0;
		var this = new geom.structure.Mat1x4(v0.x * ratioA + v1.x * ratioB, v0.y * ratioA + v1.y * ratioB, v0.z * ratioA + v1.z * ratioB, v0.x * ratioA + v1.x * ratioB);
		var q = cast this;
		{
			var currentLength = Math.sqrt(cast q.x * cast q.x + cast q.y * cast q.y + cast q.z * cast q.z + cast q.w * cast q.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				cast q.x *= mul;
				cast q.y *= mul;
				cast q.z *= mul;
				cast q.w *= mul;
				var tmp = cast q.x * cast q.x + cast q.y * cast q.y + cast q.z * cast q.z + cast q.w * cast q.w;
			};
		};
		return cast cast q;
	}

	public static inline function scalarReal(s:Float) {
		var this = new geom.structure.Mat1x4(cast 0, cast 0, cast 0, Math.sqrt(s));
		return cast this;
	}

	@:impl
	public static inline function scaled(this:geom.structure.Mat1x4, s:Float) {
		var this = new geom.structure.Mat1x4(this.x * s, this.y * s, this.z * s, this.w * s);
		return cast this;
	}

	@:impl
	public static inline function normalize(this:geom.structure.Mat1x4) {
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				this.z *= mul;
				this.w *= mul;
				var tmp = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			};
		};
		return this;
	}

	@:impl
	public static function lookAt(this:geom.structure.Mat1x4, target:geom.matrix.Matrix1x4, current:geom.matrix.Matrix1x4, eye:geom.matrix.Matrix1x4, up:geom.matrix.Matrix1x4) {
		var this = new geom.structure.Mat1x4(cast current.x - eye.x, cast current.y - eye.y, cast current.z - eye.z, cast current.w - eye.w);
		var this = cast this;
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				this.z *= mul;
				this.w *= mul;
				var tmp = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			};
		};
		var n1 = this;
		var this = new geom.structure.Mat1x4(cast target.x - eye.x, cast target.y - eye.y, cast target.z - eye.z, cast target.w - eye.w);
		var this = cast this;
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				this.z *= mul;
				this.w *= mul;
				var tmp = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			};
		};
		var n2 = this;
		var d = cast n1.x * n2.x + cast n1.y * n2.y + cast n1.z * n2.z + cast n1.w * n2.w;
		if ((d > 0.9998)) {
			var this = new geom.structure.Mat1x4(0., 0., 1., 0.);
			return cast this;
		};
		if ((d < -0.9998)) {
			var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0.);
			var this = cast this;
			var c = Math.cos(0.5);
			var s = Math.sin(0.5);
			var this = new geom.structure.Mat4x3(1., 0., 0., 0., 0., c, - s, 0., 0., s, c, 0.);
			var s = cast this;
			var this = new geom.structure.Mat4x3(this.a * s.a + this.b * s.e + this.c * s.i, this.a * s.b + this.b * s.f + this.c * s.j, this.a * s.c + this.b * s.g + this.c * s.k, this.a * s.d + this.b * s.h + this.c * s.l + this.d, this.e * s.a + this.f * s.e + this.g * s.i, this.e * s.b + this.f * s.f + this.g * s.j, this.e * s.c + this.f * s.g + this.g * s.k, this.e * s.d + this.f * s.h + this.g * s.l + this.h, this.i * s.a + this.j * s.e + this.k * s.i, this.i * s.b + this.j * s.f + this.k * s.j, this.i * s.c + this.j * s.g + this.k * s.k, this.i * s.d + this.j * s.h + this.k * s.l + this.l);
			var t = cast this;
			var this = new geom.structure.Mat1x4(t.a * cast n1.x + t.b * cast n1.y + t.c * cast n1.z + t.d, t.e * cast n1.x + t.f * cast n1.y + t.g * cast n1.z + t.h, t.i * cast n1.x + t.j * cast n1.y + t.k * cast n1.z + t.l, 1.);
			n1 = cast this;
		};
		var axis = n1;
		var this = new geom.structure.Mat1x4(cast axis.y * n2.z - cast axis.z * n2.y, cast axis.z * n2.x - cast axis.x * n2.z, cast axis.x * n2.y - cast axis.y * n2.x, cast axis.w * n2.w);
		var pointToTarget = new geom.structure.Mat1x4(axis.x, axis.y, axis.z, 1.0 + d);
		{
			var currentLength = Math.sqrt(cast pointToTarget.x * cast pointToTarget.x + cast pointToTarget.y * cast pointToTarget.y + cast pointToTarget.z * cast pointToTarget.z + cast pointToTarget.w * cast pointToTarget.w);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				cast pointToTarget.x *= mul;
				cast pointToTarget.y *= mul;
				cast pointToTarget.z *= mul;
				cast pointToTarget.w *= mul;
				var tmp = cast pointToTarget.x * cast pointToTarget.x + cast pointToTarget.y * cast pointToTarget.y + cast pointToTarget.z * cast pointToTarget.z + cast pointToTarget.w * cast pointToTarget.w;
			};
		};
		var a = pointToTarget.x;
		var b = pointToTarget.y;
		var c = pointToTarget.z;
		var this = new geom.structure.Mat4x3(b * b + c * c, - a * b, - b * a, cast 0, - b * a, a * a + c * c, - b * c, cast 0, - c * a, - c * b, a * a + b * b, cast 0);
		var projectionMatrix = cast this;
		var this = new geom.structure.Mat1x4(projectionMatrix.a * cast up.x + projectionMatrix.b * cast up.y + projectionMatrix.c * cast up.z + projectionMatrix.d, projectionMatrix.e * cast up.x + projectionMatrix.f * cast up.y + projectionMatrix.g * cast up.z + projectionMatrix.h, projectionMatrix.i * cast up.x + projectionMatrix.j * cast up.y + projectionMatrix.k * cast up.z + projectionMatrix.l, 1.);
		var upProjected = cast this;
		var y = new geom.structure.Mat1x4(0., 0., 0., 1.);
		var this = new geom.structure.Mat1x4(projectionMatrix.a * cast y.x + projectionMatrix.b * cast y.y + projectionMatrix.c * cast y.z + projectionMatrix.d, projectionMatrix.e * cast y.x + projectionMatrix.f * cast y.y + projectionMatrix.g * cast y.z + projectionMatrix.h, projectionMatrix.i * cast y.x + projectionMatrix.j * cast y.y + projectionMatrix.k * cast y.z + projectionMatrix.l, 1.);
		var yaxisProjected = cast this;
		d = cast upProjected.x * yaxisProjected.x + cast upProjected.y * yaxisProjected.y + cast upProjected.z * yaxisProjected.z + cast upProjected.w * yaxisProjected.w;
		var s = Math.sqrt(1.0 - d * d);
		var twist = new geom.structure.Mat1x4(n2.x * s, n2.y * s, n2.z * s, d);
		var this = new geom.structure.Mat1x4(pointToTarget.x * twist.w + pointToTarget.y * twist.z - pointToTarget.z * twist.y + pointToTarget.w * twist.x, - pointToTarget.x * twist.z + pointToTarget.y * twist.w + pointToTarget.z * twist.x + pointToTarget.w * twist.y, pointToTarget.x * twist.y - pointToTarget.y * twist.x + pointToTarget.z * twist.w + pointToTarget.w * twist.z, - pointToTarget.x * twist.x - pointToTarget.y * twist.y - pointToTarget.z * twist.z + pointToTarget.w * twist.w);
		return cast this;
	}

	@:from
	public static inline function fromVec(vec:haxe.ds.Vector<Float>) {
		var this = new geom.structure.Mat1x4(cast vec[0], cast vec[1], cast vec[2], cast vec[3]);
		return cast this;
	}

	@:impl @:to
	public static inline function toVector(this:geom.structure.Mat1x4) {
		var this = new eval.Vector(4);
		var vec = cast this;
		cast vec[0] = this.x;
		cast vec[1] = this.y;
		cast vec[2] = this.z;
		cast vec[3] = this.w;
		return vec;
	}

	@:from
	public static inline function fromArray(arr:Array<Float>) {
		var this = new geom.structure.Mat1x4(arr[0], arr[1], arr[2], arr[3]);
		return cast this;
	}

	@:impl @:to
	public static inline function toArray(this:geom.structure.Mat1x4) {
		return [this.x, this.y, this.z, this.w];
	}

	@:impl @:to
	public static inline function toMatrix4x3(this:geom.structure.Mat1x4) {
		var this = this;
		var this = cast this;
		var xx = this.x * this.x;
		var xy = this.x * this.y;
		var xz = this.x * this.z;
		var xw = this.x * this.w;
		var yy = this.y * this.y;
		var yz = this.y * this.z;
		var yw = this.y * this.w;
		var zz = this.z * this.z;
		var zw = this.z * this.w;
		var this = new geom.structure.Mat3x3(1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw), 2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw), 2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy));
		var m = cast this;
		var this = new geom.structure.Mat2x2(cast m.a, cast m.b, cast m.d, cast m.e);
		var this = cast this;
		var this = new geom.structure.Mat4x3(this.a, this.b, 0., 0., this.c, this.d, 0., 0., 0., 0., 1., 0.);
		return cast this;
	}

	@:impl @:to
	public static inline function toMatrix3x3(this:geom.structure.Mat1x4) {
		var xx = this.x * this.x;
		var xy = this.x * this.y;
		var xz = this.x * this.z;
		var xw = this.x * this.w;
		var yy = this.y * this.y;
		var yz = this.y * this.z;
		var yw = this.y * this.w;
		var zz = this.z * this.z;
		var zw = this.z * this.w;
		var this = new geom.structure.Mat3x3(1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw), 2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw), 2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy));
		return cast this;
	}

	@:from
	public static inline function fromMatrix4x3(m4x3:geom.matrix.Matrix4x3) {
		var this = new geom.structure.Mat3x3(cast m4x3.a, cast m4x3.b, cast m4x3.c, cast m4x3.e, cast m4x3.f, cast m4x3.g, cast m4x3.i, cast m4x3.j, cast m4x3.k);
		var m3x3 = cast this;
		var this = new geom.structure.Mat3x3(0., 0., 0., 0., 0., 0., 0., 0., 0.);
		var tr = m3x3.a + m3x3.e + m3x3.i;
		var s;
		if ((tr > 0)) {
			s = Math.sqrt(tr + 1.0) * 2;
			var this = new geom.structure.Mat1x4((m3x3.h - m3x3.f) / s, (m3x3.c - m3x3.g) / s, (m3x3.d - m3x3.b) / s, 0.25 * s);
			return cast this;
		} else if ((m3x3.a > m3x3.e && m3x3.a > m3x3.i)) {
			s = Math.sqrt(1.0 + m3x3.a - m3x3.e - m3x3.i) * 2;
			var this = new geom.structure.Mat1x4(0.25 * s, (m3x3.b + m3x3.d) / s, (m3x3.c + m3x3.g) / s, (m3x3.h - m3x3.f) / s);
			return cast this;
		} else if ((m3x3.e > m3x3.i)) {
			s = Math.sqrt(1.0 + m3x3.e - m3x3.a - m3x3.i) * 2;
			var this = new geom.structure.Mat1x4((m3x3.b + m3x3.d) / s, 0.25 * s, (m3x3.f + m3x3.h) / s, (m3x3.c - m3x3.g) / s);
			return cast this;
		} else {
			s = Math.sqrt(1.0 + m3x3.i - m3x3.i - m3x3.e) * 2;
			var this = new geom.structure.Mat1x4((m3x3.d - m3x3.b) / s, (m3x3.c + m3x3.g) / s, (m3x3.f + m3x3.h) / s, 0.25 * s);
			return cast this;
		};
	}

	@:from
	public static inline function fromMatrix3x3(m:geom.matrix.Matrix3x3) {
		var this = new geom.structure.Mat3x3(0., 0., 0., 0., 0., 0., 0., 0., 0.);
		var tr = m.a + m.e + m.i;
		var s;
		if ((tr > 0)) {
			s = Math.sqrt(tr + 1.0) * 2;
			var this = new geom.structure.Mat1x4((m.h - m.f) / s, (m.c - m.g) / s, (m.d - m.b) / s, 0.25 * s);
			return cast this;
		} else if ((m.a > m.e && m.a > m.i)) {
			s = Math.sqrt(1.0 + m.a - m.e - m.i) * 2;
			var this = new geom.structure.Mat1x4(0.25 * s, (m.b + m.d) / s, (m.c + m.g) / s, (m.h - m.f) / s);
			return cast this;
		} else if ((m.e > m.i)) {
			s = Math.sqrt(1.0 + m.e - m.a - m.i) * 2;
			var this = new geom.structure.Mat1x4((m.b + m.d) / s, 0.25 * s, (m.f + m.h) / s, (m.c - m.g) / s);
			return cast this;
		} else {
			s = Math.sqrt(1.0 + m.i - m.i - m.e) * 2;
			var this = new geom.structure.Mat1x4((m.d - m.b) / s, (m.c + m.g) / s, (m.f + m.h) / s, 0.25 * s);
			return cast this;
		};
	}
}