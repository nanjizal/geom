@:used
private class geom.matrix._Matrix1x2.Matrix1x2_Impl_ {

	@:value(1)
	public static inline var rows:Int = 1;

	@:value(2)
	public static inline var columns:Int = 2;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat1x2) {
		var this = m;
		return cast this;
	}

	@:impl
	public static inline function clone(this:geom.structure.Mat1x2) {
		var this = new geom.structure.Mat1x2(this.x, this.y);
		return cast this;
	}

	@:impl
	public static inline function iterator(this:geom.structure.Mat1x2) {
		return new haxe.iterators.ArrayIterator([this.x, this.y]);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix1x2;

	@:impl
	static inline function get_self(this:geom.structure.Mat1x2) {
		return cast this;
	}

	@:impl
	public static var magnitude(get,set):Float;

	@:impl
	static inline function get_magnitude(this:geom.structure.Mat1x2) {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}

	@:impl
	static inline function set_magnitude(this:geom.structure.Mat1x2, length:Float) {
		var currentLength = Math.sqrt(cast this.x * cast this.x + cast this.y * cast this.y);
		if ((currentLength == 0)) return 0 else {
			var mul = length / currentLength;
			this.x *= mul;
			this.y *= mul;
			return Math.sqrt(this.x * this.x + this.y * this.y);
		};
	}

	@:impl
	public static inline function normalize(this:geom.structure.Mat1x2) {
		{
			var currentLength = Math.sqrt(this.x * this.x + this.y * this.y);
			if ((currentLength != 0)) {
				var mul = 1. / currentLength;
				this.x *= mul;
				this.y *= mul;
				var tmp = this.x * this.x + this.y * this.y;
			};
		};
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}

	public static var zero(get,never):geom.matrix.Matrix1x2;

	static inline function get_zero() {
		var this = new geom.structure.Mat1x2(0., 0.);
		return cast this;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix1x2;

	@:impl
	static inline function get_nought(this:geom.structure.Mat1x2) {
		var this = new geom.structure.Mat1x2(0., 0.);
		return cast this;
	}

	public static var unit(get,never):geom.matrix.Matrix1x2;

	static inline function get_unit() {
		var this = new geom.structure.Mat1x2(1., 1.);
		return cast this;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix1x2;

	@:impl
	static inline function get_one(this:geom.structure.Mat1x2) {
		var this = new geom.structure.Mat1x2(1., 1.);
		return cast this;
	}

	public static var minus1(get,never):geom.matrix.Matrix1x2;

	static inline function get_minus1() {
		var this = new geom.structure.Mat1x2(1., 1.);
		var a = cast this;
		var this = new geom.structure.Mat1x2(- cast a.x, - cast a.y);
		return cast this;
	}

	public static var counting(get,never):geom.matrix.Matrix1x2;

	static inline function get_counting() {
		var this = new geom.structure.Mat1x2(1., 2.);
		return cast this;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix1x2;

	@:impl
	static inline function get_testCount(this:geom.structure.Mat1x2) {
		var this = new geom.structure.Mat1x2(1., 2.);
		return cast this;
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(- cast a.x, - cast a.y);
		return cast this;
	}

	@:impl
	public static inline function negate(this:geom.structure.Mat1x2) {
		var this = new geom.structure.Mat1x2(- this.x, - this.y);
		return cast this;
	}

	@:op(A + B)
	public static inline function adding(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(cast a.x + b.x, cast a.y + b.y);
		return cast this;
	}

	@:impl
	public static inline function add(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(this.x + b.x, this.y + b.y);
		return cast this;
	}

	@:op(A - B)
	public static inline function subtracting(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(cast a.x - b.x, cast a.y - b.y);
		return cast this;
	}

	@:impl
	public static inline function subtract(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(this.x - b.x, this.y - b.y);
		return cast this;
	}

	@:op(A == B)
	public static inline function isEqualling(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		if ((cast a.x == b.x)) return cast a.y == b.y else return false;
	}

	@:impl
	public static inline function isEqual(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		if ((this.x == b.x)) return this.y == b.y else return false;
	}

	@:op(A * B) @:commutative
	public static inline function scaleMultiplying(a:geom.matrix.Matrix1x2, v:Float) {
		var this = new geom.structure.Mat1x2(cast a.x * v, cast a.y * v);
		return cast this;
	}

	@:impl
	public static inline function scaleMultiply(this:geom.structure.Mat1x2, v:Float) {
		var this = new geom.structure.Mat1x2(this.x * v, this.y * v);
		return cast this;
	}

	@:impl
	public static inline function lerpClampT(this:geom.structure.Mat1x2, p:geom.matrix.Matrix1x2, t:Float) {
		var interval = new geom.structure.Range(1., 0.);
		var t = if ((t <= cast interval.l)) cast interval.l else if ((t >= cast interval.u)) cast interval.u else t;
		var this = cast cast this;
		var this = new geom.structure.Mat1x2(this.x - p.x, this.y - p.y);
		var s = cast this;
		var this = new geom.structure.Mat1x2(- cast s.x, - cast s.y);
		var n = cast this;
		var this = new geom.structure.Mat1x2(cast n.x * t, cast n.y * t);
		var tn = cast this;
		var this = new geom.structure.Mat1x2(cast s.x + tn.x, cast s.y + tn.y);
		return cast this;
	}

	@:impl
	public static inline function lerp(this:geom.structure.Mat1x2, p:geom.matrix.Matrix1x2, t:Float) {
		var this = cast this;
		var this = new geom.structure.Mat1x2(this.x - p.x, this.y - p.y);
		var s = cast this;
		var this = new geom.structure.Mat1x2(- cast s.x, - cast s.y);
		var n = cast this;
		var this = new geom.structure.Mat1x2(cast n.x * t, cast n.y * t);
		var tn = cast this;
		var this = new geom.structure.Mat1x2(cast s.x + tn.x, cast s.y + tn.y);
		return cast this;
	}

	@:impl
	public static inline function sumXY(this:geom.structure.Mat1x2) {
		return this.x + this.y;
	}

	public static inline function topLeft() {
		var this = new geom.structure.Mat1x2(-1., 1.);
		return cast this;
	}

	public static inline function topRight() {
		var this = new geom.structure.Mat1x2(1., 1.);
		return cast this;
	}

	public static inline function bottomLeft() {
		var this = new geom.structure.Mat1x2(-1., -1.);
		return cast this;
	}

	public static inline function bottomRight() {
		var this = new geom.structure.Mat1x2(1., -1.);
		return cast this;
	}

	public static inline function north() {
		var this = new geom.structure.Mat1x2(0., 1.);
		return cast this;
	}

	public static inline function south() {
		var this = new geom.structure.Mat1x2(0., -1.);
		return cast this;
	}

	public static inline function west() {
		var this = new geom.structure.Mat1x2(-1., 0.);
		return cast this;
	}

	public static inline function east() {
		var this = new geom.structure.Mat1x2(1., 0.);
		return cast this;
	}

	@:op(A * B)
	public static inline function dotting(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(cast a.x * b.x, cast a.y * b.y);
		return cast this;
	}

	@:impl
	public static inline function dot(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(this.x * b.x, this.y * b.y);
		return cast this;
	}

	@:op(A / B)
	public static inline function dividing(a:geom.matrix.Matrix1x2, v:Float) {
		var a = cast cast a;
		var v = 1 / v;
		var this = new geom.structure.Mat1x2(cast a.x * v, cast a.y * v);
		return cast this;
	}

	@:impl
	public static inline function divide(this:geom.structure.Mat1x2, v:Float) {
		var a = cast this;
		var v = 1 / v;
		var this = new geom.structure.Mat1x2(cast a.x * v, cast a.y * v);
		return cast this;
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		return ! (cast a.x == b.x && cast a.y == b.y);
	}

	@:impl
	public static inline function perp(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		return this.x * b.y - this.y * b.x;
	}

	public static inline function mid(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2((a.x + b.x) / 2, (a.y + b.y) / 2);
		return cast this;
	}

	@:impl
	public static inline function distanceBetweenSquare(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		var dx = this.x - b.x;
		var dy = this.y - b.y;
		return dx * dx + dy * dy;
	}

	@:impl
	public static inline function distanceBetweenSquare_(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(cast this.x - b.x, cast this.y - b.y);
		var c = cast this;
		return cast c.x * cast c.x + cast c.y * cast c.y;
	}

	@:impl
	public static inline function distanceBetween(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		var dx = cast this.x - b.x;
		var dy = cast this.y - b.y;
		return Math.pow(dx * dx + dy * dy, 0.5);
	}

	@:impl
	public static inline function span(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2) {
		var this = new geom.structure.Mat1x2(this.x - b.x, this.y - b.y);
		return cast this;
	}

	@:impl
	public static inline function lenSquare(this:geom.structure.Mat1x2) {
		return this.x * this.x + this.y * this.y;
	}

	@:impl
	public static inline function distance(this:geom.structure.Mat1x2) {
		return Math.pow(cast this.x * cast this.x + cast this.y * cast this.y, 0.5);
	}

	@:impl
	public static inline function isLeft(this:geom.structure.Mat1x2, a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		return (b.x - a.x) * (this.y - a.y) - (this.x - a.x) * (b.y - a.y);
	}

	public static inline function triangleArea(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2, c:geom.matrix.Matrix1x2) {
		return Math.abs(((c.x - b.x) * (cast a.y - b.y) - (cast a.x - b.x) * (c.y - b.y)) / 2.);
	}

	public static inline function sign(n:Float) {
		return Std.int(Math.abs(n) / n);
	}

	public static inline function thetaDifference(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		var dx = a.x - b.x;
		var dy = a.y - b.y;
		return Math.atan2(dy, dx);
	}

	@:impl
	public static inline function inTri(this:geom.structure.Mat1x2, a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2, c:geom.matrix.Matrix1x2) {
		var planeAB = (a.x - this.x) * (b.y - this.y) - (b.x - this.x) * (a.y - this.y);
		var planeBC = (b.x - this.x) * (c.y - this.y) - (c.x - this.x) * (b.y - this.y);
		var planeCA = (c.x - this.x) * (a.y - this.y) - (a.x - this.x) * (c.y - this.y);
		if ((Std.int(Math.abs(planeAB) / planeAB) == Std.int(Math.abs(planeBC) / planeBC))) return Std.int(Math.abs(planeBC) / planeBC) == Std.int(Math.abs(planeCA) / planeCA) else return false;
	}

	@:impl
	public static inline function inTri2(this:geom.structure.Mat1x2, a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2, c:geom.matrix.Matrix1x2) {
		var v0x = c.x - a.x;
		var v0y = c.y - a.y;
		var v1x = b.x - a.x;
		var v1y = b.y - a.y;
		var v2x = this.x - a.x;
		var v2y = this.y - a.y;
		var dot00 = v0x * v0x + v0y * v0y;
		var dot01 = v0x * v1x + v0y * v1y;
		var dot02 = v0x * v2x + v0y * v2y;
		var dot11 = v1x * v1x + v1y * v1y;
		var dot12 = v1x * v2x + v1y * v2y;
		var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
		var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
		var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
		if ((u >= 0 && v >= 0)) return u + v < 1 else return false;
	}

	@:impl
	public static inline function inRect(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2, c:geom.matrix.Matrix1x2) {
		var small = 0.0000000001;
		var minx = Math.min(b.x, c.x);
		var maxx = Math.max(b.x, c.x);
		var miny = Math.min(b.y, c.y);
		var maxy = Math.max(b.y, c.y);
		if ((minx == maxx)) {
			if ((miny <= this.y)) return this.y <= maxy else return false;
		} else if ((miny == maxy)) {
			if ((minx <= this.x)) return this.x <= maxx else return false;
		} else if ((minx <= this.x + small && this.x - small <= maxx && miny <= this.y + small)) return this.y - small <= maxy else return false;
	}

	public static inline function convex(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2, c:geom.matrix.Matrix1x2) {
		return (a.y - b.y) * (c.x - b.x) + (b.x - a.x) * (c.y - b.y) >= 0;
	}

	public static inline function cross(a:geom.matrix.Matrix1x2, b:geom.matrix.Matrix1x2) {
		return a.x * b.y - a.y * b.x;
	}

	@:impl
	public static inline function theta(this:geom.structure.Mat1x2) {
		return Math.atan2(this.y, this.x);
	}

	@:value({ delta : 0.00001 }) @:impl
	public static inline function close(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2, delta:Float = 0.00001) {
		var dx = cast this.x - b.x;
		if ((dx < 0.00001 || dx > -1e-05)) {
			var dy = cast this.y - b.y;
			if ((! (dy < 0.00001))) return dy > -1e-05 else return true;
		} else return false;
	}

	@:value({ delta : 0.00001 }) @:impl
	public static inline function xClose(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2, delta:Float = 0.00001) {
		var dx = this.x - b.x;
		if ((! (dx < delta))) return dx > - delta else return true;
	}

	@:value({ delta : 0.00001 }) @:impl
	public static inline function yClose(this:geom.structure.Mat1x2, b:geom.matrix.Matrix1x2, delta:Float = 0.00001) {
		var dy = this.y - b.y;
		if ((! (dy < delta))) return dy > - delta else return true;
	}

	@:impl
	public static inline function pivotAround(this:geom.structure.Mat1x2, omega:Float, pivot:geom.matrix.Matrix1x2) {
		var px = this.x - pivot.x;
		var py = this.y - pivot.y;
		var px2 = px * Math.cos(omega) - py * Math.sin(omega);
		py = py * Math.cos(omega) + px * Math.sin(omega);
		var this = new geom.structure.Mat1x2(px2 + pivot.x, py + pivot.y);
		return cast this;
	}

	@:impl @:to
	public static inline function toTpoint(this:geom.structure.Mat1x2) {
		return {x : this.x, y : this.y};
	}

	@:impl @:to
	public static inline function toVec3(this:geom.structure.Mat1x2) {
		var this = new eval.Vector(3);
		var vec = cast this;
		cast vec[0] = this.x;
		cast vec[1] = this.y;
		cast vec[2] = 1.;
		return vec;
	}

	@:from
	public static inline function fromVec3(v:haxe.ds.Vector<Float>) {
		var this = new geom.structure.Mat1x2(cast v[0], cast v[1]);
		return cast this;
	}

	public static inline function fromArrayPos(arr:Array<Float>, pos:Int) {
		var this = new geom.structure.Mat1x2(arr[pos], arr[pos + 1]);
		return cast this;
	}

	@:impl
	public static inline function toArrayPos(this:geom.structure.Mat1x2, arr:Array<Float>, pos:Int) {
		arr[pos] = this.x;
		arr[pos + 1] = this.y;
		return arr;
	}

	@:impl @:op([])
	public static inline function readItem(this:geom.structure.Mat1x2, k:Int) {
		switch ((k)) {
			case 0: return this.x;
			case 1: return this.y;
			default: throw haxe.Exception.thrown("use index less than 2")
		};
	}

	@:impl @:op([])
	public static inline function writeItem(this:geom.structure.Mat1x2, k:Int, v:Float) {
		switch ((k)) {
			case 0: this.x = v;
			case 1: this.y = v;
			default: throw haxe.Exception.thrown("use index less than 2")
		};
		return v;
	}
}