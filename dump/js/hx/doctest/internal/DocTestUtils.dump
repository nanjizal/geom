@:directlyUsed @:used @:noDoc @:dox(hide)
class hx.doctest.internal.DocTestUtils {

	public static function exceptionStackAsString() {
		var stack = haxe._CallStack.CallStack_Impl_.exceptionStack();
		var i = -1;
		{
			var _g = 0;
			@:loopLabel(1) while ((_g < stack.length)) {
				var elem = stack[_g];
				++ _g;
				++ i;
				switch ((enumIndex elem)) {
					case 2: {
						var _g1 = elem[3];
						{
							var line = elem[2];
							var file = elem[1];
							var elem2 = elem[0];
							{
								if ((StringTools.startsWith(file, "hx/doctest"))) {
									stack = stack.slice(0, i);
									@:loopLabel(1) break;
								};
								if ((elem2 != null)) {
									if ((elem2 != null)) {
										if ((enumIndex elem2 == 3)) {
											var method = elem2[1];
											var classname = elem2[0];
											if ((StringTools.startsWith(classname, "hx.doctest."))) {
												stack = stack.slice(0, i);
												@:loopLabel(1) break;
											};
										};
									};
								};
							};
						};
					};
					case 3: {
						var method1 = elem[1];
						var classname1 = elem[0];
						if ((StringTools.startsWith(classname1, "hx.doctest."))) {
							stack = stack.slice(0, i);
							@:loopLabel(1) break;
						};
					};
					default: {}
				};
			};
		};
		return "  " + haxe._CallStack.CallStack_Impl_.toString(stack).split("\n").join("\n  ") + "\n";
	}

	public static function deepEquals(left:Dynamic, right:Dynamic) {
		if ((left == right)) return true;
		if ((js.Syntax.instanceof(right, EReg))) return (cast (right,EReg)).match(Std.string(left));
		if ((js.Syntax.typeof(left) == "string")) return false;
		if ((js.Syntax.instanceof(left, Array) && js.Syntax.instanceof(right, Array))) {
			if ((left.length == right.length)) {
				{
					var _g = 0;
					var _g1 = cast left.length;
					while ((_g < _g1)) {
						var i = _g ++;
						if ((! hx.doctest.internal.DocTestUtils.deepEquals(left[i], right[i]))) return false;
					};
				};
				return true;
			};
			return false;
		};
		if ((Reflect.isEnumValue(left) && Reflect.isEnumValue(right))) {
			var leftEnum = left;
			var rightEnum = right;
			return Type.enumEq(leftEnum, rightEnum);
		};
		if ((Reflect.isObject(left) && Reflect.isObject(right))) {
			var clsLeft = Type.getClass(left);
			var clsLeftName = if ((clsLeft == null)) null else Type.getClassName(clsLeft);
			var clsRight = Type.getClass(right);
			var clsRightName = if ((clsRight == null)) null else Type.getClassName(clsRight);
			if ((clsLeftName != clsRightName)) return false;
			var clsLeftFields = Reflect.fields(left);
			clsLeftFields.sort(function(x:String, y:String) {
				if ((x > y)) return 1 else if ((x == y)) return 0 else return -1;
			});
			var clsRightFields = Reflect.fields(right);
			clsRightFields.sort(function(x:String, y:String) {
				if ((x > y)) return 1 else if ((x == y)) return 0 else return -1;
			});
			if ((hx.doctest.internal.DocTestUtils.deepEquals(clsLeftFields, clsRightFields))) {
				{
					var _g = 0;
					while ((_g < clsLeftFields.length)) {
						var fieldName = clsLeftFields[_g];
						++ _g;
						if ((! hx.doctest.internal.DocTestUtils.deepEquals(Reflect.field(left, fieldName), Reflect.field(right, fieldName)))) return false;
					};
				};
				return true;
			};
		};
		return false;
	}

	public static function substringAfter(str:String, sep:String) {
		var foundAt = str.indexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(foundAt + sep.length);
	}

	public static function substringAfterLast(str:String, sep:String) {
		var foundAt = str.lastIndexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(foundAt + sep.length);
	}

	public static function substringBefore(str:String, sep:String) {
		var foundAt = str.indexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(0, foundAt);
	}

	public static function substringBeforeLast(str:String, sep:String) {
		var foundAt = str.lastIndexOf(sep);
		if ((foundAt == -1)) return "";
		return str.substring(0, foundAt);
	}
}