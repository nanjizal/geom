@:used
private class geom.matrix._Matrix3x3.Matrix3x3_Impl_ {

	@:value(3)
	public static inline var rows:Int = 3;

	@:value(3)
	public static inline var columns:Int = 3;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat3x3) {
		var this1 = m;
		return cast this1;
	}

	@:impl
	public static inline function clone(this1:geom.structure.Mat3x3) {
		var this2 = new geom.structure.Mat3x3(this1.a, this1.b, this1.c, this1.d, this1.e, this1.f, this1.g, this1.h, this1.i);
		return cast this2;
	}

	@:impl
	public static inline function iterator(this1:geom.structure.Mat3x3) {
		var arr = [this1.a, this1.b, this1.c, this1.d, this1.e, this1.f, this1.g, this1.h, this1.i];
		return new haxe.iterators.ArrayIterator(arr);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix3x3;

	@:impl
	static inline function get_self(this1:geom.structure.Mat3x3) {
		return cast this1;
	}

	public static var zero(get,never):geom.matrix.Matrix3x3;

	static inline function get_zero() {
		var this1 = new geom.structure.Mat3x3(0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this1;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix3x3;

	@:impl
	static inline function get_nought(this1:geom.structure.Mat3x3) {
		var this1 = new geom.structure.Mat3x3(0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this1;
	}

	public static var unit(get,never):geom.matrix.Matrix3x3;

	public static inline function get_unit() {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., 0., 1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix3x3;

	@:impl
	static inline function get_one(this1:geom.structure.Mat3x3) {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., 0., 1., 0., 0., 0., 1.);
		return cast this1;
	}

	public static var minus1(get,never):geom.matrix.Matrix3x3;

	static inline function get_minus1() {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., 0., 1., 0., 0., 0., 1.);
		var a = cast this1;
		var this1 = new geom.structure.Mat3x3(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i);
		return cast this1;
	}

	public static var counting(get,never):geom.matrix.Matrix3x3;

	static inline function get_counting() {
		var this1 = new geom.structure.Mat3x3(1., 2., 3., 4., 5., 6., 7., 8., 9.);
		return cast this1;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix3x3;

	@:impl
	static inline function get_testCount(this1:geom.structure.Mat3x3) {
		var this1 = new geom.structure.Mat3x3(1., 2., 3., 4., 5., 6., 7., 8., 9.);
		return cast this1;
	}

	public static var _123456789(get,never):geom.matrix.Matrix3x3;

	static inline function get__123456789() {
		var this1 = new geom.structure.Mat3x3(1., 2., 3., 4., 5., 6., 7., 8., 9.);
		return cast this1;
	}

	public static inline function radianX(theta:Float) {
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this1 = new geom.structure.Mat3x3(1., 0., 0., 0., c, - s, 0., s, c);
		return cast this1;
	}

	@:impl
	public static inline function rotateX(this1:geom.structure.Mat3x3, theta:Float) {
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this2 = new geom.structure.Mat3x3(1., 0., 0., 0., c, - s, 0., s, c);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function radianY(theta:Float) {
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this1 = new geom.structure.Mat3x3(c, 0., s, 0., 1., cast 0, - s, 0., c);
		return cast this1;
	}

	@:impl
	public static inline function rotateY(this1:geom.structure.Mat3x3, theta:Float) {
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this2 = new geom.structure.Mat3x3(c, 0., s, 0., 1., cast 0, - s, 0., c);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function radianZ(theta:Float) {
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this1 = new geom.structure.Mat3x3(c, - s, 0., s, c, 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function rotateZ(this1:geom.structure.Mat3x3, theta:Float) {
		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var this2 = new geom.structure.Mat3x3(c, - s, 0., s, c, 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	@:impl
	public static inline function rotate(this1:geom.structure.Mat3x3, theta:Float) {
		var theta1 = - theta;
		var c = Math.cos(theta1);
		var s = Math.sin(theta1);
		var this2 = new geom.structure.Mat3x3(c, - s, 0., s, c, 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function xShear(theta:Float) {
		var this1 = new geom.structure.Mat3x3(1., Math.tan(theta), 0., cast 0, 1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function shearX(this1:geom.structure.Mat3x3, theta:Float) {
		var this2 = new geom.structure.Mat3x3(1., Math.tan(theta), 0., cast 0, 1., 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function yShear(theta:Float) {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., Math.tan(theta), 1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function shearY(this1:geom.structure.Mat3x3, theta:Float) {
		var this2 = new geom.structure.Mat3x3(1., 0., 0., Math.tan(theta), 1., 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function xFlip() {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., cast 0, -1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function flipX(this1:geom.structure.Mat3x3) {
		var this2 = new geom.structure.Mat3x3(1., 0., 0., cast 0, -1., 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function yFlip() {
		var this1 = new geom.structure.Mat3x3(-1., 0., 0., cast 0, 1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function flipY(this1:geom.structure.Mat3x3) {
		var this2 = new geom.structure.Mat3x3(-1., 0., 0., cast 0, 1., 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function xyFlip() {
		var this1 = new geom.structure.Mat3x3(-1., 0., 0., cast 0, -1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function flipXY(this1:geom.structure.Mat3x3) {
		var this2 = new geom.structure.Mat3x3(-1., 0., 0., cast 0, -1., 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function sxyz(x:Float, y:Float, z:Float) {
		var this1 = new geom.structure.Mat3x3(x, 0., 0., 0., y, 0., 0., 0., z);
		return cast this1;
	}

	@:impl
	public static inline function scaleXYZ(this1:geom.structure.Mat3x3, x:Float, y:Float, z:Float) {
		var this2 = new geom.structure.Mat3x3(x, 0., 0., 0., y, 0., 0., 0., z);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function sx(x:Float) {
		var this1 = new geom.structure.Mat3x3(x, 0., 0., 0., 1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function scaleX(this1:geom.structure.Mat3x3, x:Float) {
		var this2 = new geom.structure.Mat3x3(x, 0., 0., 0., 1., 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function sy(y:Float) {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., 0., y, 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function scaleY(this1:geom.structure.Mat3x3, y:Float) {
		var this2 = new geom.structure.Mat3x3(1., 0., 0., 0., y, 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function sz(z:Float) {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., 0., 1., 0., 0., 0., z);
		return cast this1;
	}

	@:impl
	public static inline function scaleZ(this1:geom.structure.Mat3x3, z:Float) {
		var this2 = new geom.structure.Mat3x3(1., 0., 0., 0., 1., 0., 0., 0., z);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	@:impl
	public static inline function scale(this1:geom.structure.Mat3x3, s:Float) {
		var this2 = new geom.structure.Mat3x3(s, 0., 0., 0., s, 0., 0., 0., s);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(cast this1.a * q.a + cast this1.b * q.d + cast this1.c * q.g, cast this1.a * q.b + cast this1.b * q.e + cast this1.c * q.h, cast this1.a * q.c + cast this1.b * q.f + cast this1.c * q.i, cast this1.d * q.a + cast this1.e * cast this1.d + cast this1.f * q.g, cast this1.d * q.b + cast this1.e * q.e + cast this1.f * q.h, cast this1.d * q.c + cast this1.e * q.f + cast this1.f * q.i, cast this1.g * cast this1.a + cast this1.h * q.d + cast this1.i * q.g, cast this1.g * q.b + cast this1.h * q.e + cast this1.i * q.h, cast this1.g * q.c + cast this1.h * q.f + cast this1.i * q.i);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	@:impl
	public static inline function scale2D(this1:geom.structure.Mat3x3, s:Float) {
		var this2 = new geom.structure.Mat3x3(s, 0., 0., 0., s, 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function tx(x:Float) {
		var this1 = new geom.structure.Mat3x3(1., 0., x, 0., 1., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function translateX(this1:geom.structure.Mat3x3, x:Float) {
		var this2 = new geom.structure.Mat3x3(1., 0., x, 0., 1., 0., 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	public static inline function ty(y:Float) {
		var this1 = new geom.structure.Mat3x3(1., 0., 0., 0., 1., y, 0., 0., 1.);
		return cast this1;
	}

	public static inline function txy(x:Float, y:Float) {
		var this1 = new geom.structure.Mat3x3(1., 0., x, 0., 1., y, 0., 0., 1.);
		return cast this1;
	}

	@:impl
	public static inline function translateXY(this1:geom.structure.Mat3x3, x:Float, y:Float) {
		var this2 = new geom.structure.Mat3x3(1., 0., x, 0., 1., y, 0., 0., 1.);
		var q = cast this2;
		var this2 = new geom.structure.Mat3x3(this1.a * q.a + this1.b * q.d + this1.c * q.g, this1.a * q.b + this1.b * q.e + this1.c * q.h, this1.a * q.c + this1.b * q.f + this1.c * q.i, this1.d * q.a + this1.e * this1.d + this1.f * q.g, this1.d * q.b + this1.e * q.e + this1.f * q.h, this1.d * q.c + this1.e * q.f + this1.f * q.i, this1.g * this1.a + this1.h * q.d + this1.i * q.g, this1.g * q.b + this1.h * q.e + this1.i * q.h, this1.g * q.c + this1.h * q.f + this1.i * q.i);
		return cast this2;
	}

	@:impl
	public static inline function transpose(this1:geom.structure.Mat3x3) {
		var this2 = new geom.structure.Mat3x3(this1.a, this1.d, this1.g, this1.b, this1.e, this1.h, this1.c, this1.f, this1.i);
		return cast this2;
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix3x3) {
		var this1 = new geom.structure.Mat3x3(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i);
		return cast this1;
	}

	@:impl
	public static inline function negate(this1:geom.structure.Mat3x3) {
		var this2 = new geom.structure.Mat3x3(- this1.a, - this1.b, - this1.c, - this1.d, - this1.e, - this1.f, - this1.g, - this1.h, - this1.i);
		return cast this2;
	}

	@:op(A + B)
	public static inline function adding(a:geom.matrix.Matrix3x3, b:geom.matrix.Matrix3x3) {
		var this1 = new geom.structure.Mat3x3(cast a.a + b.a, cast a.b + b.b, cast a.c + b.c, cast a.d + b.d, cast a.e + b.e, cast a.f + b.f, cast a.d + b.d, cast a.h + b.h, cast a.i + b.i);
		return cast this1;
	}

	@:impl
	public static inline function add(this1:geom.structure.Mat3x3, b:geom.matrix.Matrix3x3) {
		var this2 = new geom.structure.Mat3x3(this1.a + b.a, this1.b + b.b, this1.c + b.c, this1.d + b.d, this1.e + b.e, this1.f + b.f, this1.d + b.d, this1.h + b.h, this1.i + b.i);
		return cast this2;
	}

	@:op(A - B)
	public static inline function subtracting(a:geom.matrix.Matrix3x3, b:geom.matrix.Matrix3x3) {
		var this1 = new geom.structure.Mat3x3(cast a.a - b.a, cast a.b - b.b, cast a.c - b.c, cast a.d - b.d, cast a.e - b.e, cast a.f - b.f, cast a.g - b.g, cast a.h - b.h, cast a.i - b.i);
		return cast this1;
	}

	@:impl
	public static inline function subtract(this1:geom.structure.Mat3x3, b:geom.matrix.Matrix3x3) {
		var this2 = new geom.structure.Mat3x3(this1.a - b.a, this1.b - b.b, this1.c - b.c, this1.d - b.d, this1.e - b.e, this1.f - b.f, this1.g - b.g, this1.h - b.h, this1.i - b.i);
		return cast this2;
	}

	@:impl
	public static inline function scaleVector4(this1:geom.structure.Mat3x3, p:geom.matrix.Matrix1x4) {
		var this2 = new geom.structure.Mat3x3(this1.a * p.x, this1.b, this1.c, this1.d, this1.e * p.y, this1.f, this1.g, this1.h, this1.i * p.z);
		return cast this2;
	}

	@:impl
	public static inline function scaleVector2(this1:geom.structure.Mat3x3, p:geom.matrix.Matrix1x2) {
		var this2 = new geom.structure.Mat3x3(this1.a * p.x, this1.b, this1.c, this1.d, this1.e * p.y, this1.f, this1.g, this1.h, this1.i);
		return cast this2;
	}

	@:impl
	public static inline function scaleVectorT3(this1:geom.structure.Mat3x3, p:geom.tydef.Tmatrix1x3) {
		var this2 = new geom.structure.Mat3x3(this1.a * p.x, this1.b, this1.c, this1.d, this1.e * p.y, this1.f, this1.g, this1.h, this1.i * p.y);
		return cast this2;
	}

	@:op(A * B)
	public static inline function multiplyV(v:Float, m:geom.matrix.Matrix3x3) {
		var this1 = new geom.structure.Mat3x3(m.a * v, m.b * v, m.c * v, m.d * v, m.e * v, m.f * v, m.g * v, m.h * v, m.i * v);
		return cast this1;
	}

	@:op(A * B)
	public static inline function multiply(p:geom.matrix.Matrix3x3, q:geom.matrix.Matrix3x3) {
		var this1 = new geom.structure.Mat3x3(p.a * q.a + p.b * q.d + p.c * q.g, p.a * q.b + p.b * q.e + p.c * q.h, p.a * q.c + p.b * q.f + p.c * q.i, p.d * q.a + p.e * p.d + p.f * q.g, p.d * q.b + p.e * q.e + p.f * q.h, p.d * q.c + p.e * q.f + p.f * q.i, p.g * p.a + p.h * q.d + p.i * q.g, p.g * q.b + p.h * q.e + p.i * q.h, p.g * q.c + p.h * q.f + p.i * q.i);
		return cast this1;
	}

	@:op(A == B)
	public static inline function equal(a:geom.matrix.Matrix3x3, b:geom.matrix.Matrix3x3) {
		var delta = 0.0000001;
		return ! (Math.abs(cast a.a - b.a) >= delta || Math.abs(cast a.b - b.b) >= delta || Math.abs(cast a.c - b.c) >= delta || Math.abs(cast a.d - b.d) >= delta || Math.abs(cast a.e - b.e) >= delta || Math.abs(cast a.f - b.f) >= delta || Math.abs(cast a.g - b.g) >= delta || Math.abs(cast a.h - b.h) >= delta || Math.abs(cast a.i - b.i) >= delta);
	}

	@:impl
	public static inline function isEqual(this1:geom.structure.Mat3x3, b:geom.matrix.Matrix3x3) {
		var delta = 0.0000001;
		return ! (Math.abs(this1.a - b.a) >= delta || Math.abs(this1.b - b.b) >= delta || Math.abs(this1.c - b.c) >= delta || Math.abs(this1.d - b.d) >= delta || Math.abs(this1.e - b.e) >= delta || Math.abs(this1.f - b.f) >= delta || Math.abs(this1.g - b.g) >= delta || Math.abs(this1.h - b.h) >= delta || Math.abs(this1.i - b.i) >= delta);
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix3x3, b:geom.matrix.Matrix3x3) {
		var delta = 0.0000001;
		return (Math.abs(cast a.a - b.a) >= delta || Math.abs(cast a.b - b.b) >= delta || Math.abs(cast a.c - b.c) >= delta || Math.abs(cast a.d - b.d) >= delta || Math.abs(cast a.e - b.e) >= delta || Math.abs(cast a.f - b.f) >= delta || Math.abs(cast a.g - b.g) >= delta || Math.abs(cast a.h - b.h) >= delta || Math.abs(cast a.i - b.i) >= delta);
	}

	@:impl
	public static inline function cofactor(this1:geom.structure.Mat3x3, a:Float, b:Float, c:Float, d:Float) {
		return a * d - b * c;
	}

	@:impl
	public static inline function det(this1:geom.structure.Mat3x3) {
		return this1.a * (this1.e * this1.i - this1.f * this1.h) - this1.b * (this1.d * this1.i - this1.f * this1.g) + this1.c * (this1.d * this1.h - this1.e * this1.g);
	}

	@:impl
	public static inline function inverse(this1:geom.structure.Mat3x3) {
		var d = cast this1.a * (cast this1.e * cast this1.i - cast this1.f * cast this1.h) - cast this1.b * (cast this1.d * cast this1.i - cast this1.f * cast this1.g) + cast this1.c * (cast this1.d * cast this1.h - cast this1.e * cast this1.g);
		if ((d == 0)) return null else {
			var this2 = new geom.structure.Mat3x3(this1.e * this1.i - this1.f * this1.h, - (this1.d * this1.i - this1.f * this1.g), this1.d * this1.h - this1.e * this1.g, - (this1.b * this1.i - this1.c * this1.h), this1.a * this1.i - this1.c * this1.g, - (this1.a * this1.h - this1.b * this1.g), this1.b * this1.f - this1.c * this1.e, - (this1.a * this1.f - this1.c * this1.d), this1.a * this1.e - this1.b * this1.d);
			var adj = cast this2;
			var v = 1 / d;
			var this1 = new geom.structure.Mat3x3(adj.a * v, adj.b * v, adj.c * v, adj.d * v, adj.e * v, adj.f * v, adj.g * v, adj.h * v, adj.i * v);
			return cast this1;
		};
	}

	@:from
	public static inline function fromArr(arr:Array<Float>) {
		return geom.matrix.Conversion.Arrayto3x3(arr);
	}

	@:impl @:to
	public static inline function toArray(this1:geom.structure.Mat3x3) {
		return geom.matrix.Conversion._3x3toArray(this1);
	}

	@:impl @:to
	public static inline function to2x2(this1:geom.structure.Mat3x3) {
		return geom.matrix.Conversion._3x3to2x2(this1);
	}

	public static inline function to3D(m2:geom.matrix.Matrix2x2) {
		var this1 = new geom.structure.Mat3x3(m2.a, m2.b, 0., m2.c, m2.d, 0., 0., cast 0, 0.);
		return cast this1;
	}

	@:from
	public static inline function from2x2(m2:geom.matrix.Matrix2x2) {
		return geom.matrix.Conversion._2x2to3x3(m2);
	}

	@:impl @:to
	public static inline function to4x3(this1:geom.structure.Mat3x3) {
		return geom.matrix.Conversion._2x2to4x3(cast geom.matrix.Conversion._3x3to2x2(this1));
	}

	@:from
	public static inline function from4x3(m4:geom.matrix.Matrix4x3) {
		return geom.matrix.Conversion._4x3to3x3(cast geom.matrix.Conversion._3x3to4x3(@:implicitCast geom.matrix.Conversion._4x3to3x3(cast m4)));
	}

	@:from
	public static inline function fromVec(vec:haxe.ds.Vector<Float>) {
		return geom.matrix.Conversion.Vectorto3x3(vec);
	}

	@:impl @:to
	public static inline function toVector(this1:geom.structure.Mat3x3) {
		return geom.matrix.Conversion._3x3toVector(this1);
	}

	@:impl
	public static inline function setXY(this1:geom.structure.Mat3x3, x:Int, y:Int, v:Float) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this1.a = v;
				case 1: return this1.b = v;
				case 2: return this1.c = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix3x3")
			};
			case 1: switch ((y)) {
				case 0: return this1.d = v;
				case 1: return this1.e = v;
				case 2: return this1.f = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix3x3")
			};
			case 2: switch ((y)) {
				case 0: return this1.g = v;
				case 1: return this1.h = v;
				case 2: return this1.i = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix3x3")
			};
			default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix3x3")
		};
	}

	@:impl
	public static inline function getXY(this1:geom.structure.Mat3x3, x:Int, y:Int) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this1.a;
				case 1: return this1.b;
				case 2: return this1.c;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix3x3")
			};
			case 1: switch ((y)) {
				case 0: return this1.d;
				case 1: return this1.e;
				case 2: return this1.f;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix3x3")
			};
			case 2: switch ((y)) {
				case 0: return this1.g;
				case 1: return this1.h;
				case 2: return this1.i;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix3x3")
			};
			default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix3x3")
		};
	}
}