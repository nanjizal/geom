@:used
private class geom.matrix._Matrix5x5.Matrix5x5_Impl_ {

	@:value(5)
	public static inline var rows:Int = 5;

	@:value(5)
	public static inline var columns:Int = 5;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat5x5) {
		var this1 = m;
		return cast this1;
	}

	@:impl
	public static inline function clone(this1:geom.structure.Mat5x5) {
		var this2 = new geom.structure.Mat5x5(this1.a, this1.b, this1.c, this1.d, this1.e, this1.f, this1.g, this1.h, this1.i, this1.j, this1.k, this1.l, this1.m, this1.n, this1.o, this1.p, this1.q, this1.r, this1.s, this1.t, this1.u, this1.v, this1.w, this1.x, this1.y);
		return cast this2;
	}

	@:impl
	public static inline function iterator(this1:geom.structure.Mat5x5) {
		return new haxe.iterators.ArrayIterator([this1.a, this1.b, this1.c, this1.d, this1.e, this1.f, this1.g, this1.h, this1.i, this1.j, this1.k, this1.l, this1.m, this1.n, this1.o, this1.p, this1.q, this1.r, this1.s, this1.t, this1.u, this1.v, this1.w, this1.x, this1.y]);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_self(this1:geom.structure.Mat5x5) {
		return cast this1;
	}

	public static var zero(get,never):geom.matrix.Matrix5x5;

	static inline function get_zero() {
		var this1 = new geom.structure.Mat5x5(0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this1;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_nought(this1:geom.structure.Mat5x5) {
		var this1 = new geom.structure.Mat5x5(0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);
		return cast this1;
	}

	public static var unit(get,never):geom.matrix.Matrix5x5;

	static inline function get_unit() {
		var this1 = new geom.structure.Mat5x5(1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1.);
		return cast this1;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_one(this1:geom.structure.Mat5x5) {
		var this1 = new geom.structure.Mat5x5(1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1.);
		return cast this1;
	}

	public static var minus1(get,never):geom.matrix.Matrix5x5;

	static inline function get_minus1() {
		var this1 = new geom.structure.Mat5x5(1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 1.);
		var a = cast this1;
		var this1 = new geom.structure.Mat5x5(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i, - cast a.j, - cast a.k, - cast a.l, - cast a.m, - cast a.n, - cast a.o, - cast a.p, - cast a.q, - cast a.r, - cast a.s, - cast a.t, - cast a.u, - cast a.v, - cast a.w, - cast a.x, - cast a.y);
		return cast this1;
	}

	public static var counting(get,never):geom.matrix.Matrix5x5;

	static inline function get_counting() {
		var this1 = new geom.structure.Mat5x5(1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.);
		return cast this1;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix5x5;

	@:impl
	static inline function get_testCount(this1:geom.structure.Mat5x5) {
		var this1 = new geom.structure.Mat5x5(1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.);
		return cast this1;
	}

	@:op(A == B)
	public static inline function equal(a:geom.matrix.Matrix5x5, b:geom.matrix.Matrix5x5) {
		var delta = 0.0000001;
		return ! (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta || Math.abs(a.e - b.e) >= delta || Math.abs(a.f - b.f) >= delta || Math.abs(a.g - b.g) >= delta || Math.abs(a.h - b.h) >= delta || Math.abs(a.i - b.i) >= delta || Math.abs(a.j - b.j) >= delta || Math.abs(a.k - b.k) >= delta || Math.abs(a.l - b.l) >= delta || Math.abs(a.m - b.m) >= delta || Math.abs(a.n - b.n) >= delta || Math.abs(a.o - b.o) >= delta || Math.abs(a.p - b.p) >= delta || Math.abs(a.q - b.q) >= delta || Math.abs(a.r - b.r) >= delta || Math.abs(a.s - b.s) >= delta || Math.abs(a.t - b.t) >= delta || Math.abs(a.u - b.u) >= delta || Math.abs(a.v - b.v) >= delta || Math.abs(a.w - b.w) >= delta || Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta);
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix5x5, b:geom.matrix.Matrix5x5) {
		var delta = 0.0000001;
		return (Math.abs(a.a - b.a) >= delta || Math.abs(a.b - b.b) >= delta || Math.abs(a.c - b.c) >= delta || Math.abs(a.d - b.d) >= delta || Math.abs(a.e - b.e) >= delta || Math.abs(a.f - b.f) >= delta || Math.abs(a.g - b.g) >= delta || Math.abs(a.h - b.h) >= delta || Math.abs(a.i - b.i) >= delta || Math.abs(a.j - b.j) >= delta || Math.abs(a.k - b.k) >= delta || Math.abs(a.l - b.l) >= delta || Math.abs(a.m - b.m) >= delta || Math.abs(a.n - b.n) >= delta || Math.abs(a.o - b.o) >= delta || Math.abs(a.p - b.p) >= delta || Math.abs(a.q - b.q) >= delta || Math.abs(a.r - b.r) >= delta || Math.abs(a.s - b.s) >= delta || Math.abs(a.t - b.t) >= delta || Math.abs(a.u - b.u) >= delta || Math.abs(a.v - b.v) >= delta || Math.abs(a.w - b.w) >= delta || Math.abs(a.x - b.x) >= delta || Math.abs(a.y - b.y) >= delta);
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix5x5) {
		var this1 = new geom.structure.Mat5x5(- cast a.a, - cast a.b, - cast a.c, - cast a.d, - cast a.e, - cast a.f, - cast a.g, - cast a.h, - cast a.i, - cast a.j, - cast a.k, - cast a.l, - cast a.m, - cast a.n, - cast a.o, - cast a.p, - cast a.q, - cast a.r, - cast a.s, - cast a.t, - cast a.u, - cast a.v, - cast a.w, - cast a.x, - cast a.y);
		return cast this1;
	}

	@:impl
	public static inline function negate(this1:geom.structure.Mat5x5) {
		var this2 = new geom.structure.Mat5x5(- this1.a, - this1.b, - this1.c, - this1.d, - this1.e, - this1.f, - this1.g, - this1.h, - this1.i, - this1.j, - this1.k, - this1.l, - this1.m, - this1.n, - this1.o, - this1.p, - this1.q, - this1.r, - this1.s, - this1.t, - this1.u, - this1.v, - this1.w, - this1.x, - this1.y);
		return cast this2;
	}

	@:op(A * B)
	public static inline function multiply(r:geom.matrix.Matrix5x5, s:geom.matrix.Matrix5x5) {
		var this1 = new geom.structure.Mat5x5(r.a * s.a + r.b * s.f + r.c * s.k + r.d * s.p + r.e * s.u, r.a * s.b + r.b * s.g + r.c * s.l + r.d * s.q + r.e * s.v, r.a * s.c + r.b * s.h + r.c * s.m + r.d * s.r + r.e * s.w, r.a * s.d + r.b * s.i + r.c * s.n + r.d * s.s + r.e * s.x, r.a * s.e + r.b * s.j + r.c * s.o + r.d * s.t + r.e * s.y, r.f * s.a + r.g * s.f + r.h * s.k + r.i * s.p + r.j * s.u, r.f * s.b + r.g * s.g + r.h * s.l + r.i * s.q + r.j * s.v, r.f * s.c + r.g * s.h + r.h * s.m + r.i * s.r + r.j * s.w, r.f * s.d + r.g * s.i + r.h * s.n + r.i * s.s + r.j * s.x, r.f * s.e + r.g * s.j + r.h * s.o + r.i * s.t + r.j * s.y, r.k * s.a + r.l * s.f + r.m * s.k + r.n * s.p + r.o * s.u, r.k * s.b + r.l * s.g + r.m * s.l + r.n * s.q + r.o * s.v, r.k * s.c + r.l * s.h + r.m * s.m + r.n * s.r + r.o * s.w, r.k * s.d + r.l * s.i + r.m * s.n + r.n * s.s + r.o * s.x, r.k * s.e + r.l * s.j + r.m * s.o + r.n * s.t + r.o * s.y, r.p * s.a + r.q * s.f + r.r * s.k + r.s * s.p + r.t * s.u, r.p * s.b + r.q * s.g + r.r * s.l + r.s * s.q + r.t * s.v, r.p * s.c + r.q * s.h + r.r * s.m + r.s * s.r + r.t * s.w, r.p * s.d + r.q * s.i + r.r * s.n + r.s * s.s + r.t * s.x, r.p * s.e + r.q * s.j + r.r * s.o + r.s * s.t + r.t * s.y, r.u * s.a + r.v * s.f + r.w * s.k + r.x * s.p + r.y * s.u, r.u * s.b + r.v * s.g + r.w * s.l + r.x * s.q + r.y * s.v, r.u * s.c + r.v * s.h + r.w * s.m + r.x * s.r + r.y * s.w, r.u * s.d + r.v * s.i + r.w * s.n + r.x * s.s + r.y * s.x, r.u * s.e + r.v * s.j + r.w * s.o + r.x * s.t + r.y * s.y);
		return cast this1;
	}

	@:op(A + B)
	public static inline function add(m0:geom.matrix.Matrix5x5, m1:geom.matrix.Matrix5x5) {
		var this1 = new geom.structure.Mat5x5(m0.a + m1.a, m0.b + m1.b, m0.c + m1.c, m0.d + m1.d, m0.e + m1.e, m0.f + m1.f, m0.g + m1.g, m0.h + m1.h, m0.i + m1.i, m0.j + m1.j, m0.k + m1.k, m0.l + m1.l, m0.m + m1.m, m0.n + m1.n, m0.o + m1.o, m0.p + m1.p, m0.q + m1.q, m0.r + m1.r, m0.s + m1.s, m0.t + m1.t, m0.u + m1.u, m0.v + m1.v, m0.w + m1.w, m0.x + m1.x, m0.y + m1.y);
		return cast this1;
	}

	@:op(A - B)
	public static inline function sub(m0:geom.matrix.Matrix5x5, m1:geom.matrix.Matrix5x5) {
		var this1 = new geom.structure.Mat5x5(m0.a - m1.a, m0.b - m1.b, m0.c - m1.c, m0.d - m1.d, m0.e - m1.e, m0.f - m1.f, m0.g - m1.g, m0.h - m1.h, m0.i - m1.i, m0.j - m1.j, m0.k - m1.k, m0.l - m1.l, m0.m - m1.m, m0.n - m1.n, m0.o - m1.o, m0.p - m1.p, m0.q - m1.q, m0.r - m1.r, m0.s - m1.s, m0.t - m1.t, m0.u - m1.u, m0.v - m1.v, m0.w - m1.w, m0.x - m1.x, m0.y - m1.y);
		return cast this1;
	}

	@:impl
	public static inline function transpose(this1:geom.structure.Mat5x5) {
		var this2 = new geom.structure.Mat5x5(this1.a, this1.f, this1.k, this1.p, this1.u, this1.b, this1.g, this1.l, this1.q, this1.v, this1.c, this1.h, this1.m, this1.r, this1.w, this1.d, this1.i, this1.n, this1.s, this1.x, this1.e, this1.j, this1.o, this1.t, this1.y);
		return cast this2;
	}

	@:impl
	public static inline function setXY(this1:geom.structure.Mat5x5, x:Int, y:Int, v:Float) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this1.a = v;
				case 1: return this1.b = v;
				case 2: return this1.c = v;
				case 3: return this1.d = v;
				case 4: return this1.e = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 1: switch ((y)) {
				case 0: return this1.f = v;
				case 1: return this1.g = v;
				case 2: return this1.h = v;
				case 3: return this1.i = v;
				case 4: return this1.j = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 2: switch ((y)) {
				case 0: return this1.k = v;
				case 1: return this1.l = v;
				case 2: return this1.m = v;
				case 3: return this1.n = v;
				case 4: return this1.o = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 3: switch ((y)) {
				case 0: return this1.p = v;
				case 1: return this1.q = v;
				case 2: return this1.r = v;
				case 3: return this1.s = v;
				case 4: return this1.t = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			case 4: switch ((y)) {
				case 0: return this1.u = v;
				case 1: return this1.v = v;
				case 2: return this1.w = v;
				case 3: return this1.x = v;
				case 4: return this1.y = v;
				default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
			};
			default: throw haxe.Exception.thrown("bad set " + x + ", " + y + " on Matrix5x5")
		};
	}

	@:impl
	public static inline function getXY(this1:geom.structure.Mat5x5, x:Int, y:Int) {
		switch ((x)) {
			case 0: switch ((y)) {
				case 0: return this1.a;
				case 1: return this1.b;
				case 2: return this1.c;
				case 3: return this1.d;
				case 4: return this1.e;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 1: switch ((y)) {
				case 0: return this1.f;
				case 1: return this1.g;
				case 2: return this1.h;
				case 3: return this1.i;
				case 4: return this1.j;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 2: switch ((y)) {
				case 0: return this1.k;
				case 1: return this1.l;
				case 2: return this1.m;
				case 3: return this1.n;
				case 4: return this1.o;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 3: switch ((y)) {
				case 0: return this1.p;
				case 1: return this1.q;
				case 2: return this1.r;
				case 3: return this1.s;
				case 4: return this1.t;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			case 4: switch ((y)) {
				case 0: return this1.u;
				case 1: return this1.v;
				case 2: return this1.w;
				case 3: return this1.x;
				case 4: return this1.y;
				default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
			};
			default: throw haxe.Exception.thrown("bad get " + x + ", " + y + " on Matrix5x5")
		};
	}

	@:impl
	public static inline function pretty(this1:geom.structure.Mat5x5, prec:Int) {
		var sa = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.a, prec);
		var sb = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.b, prec);
		var sc = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.c, prec);
		var sd = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.d, prec);
		var se = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.e, prec);
		var sf = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.f, prec);
		var sg = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.g, prec);
		var sh = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.h, prec);
		var si = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.i, prec);
		var sj = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.j, prec);
		var sk = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.k, prec);
		var sl = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.l, prec);
		var sm = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.m, prec);
		var sn = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.n, prec);
		var so = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.o, prec);
		var sp = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.p, prec);
		var sq = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.q, prec);
		var sr = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.r, prec);
		var ss = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.s, prec);
		var st = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.t, prec);
		var su = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.u, prec);
		var sv = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.v, prec);
		var sw = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.w, prec);
		var sx = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.x, prec);
		var sy = geom.matrix._Matrix5x5.Matrix5x5_Impl_.floatToStringPrecision(this1.y, prec);
		var la = sa.length;
		var lb = sb.length;
		var lc = sc.length;
		var ld = sd.length;
		var le = se.length;
		var lf = sf.length;
		var lg = sg.length;
		var lh = sh.length;
		var li = si.length;
		var lj = sj.length;
		var lk = sk.length;
		var ll = sl.length;
		var lm = sm.length;
		var ln = sn.length;
		var lo = so.length;
		var lp = sp.length;
		var lq = sq.length;
		var lr = sr.length;
		var ls = ss.length;
		var lt = st.length;
		var lu = su.length;
		var lv = sv.length;
		var lw = sw.length;
		var lx = sx.length;
		var ly = sy.length;
		var r0 = Math.round(Math.max(Math.max(Math.max(Math.max(la, lf), lk), lp), lu));
		var r1 = Math.round(Math.max(Math.max(Math.max(Math.max(lb, lg), ll), lq), lv));
		var r2 = Math.round(Math.max(Math.max(Math.max(Math.max(lc, lh), lm), lr), lw));
		var r3 = Math.round(Math.max(Math.max(Math.max(Math.max(ld, li), ln), ls), lx));
		var r4 = Math.round(Math.max(Math.max(Math.max(Math.max(le, lj), lo), lt), ly));
		var spaces = "";
		{
			var _g = 0;
			var _g1 = r0;
			while ((_g < _g1)) {
				var n = _g ++;
				spaces += " ";
			};
		};
		sa = @:pure HxOverrides.substr(spaces, 0, r0 - la) + sa;
		sf = @:pure HxOverrides.substr(spaces, 0, r0 - lf) + sf;
		sk = @:pure HxOverrides.substr(spaces, 0, r0 - lk) + sk;
		sp = @:pure HxOverrides.substr(spaces, 0, r0 - lp) + sp;
		su = @:pure HxOverrides.substr(spaces, 0, r0 - lu) + su;
		var spaces = "";
		{
			var _g = 0;
			var _g1 = r1;
			while ((_g < _g1)) {
				var n = _g ++;
				spaces += " ";
			};
		};
		sb = @:pure HxOverrides.substr(spaces, 0, r1 - lb) + sb;
		sg = @:pure HxOverrides.substr(spaces, 0, r1 - lg) + sg;
		sl = @:pure HxOverrides.substr(spaces, 0, r1 - ll) + sl;
		sq = @:pure HxOverrides.substr(spaces, 0, r1 - lq) + sq;
		sv = @:pure HxOverrides.substr(spaces, 0, r1 - lv) + sv;
		var space = "";
		{
			var _g = 0;
			var _g1 = r2;
			while ((_g < _g1)) {
				var n = _g ++;
				spaces += " ";
			};
		};
		sc = @:pure HxOverrides.substr(spaces, 0, r2 - lc) + sc;
		sh = @:pure HxOverrides.substr(spaces, 0, r2 - lh) + sh;
		sm = @:pure HxOverrides.substr(spaces, 0, r2 - lm) + sm;
		sr = @:pure HxOverrides.substr(spaces, 0, r2 - lr) + sr;
		sw = @:pure HxOverrides.substr(spaces, 0, r2 - lw) + sw;
		var space = "";
		{
			var _g = 0;
			var _g1 = r3;
			while ((_g < _g1)) {
				var n = _g ++;
				spaces += " ";
			};
		};
		sd = @:pure HxOverrides.substr(spaces, 0, r3 - ld) + sd;
		si = @:pure HxOverrides.substr(spaces, 0, r3 - li) + si;
		sn = @:pure HxOverrides.substr(spaces, 0, r3 - ln) + sn;
		ss = @:pure HxOverrides.substr(spaces, 0, r3 - ls) + ss;
		sx = @:pure HxOverrides.substr(spaces, 0, r3 - lx) + sx;
		var space = "";
		{
			var _g = 0;
			var _g1 = r4;
			while ((_g < _g1)) {
				var n = _g ++;
				spaces += " ";
			};
		};
		se = @:pure HxOverrides.substr(spaces, 0, r4 - le) + se;
		sj = @:pure HxOverrides.substr(spaces, 0, r4 - lj) + sj;
		so = @:pure HxOverrides.substr(spaces, 0, r4 - lo) + so;
		st = @:pure HxOverrides.substr(spaces, 0, r4 - lt) + st;
		sy = @:pure HxOverrides.substr(spaces, 0, r4 - ly) + sy;
		return "\n" + "/ " + sa + ", " + sb + ", " + sc + ", " + sd + ", " + se + " \\\n" + "| " + sf + ", " + sg + ", " + sh + ", " + si + ", " + sj + " |\n" + "| " + sk + ", " + sl + ", " + sm + ", " + sn + ", " + so + " |\n" + "| " + sp + ", " + sq + ", " + sr + ", " + ss + ", " + st + " |\n" + "\\ " + su + ", " + sv + ", " + sw + ", " + sx + ", " + sy + " /\n";
	}

	public static inline function max5(f0:Float, f1:Float, f2:Float, f3:Float, f4:Float) {
		return Math.round(Math.max(Math.max(Math.max(Math.max(f0, f1), f2), f3), f4));
	}

	public static function floatToStringPrecision(n:Float, prec:Int) {
		if ((n == 0)) {
			var _g = [];
			{
				var _g1 = 0;
				var _g2 = prec;
				while ((_g1 < _g2)) {
					var i = _g1 ++;
					_g.push("0");
				};
			};
			return "0." + _g.join("");
		};
		var minusSign = n < 0.0;
		n = Math.abs(n);
		var intPart = Math.floor(n);
		var p = Math.pow(10, prec);
		var fracPart = Math.round(p * (n - intPart));
		var buf = new StringBuf();
		if ((minusSign)) buf.addChar(45);
		buf.add(if ((intPart == null)) "null" else "" + intPart);
		if ((fracPart == 0)) {
			buf.addChar(46);
			{
				var _g = 0;
				var _g1 = prec;
				while ((_g < _g1)) {
					var i = _g ++;
					buf.addChar(48);
				};
			};
		} else {
			buf.addChar(46);
			p /= 10;
			var nZeros = 0;
			while ((fracPart < p)) {
				p /= 10;
				buf.addChar(48);
			};
			buf.add(fracPart);
		};
		return buf.toString();
	}
}