@:used
private class geom.matrix._Matrix1x3.Matrix1x3_Impl_ {

	@:value(1)
	public static inline var rows:Int = 1;

	@:value(3)
	public static inline var columns:Int = 3;

	@:impl @:noCompletion
	public static inline function _new(m:geom.structure.Mat1x3) {
		var this1 = m;
		return cast this1;
	}

	@:impl
	public static inline function clone(this1:geom.structure.Mat1x3) {
		var this2 = new geom.structure.Mat1x3(this1.x, this1.y, this1.z);
		return cast this2;
	}

	@:impl
	public static inline function iterator(this1:geom.structure.Mat1x3) {
		return new haxe.iterators.ArrayIterator([this1.x, this1.y, this1.z]);
	}

	@:impl
	public static var self(get,never):geom.matrix.Matrix1x3;

	@:impl
	static inline function get_self(this1:geom.structure.Mat1x3) {
		return cast this1;
	}

	@:impl
	public static var magnitude(get,set):Float;

	@:impl
	static inline function get_magnitude(this1:geom.structure.Mat1x3) {
		return Math.sqrt(cast this1.x * cast this1.x + cast this1.y * cast this1.y + cast this1.z * cast this1.z);
	}

	@:impl
	static inline function set_magnitude(this1:geom.structure.Mat1x3, length:Float) {
		var currentLength = Math.sqrt(cast this1.x * cast this1.x + cast this1.y * cast this1.y + cast this1.z * cast this1.z);
		if ((currentLength == 0.)) return 0. else {
			var mul = length / currentLength;
			this1.x *= mul;
			this1.y *= mul;
			this1.z *= mul;
			return Math.sqrt(this1.x * this1.x + this1.y * this1.y + this1.z * this1.z);
		};
	}

	@:impl
	public static inline function normalize(this1:geom.structure.Mat1x3) {
		{
			var currentLength = Math.sqrt(this1.x * this1.x + this1.y * this1.y + this1.z * this1.z);
			if ((currentLength != 0.)) {
				var mul = 1. / currentLength;
				this1.x *= mul;
				this1.y *= mul;
				this1.z *= mul;
				var tmp = this1.x * this1.x + this1.y * this1.y + this1.z * this1.z;
			};
		};
		return this1;
	}

	public static var zero(get,never):geom.matrix.Matrix1x3;

	static inline function get_zero() {
		var this1 = new geom.structure.Mat1x3(0., 0., 0.);
		return cast this1;
	}

	@:impl
	static var nought(get,never):geom.matrix.Matrix1x3;

	@:impl
	static inline function get_nought(this1:geom.structure.Mat1x3) {
		var this1 = new geom.structure.Mat1x3(0., 0., 0.);
		return cast this1;
	}

	public static var unit(get,never):geom.matrix.Matrix1x3;

	public static inline function get_unit() {
		var this1 = new geom.structure.Mat1x3(1., 1., 1.);
		return cast this1;
	}

	@:impl
	static var one(get,never):geom.matrix.Matrix1x3;

	@:impl
	static inline function get_one(this1:geom.structure.Mat1x3) {
		var this1 = new geom.structure.Mat1x3(1., 1., 1.);
		return cast this1;
	}

	public static var minus1(get,never):geom.matrix.Matrix1x3;

	static inline function get_minus1() {
		var this1 = new geom.structure.Mat1x3(1., 1., 1.);
		var a = cast this1;
		var this1 = new geom.structure.Mat1x3(- cast a.x, - cast a.y, - cast a.z);
		return cast this1;
	}

	public static var counting(get,never):geom.matrix.Matrix1x3;

	static inline function get_counting() {
		var this1 = new geom.structure.Mat1x3(1., 2., 3.);
		return cast this1;
	}

	@:impl
	static var testCount(get,never):geom.matrix.Matrix1x3;

	@:impl
	static inline function get_testCount(this1:geom.structure.Mat1x3) {
		var this1 = new geom.structure.Mat1x3(1., 2., 3.);
		return cast this1;
	}

	public static inline function identity(out:geom.matrix.Matrix1x3) {
		out.x = 1.;
		out.y = 1.;
		out.z = 1.;
		return out;
	}

	public static inline function copy(pin:geom.matrix.Matrix1x3, pout:geom.matrix.Matrix1x3) {
		pout.x = pin.x;
		pout.y = pin.y;
		pout.z = pin.z;
		return pout;
	}

	@:impl
	public static inline function magnitudeSquared(this1:geom.structure.Mat1x3) {
		return this1.x * this1.x + this1.y * this1.y + this1.z * this1.z;
	}

	public static inline function scalarProduct(a:geom.matrix.Matrix1x3, b:geom.matrix.Matrix1x3) {
		return a.x * b.x + a.y * b.y + a.z * b.z;
	}

	@:impl
	public static inline function dotProd(this1:geom.structure.Mat1x3, b:geom.matrix.Matrix1x3) {
		return this1.x * b.x + this1.y * b.y + this1.z * b.z;
	}

	@:impl
	public static inline function transformPoint(this1:geom.structure.Mat1x3, t:geom.matrix.Matrix4x3) {
		var this2 = new geom.structure.Mat1x3(t.a * this1.x + t.b * this1.y + t.c * this1.z + t.d, t.e * this1.x + t.f * this1.y + t.g * this1.z + t.h, t.i * this1.x + t.j * this1.y + t.k * this1.z + t.l);
		return cast this2;
	}

	@:impl
	public static inline function cross(this1:geom.structure.Mat1x3, v:geom.matrix.Matrix1x3) {
		var this2 = new geom.structure.Mat1x3(this1.y * v.z - this1.z * v.y, this1.z * v.x - this1.x * v.z, this1.x * v.y - this1.y * v.x);
		return cast this2;
	}

	@:op(A / B)
	public static inline function divide(a:geom.matrix.Matrix1x3, v:Float) {
		var v1 = 1 / v;
		var this1 = new geom.structure.Mat1x3(cast a.x * v1, cast a.y * v1, cast a.z * v1);
		return cast this1;
	}

	@:op(A / B)
	public static inline function divide2(v:Float, a:geom.matrix.Matrix1x3) {
		var this1 = new geom.structure.Mat1x3(v / a.x, v / a.y, v / a.z);
		return cast this1;
	}

	@:op(A != B)
	public static inline function notEqual(a:geom.matrix.Matrix1x3, b:geom.matrix.Matrix1x3) {
		var delta = 0.0000001;
		return (Math.abs(cast a.x - b.x) >= delta || Math.abs(cast a.y - b.y) >= delta || Math.abs(cast a.z - b.z) >= delta);
	}

	@:op(-A)
	public static inline function negating(a:geom.matrix.Matrix1x3) {
		var this1 = new geom.structure.Mat1x3(- cast a.x, - cast a.y, - cast a.z);
		return cast this1;
	}

	@:impl
	public static inline function negate(this1:geom.structure.Mat1x3) {
		var this2 = new geom.structure.Mat1x3(- this1.x, - this1.y, - this1.z);
		return cast this2;
	}

	@:op(A - B)
	public static inline function subtracting(a:geom.matrix.Matrix1x3, b:geom.matrix.Matrix1x3) {
		var this1 = new geom.structure.Mat1x3(cast a.x - b.x, cast a.y - b.y, cast a.z - b.z);
		return cast this1;
	}

	@:impl
	public static inline function subtract(this1:geom.structure.Mat1x3, b:geom.matrix.Matrix1x3) {
		var this2 = new geom.structure.Mat1x3(this1.x - b.x, this1.y - b.y, this1.z - b.z);
		return cast this2;
	}

	@:op(A + B)
	public static inline function adding(a:geom.matrix.Matrix1x3, b:geom.matrix.Matrix1x3) {
		var this1 = new geom.structure.Mat1x3(cast a.x + b.x, cast a.y + b.y, cast a.z + b.z);
		return cast this1;
	}

	@:impl
	public static inline function add(this1:geom.structure.Mat1x3, b:geom.matrix.Matrix1x3) {
		var this2 = new geom.structure.Mat1x3(this1.x + b.x, this1.y + b.y, this1.z + b.z);
		return cast this2;
	}

	@:op(A * B) @:commutative
	public static inline function scaleMultiplying(a:geom.matrix.Matrix1x3, v:Float) {
		var this1 = new geom.structure.Mat1x3(cast a.x * v, cast a.y * v, cast a.z * v);
		return cast this1;
	}

	@:impl
	public static inline function scaleMultiply(this1:geom.structure.Mat1x3, v:Float) {
		var this2 = new geom.structure.Mat1x3(this1.x * v, this1.y * v, this1.z * v);
		return cast this2;
	}

	@:op(A == B)
	public static inline function isEqualling(a:geom.matrix.Matrix1x3, b:geom.matrix.Matrix1x3) {
		var delta = 0.0000001;
		return ! (Math.abs(cast a.x - b.x) >= delta || Math.abs(cast a.y - b.y) >= delta || Math.abs(cast a.z - b.z) >= delta);
	}

	@:impl
	public static inline function isEqual(this1:geom.structure.Mat1x3, b:geom.matrix.Matrix1x3) {
		var delta = 0.0000001;
		return ! (Math.abs(this1.x - b.x) >= delta || Math.abs(this1.y - b.y) >= delta || Math.abs(this1.z - b.z) >= delta);
	}

	@:from
	public static inline function fromVec(vec:haxe.ds.Vector<Float>) {
		return geom.matrix.Conversion.Vectorto1x3(vec);
	}

	@:impl
	public static inline function staticFromVec(this1:geom.structure.Mat1x3, vec:haxe.ds.Vector<Float>) {
		return geom.matrix.Conversion.Vectorto1x3(vec);
	}

	@:impl @:to
	public static inline function toVector(this1:geom.structure.Mat1x3) {
		return geom.matrix.Conversion._1x3toVector(this1);
	}

	@:from
	public static inline function fromArray(arr:Array<Float>) {
		return geom.matrix.Conversion.Arrayto1x3(arr);
	}

	@:impl
	public static inline function staticFromArray(this1:geom.structure.Mat1x3, arr:Array<Float>) {
		return geom.matrix.Conversion.Arrayto1x3(arr);
	}

	@:impl @:to
	public static inline function toArray(this1:geom.structure.Mat1x3) {
		return geom.matrix.Conversion._1x3toArray(this1);
	}

	@:impl @:op([])
	public static inline function readItem(this1:geom.structure.Mat1x3, k:Int) {
		switch ((k)) {
			case 0: return this1.x;
			case 1: return this1.y;
			case 2: return this1.z;
			default: throw haxe.Exception.thrown("index needs to be below 4")
		};
	}

	@:impl @:op([])
	public static inline function writeItem(this1:geom.structure.Mat1x3, k:Int, v:Float) {
		switch ((k)) {
			case 0: this1.x = v;
			case 1: this1.y = v;
			case 3: this1.z = v;
			default: throw haxe.Exception.thrown("index needs to be below 4")
		};
		return v;
	}
}