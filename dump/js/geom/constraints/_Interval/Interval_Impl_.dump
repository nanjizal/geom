@:used
private class geom.constraints._Interval.Interval_Impl_ {

	@:impl @:noCompletion
	public static inline function _new(interval:geom.structure.Range) {
		var this1 = interval;
		return cast this1;
	}

	@:impl
	public static inline function valid(this1:geom.structure.Range) {
		return this1.u > this1.l;
	}

	@:impl
	public static inline function fix(this1:geom.structure.Range) {
		if ((! (cast this1.u > cast this1.l))) {
			var l = this1.u;
			this1.u = this1.l;
			this1.l = l;
		};
	}

	@:impl
	public static inline function clampClosed(this1:geom.structure.Range, v:Float) {
		if ((v <= this1.l)) return this1.l else if ((v >= this1.u)) return this1.u else return v;
	}

	@:impl
	public static inline function clampOpen(this1:geom.structure.Range, v:Float) {
		if ((v < cast this1.l)) return this1.l else if ((v > cast this1.u)) return this1.u else return v;
	}

	@:value({ delta : 0.00001 }) @:impl
	public static inline function close(this1:geom.structure.Range, v:Float, delta:Float = 0.00001) {
		var interval = new geom.structure.Range(this1.u + delta, this1.l - delta);
		return v == (if ((v <= cast interval.l)) cast interval.l else if ((v >= cast interval.u)) cast interval.u else v);
	}

	@:impl
	public static inline function above(this1:geom.structure.Range, v:Float) {
		return v > this1.u;
	}

	@:impl
	public static inline function below(this1:geom.structure.Range, v:Float) {
		return v < this1.l;
	}

	@:impl
	public static inline function inClampOpen(this1:geom.structure.Range, v:Float) {
		return v == (if ((v < cast this1.l)) cast this1.l else if ((v > cast this1.u)) cast this1.u else v);
	}

	@:impl
	public static inline function inClampClosed(this1:geom.structure.Range, v:Float) {
		return v == (if ((v <= cast this1.l)) cast this1.l else if ((v >= cast this1.u)) cast this1.u else v);
	}

	public static inline function unit(v:Float) {
		var interval = new geom.structure.Range(1., 0.);
		if ((v <= cast interval.l)) return cast interval.l else if ((v >= cast interval.u)) return cast interval.u else return v;
	}

	public static inline function unitFloat(v:Float) {
		var interval = new geom.structure.Range(1., -1.);
		if ((v <= cast interval.l)) return cast interval.l else if ((v >= cast interval.u)) return cast interval.u else return v;
	}

	public static inline function unitNegative(v:Float) {
		var interval = new geom.structure.Range(1., -1.);
		if ((v <= cast interval.l)) return cast interval.l else if ((v >= cast interval.u)) return cast interval.u else return v;
	}

	public static inline function inUnitFloat(v:Float) {
		var interval = new geom.structure.Range(1., -1.);
		return v == (if ((v <= cast interval.l)) cast interval.l else if ((v >= cast interval.u)) cast interval.u else v);
	}

	@:impl
	public static inline function random(this1:geom.structure.Range) {
		return Math.random() * (this1.u - this1.l) + this1.l;
	}

	@:impl
	public static inline function randomInt(this1:geom.structure.Range) {
		return Math.round(Math.random() * (cast this1.u - cast this1.l) + cast this1.l);
	}
}