@:keep @:directlyUsed @:used @:coreApi
class Type {

	public static function getClass<T : getClass.T>(o:getClass.T) {
		return js.Boot.getClass(o);
	}

	@:has_untyped
	public static function getEnum(o:EnumValue) {
		if ((o == null)) return null;
		return $hxEnums[o.__enum__];
	}

	@:has_untyped
	public static function getClassName(c:Class<Dynamic>) {
		return __define_feature__("Type.getClassName", c.__name__);
	}

	@:has_untyped
	public static function getEnumName(e:Enum<Dynamic>) {
		return __define_feature__("Type.getEnumName", e.__ename__);
	}

	public static function getInstanceFields(c:Class<Dynamic>) {
		var a = [];
		js.Syntax.code("for(var i in c.prototype) a.push(i)");
		HxOverrides.remove(a, "__class__");
		HxOverrides.remove(a, "__properties__");
		return a;
	}

	@:has_untyped @:access(js.Boot)
	public static function typeof(v:Dynamic) {
		switch ((js.Syntax.typeof(v))) {
			case "boolean": return ValueType.TBool;
			case "function": {
				if ((js.Boot.isClass(v) || js.Boot.isEnum(v))) return ValueType.TObject;
				return ValueType.TFunction;
			};
			case "number": {
				if ((Math.ceil(v) == v % 2147483648.0)) return ValueType.TInt;
				return ValueType.TFloat;
			};
			case "object": {
				if ((v == null)) return ValueType.TNull;
				var e = v.__enum__;
				if ((e != null)) return ValueType.TEnum($hxEnums[e]);
				var c = js.Boot.getClass(v);
				if ((c != null)) return ValueType.TClass(c);
				return ValueType.TObject;
			};
			case "string": return ValueType.TClass(String);
			case "undefined": return ValueType.TNull;
			default: return ValueType.TUnknown
		};
	}

	@:has_untyped
	public static function enumEq<T : enumEq.T>(a:enumEq.T, b:enumEq.T) {
		if ((a == b)) return true;
		try {
			var e = a.__enum__;
			if ((e == null || e != b.__enum__)) return false;
			if ((a._hx_index != b._hx_index)) return false;
			var enm = $hxEnums[e];
			var ctorName = enm.__constructs__[a._hx_index];
			var params = enm[ctorName].__params__;
			{
				var _g = 0;
				while ((_g < params.length)) {
					var f = params[_g];
					++ _g;
					if ((! Type.enumEq(a[f], b[f]))) return false;
				};
			};
		} catch (_g:Dynamic) {
			haxe.NativeStackTrace.saveStack(_g);
			return false;
		};
		return true;
	}

	@:has_untyped
	public static function enumConstructor(e:EnumValue) {
		return $hxEnums[e.__enum__].__constructs__[e._hx_index];
	}

	@:has_untyped
	public static function enumParameters(e:EnumValue) {
		var enm = $hxEnums[e.__enum__];
		var ctorName = enm.__constructs__[e._hx_index];
		var params = enm[ctorName].__params__;
		if ((params != null)) {
			var _g = [];
			{
				var _g1 = 0;
				while ((_g1 < params.length)) {
					var p = params[_g1];
					++ _g1;
					_g.push(e[p]);
				};
			};
			return _g;
		} else return [];
	}

	@:has_untyped
	public static function enumIndex(e:EnumValue) {
		return e._hx_index;
	}
}