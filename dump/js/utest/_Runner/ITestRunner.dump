@:directlyUsed @:used @:access(utest.Runner.iTestFixtures) @:access(utest.Runner.runNext) @:access(utest.Runner.runFixture) @:access(utest.Runner.executedFixtures)
private class utest._Runner.ITestRunner {

	public function new(runner:utest.Runner) {
		this.runner = runner;
	}

	var runner:utest.Runner;

	var cases:Iterator<utest.ITest>;

	var currentCase:utest.ITest;

	var currentCaseFixtures:Array<utest.TestFixture>;

	var teardownClass:Void -> utest.Async;

	var setupAsync:utest.Async;

	var teardownAsync:utest.Async;

	public function run() {
		this.cases = cast cast this.runner.iTestFixtures.keys();
		this.runCases();
	}

	function runCases() {
		while ((this.cases.hasNext())) {
			this.currentCase = this.cases.next();
			var data = cast cast this.runner.iTestFixtures.get(this.currentCase);
			this.currentCaseFixtures = data.fixtures;
			this.teardownClass = data.teardownClass;
			try {
				this.setupAsync = data.setupClass();
			} catch (_g:Dynamic) {
				haxe.NativeStackTrace.saveStack(_g);
				var e = cast haxe.Exception.caught(_g).unwrap();
				this.setupFailed(utest.Assertation.SetupError("setupClass failed: " + Std.string(e), haxe._CallStack.CallStack_Impl_.exceptionStack()));
				return;
			};
			if ((this.setupAsync.resolved)) {
				if ((! this.runFixtures())) return;
			} else {
				this.setupAsync.then(this.checkSetup);
				return;
			};
		};
		this.runner.runNext();
	}

	function checkSetup() {
		if ((this.setupAsync.timedOut)) this.setupFailed(utest.Assertation.SetupError("setupClass timeout", [])) else this.runFixtures();
	}

	function setupFailed(assertation:utest.Assertation) {
		this.runner.executedFixtures += this.currentCaseFixtures.length;
		this.runner.onProgress.dispatch({totals : this.runner.length, result : utest.TestResult.ofFailedSetupClass(this.currentCase, assertation), done : this.runner.executedFixtures});
		this.runCases();
	}

	function runFixtures(finishedHandler:Null<utest.TestHandler<utest.TestFixture>> = null) {
		while ((this.currentCaseFixtures.length > 0)) {
			var handler = this.runner.runFixture(this.currentCaseFixtures.pop());
			if ((! handler.finished)) {
				handler.onComplete.add(this.runFixtures);
				return false;
			};
		};
		try {
			this.teardownAsync = this.teardownClass();
		} catch (_g:Dynamic) {
			haxe.NativeStackTrace.saveStack(_g);
			var e = cast haxe.Exception.caught(_g).unwrap();
			this.teardownFailed(utest.Assertation.TeardownError("tearDownClass failed: " + Std.string(e), haxe._CallStack.CallStack_Impl_.exceptionStack()));
		};
		if ((this.teardownAsync.resolved && finishedHandler == null)) return true;
		this.teardownAsync.then(this.checkTeardown);
		return false;
	}

	function checkTeardown() {
		if ((this.teardownAsync.timedOut)) this.teardownFailed(utest.Assertation.TeardownError("teardownClass timeout", []));
		this.runCases();
	}

	function teardownFailed(assertation:utest.Assertation) {
		this.runner.onProgress.dispatch({totals : this.runner.length, result : utest.TestResult.ofFailedTeardownClass(this.currentCase, assertation), done : this.runner.executedFixtures});
	}
}