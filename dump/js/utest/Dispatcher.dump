@:directlyUsed @:used
class utest.Dispatcher<T : utest.Dispatcher.T> {

	public function new() {
		this.handlers = new Array();
	}

	var handlers:Array<utest.Dispatcher.T -> Void>;

	public function add(h:utest.Dispatcher.T -> Void) {
		this.handlers.push(h);
		return h;
	}

	public function remove(h:utest.Dispatcher.T -> Void) {
		{
			var _g = 0;
			var _g1 = this.handlers.length;
			while ((_g < _g1)) {
				var i = _g ++;
				if ((Reflect.compareMethods(this.handlers[i], h))) return this.handlers.splice(i, 1)[0];
			};
		};
		return null;
	}

	public function clear() {
		this.handlers = new Array();
	}

	public function dispatch(e:utest.Dispatcher.T) {
		try {
			var list = cast this.handlers.slice();
			{
				var _g = 0;
				while ((_g < list.length)) {
					var l = list[_g];
					++ _g;
					l(e);
				};
			};
			return true;
		} catch (_g:Dynamic) {
			haxe.NativeStackTrace.saveStack(_g);
			if ((Std.isOfType(cast haxe.Exception.caught(_g).unwrap(), utest._Dispatcher.EventException))) return false else throw _g;
		};
	}

	public function has() {
		return this.handlers.length > 0;
	}

	public static function stop() {
		throw haxe.Exception.thrown(utest._Dispatcher.EventException.StopPropagation);
	}
}