@:keep @:directlyUsed @:used @:dox(hide) @:noCompletion @:allow(haxe.Exception)
class haxe.NativeStackTrace {

	static var lastError:Error;

	@:noCompletion
	public static var wrapCallSite:haxe.V8CallSite -> haxe.V8CallSite;

	@:ifFeature("haxe.NativeStackTrace.exceptionStack")
	public static function saveStack(e:Error) {
		haxe.NativeStackTrace.lastError = e;
	}

	public static function callStack() {
		var e = new Error("");
		var stack = haxe.NativeStackTrace.tryHaxeStack(e);
		if ((js.Syntax.typeof(stack) == "undefined")) {
			try {
				throw e;
			} catch (_g:Dynamic) {};
			stack = @:implicitCast cast e.stack;
		};
		return haxe.NativeStackTrace.normalize(stack, 2);
	}

	public static function exceptionStack() {
		return haxe.NativeStackTrace.normalize(haxe.NativeStackTrace.tryHaxeStack(haxe.NativeStackTrace.lastError));
	}

	@:value({ skip : 0 })
	public static function toHaxe(s:Null<Any>, skip:Int = 0) {
		if ((s == null)) return [] else if ((js.Syntax.typeof(s) == "string")) {
			var stack = @:implicitCast cast cast s.split("\n");
			if ((stack[0] == "Error")) stack.shift();
			var m = [];
			{
				var _g = 0;
				var _g1 = stack.length;
				while ((_g < _g1)) {
					var i = _g ++;
					if ((skip > i)) continue;
					var line = stack[i];
					var matched = js.Syntax.code("{0}.match(/^    at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/)", line);
					if ((matched != null)) {
						var path = matched[1].split(".");
						if ((path[0] == "$hxClasses")) path.shift();
						var meth = path.pop();
						var file = matched[2];
						var line1 = Std.parseInt(matched[3]);
						var column = Std.parseInt(matched[4]);
						m.push(haxe.StackItem.FilePos(if ((meth == "Anonymous function")) haxe.StackItem.LocalFunction() else if ((meth == "Global code")) null else haxe.StackItem.Method(path.join("."), meth), file, line1, column));
					} else m.push(haxe.StackItem.Module(StringTools.trim(line)));
				};
			};
			return m;
		} else if ((skip > 0 && js.Syntax.code("Array.isArray({0})", s))) return @:implicitCast cast cast s.slice(skip) else return cast s;
	}

	static function tryHaxeStack(e:Null<Error>) {
		if ((e == null)) return @:implicitCast cast [];
		var oldValue = Error.prepareStackTrace;
		Error.prepareStackTrace = haxe.NativeStackTrace.prepareHxStackTrace;
		var stack = e.stack;
		Error.prepareStackTrace = oldValue;
		return @:implicitCast cast stack;
	}

	static function prepareHxStackTrace(e:Error, callsites:Array<haxe.V8CallSite>) {
		var stack = [];
		{
			var _g = 0;
			while ((_g < callsites.length)) {
				var site = callsites[_g];
				++ _g;
				if ((haxe.NativeStackTrace.wrapCallSite != null)) site = haxe.NativeStackTrace.wrapCallSite(site);
				var method = null;
				var fullName = site.getFunctionName();
				if ((fullName != null)) {
					var idx = fullName.lastIndexOf(".");
					if ((idx >= 0)) {
						var className = fullName.substring(0, idx);
						var methodName = fullName.substring(idx + 1);
						method = haxe.StackItem.Method(className, methodName);
					} else method = haxe.StackItem.Method(null, fullName);
				};
				var fileName = site.getFileName();
				var fileAddr = if ((fileName == null)) -1 else fileName.indexOf("file:");
				if ((haxe.NativeStackTrace.wrapCallSite != null && fileAddr > 0)) fileName = fileName.substring(fileAddr + 6);
				stack.push(haxe.StackItem.FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));
			};
		};
		return @:implicitCast cast stack;
	}

	@:value({ skipItems : 0 })
	static function normalize(stack:Any, skipItems:Int = 0) {
		if ((js.Syntax.code("Array.isArray({0})", stack) && skipItems > 0)) return cast @:implicitCast cast cast stack.slice(skipItems) else if ((js.Syntax.typeof(stack) == "string")) {
			switch ((@:implicitCast cast cast stack.substring(0, 6))) {
				case "Error\n", "Error:": ++ skipItems;
				default: {}
			};
			return cast haxe.NativeStackTrace.skipLines(@:implicitCast cast cast stack, skipItems);
		} else return stack;
	}

	@:value({ pos : 0 })
	static function skipLines(stack:String, skip:Int, pos:Int = 0) {
		if ((skip > 0)) {
			pos = stack.indexOf("\n", pos);
			if ((pos < 0)) return "" else return haxe.NativeStackTrace.skipLines(stack, -- skip, pos + 1);
		} else return stack.substring(pos);
	}
}